<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>同步、异步、阻塞、非阻塞</title>
    <url>/archives/55b0962b.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h3 id="IO操作">IO操作</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CopyIO分两阶段（一旦拿到数据后就变成了数据操作，不再是IO）：</span><br><span class="line"><span class="code">    1.数据准备阶段</span></span><br><span class="line"><span class="code">    2.内核空间复制数据到用户进程缓冲区（用户空间）阶段</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">在操作系统中，程序运行的空间分为内核空间和用户空间。</span><br><span class="line"><span class="code">    应用程序都是运行在用户空间的，所以它们能操作的数据也都在用户空间。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">阻塞IO和非阻塞IO的区别在于第一步发起IO请求是否会被阻塞：</span><br><span class="line"><span class="code">    如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">一般来讲：</span><br><span class="line"><span class="code">    阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">同步IO和异步IO的区别就在于第二个步骤是否阻塞：</span><br><span class="line"><span class="code">    如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><img src="https://s2.loli.net/2024/04/05/d3vbT5BYtQhRXOe.png" alt="img"></p>
<h3 id="同步和异步IO-阻塞和非阻塞IO">同步和异步IO 阻塞和非阻塞IO</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Copy同步和异步IO的概念：</span><br><span class="line"></span><br><span class="line">	同步是用户线程发起<span class="selector-tag">I</span>/O请求后需要等待或者轮询内核<span class="selector-tag">I</span>/O操作完成后才能继续执行</span><br><span class="line"></span><br><span class="line">	异步是用户线程发起<span class="selector-tag">I</span>/O请求后仍需要继续执行，当内核<span class="selector-tag">I</span>/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数</span><br><span class="line"></span><br><span class="line">阻塞和非阻塞IO的概念：</span><br><span class="line"></span><br><span class="line">	阻塞是指<span class="selector-tag">I</span>/O操作需要彻底完成后才能返回用户空间</span><br><span class="line"></span><br><span class="line">	非阻塞是指<span class="selector-tag">I</span>/O操作被调用后立即返回一个状态值，无需等<span class="selector-tag">I</span>/O操作彻底完成</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/04/05/BYdKQewpI9iA5v1.png" alt="img"></p>
<p><img src="https://s2.loli.net/2024/04/05/5RqyJZeK6Hc8E91.png" alt="img"></p>
<p><img src="https://s2.loli.net/2024/04/05/lsnL8egyqQ6pA2N.png" alt="img"></p>
<h3 id="同步与异步（线程间调用）">同步与异步（线程间调用）</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Copy同步与异步是对应于调用者与被调用者，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的</span><br><span class="line"></span><br><span class="line"><span class="code">	同步操作时，调用者需要等待被调用者返回结果，才会进行下一步操作</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	而异步则相反，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果</span></span><br></pre></td></tr></table></figure>
<h3 id="阻塞与非阻塞（线程内调用）同步与异步调用-线程-通信">阻塞与非阻塞（线程内调用）同步与异步调用/线程/通信</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Copy同步就是两种东西通过一种机制实现步调一致，异步是两种东西不必步调一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一、同步调用与异步调用：</span><br><span class="line"></span><br><span class="line"><span class="code">    在用在调用场景中，无非是对调用结果的不同处理。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    同步调用就是调用一但返回，就能知道结果，而异步是返回时不一定知道结果，还得通过其他机制来获知结果，如：</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        a. 状态 b. 通知 c. 回调函数</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">二、同步线程与异步线程：</span><br><span class="line"></span><br><span class="line"><span class="code">    同步线程：即两个线程步调要一致，其中一个线程可能要阻塞等待另外一个线程的运行，要相互协商。快的阻塞一下等到慢的步调一致。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    异步线程：步调不用一致，各自按各自的步调运行，不受另一个线程的影响。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">三、同步通信与异步通信：</span><br><span class="line"></span><br><span class="line"><span class="code">    同步和异步是指：发送方和接收方是否协调步调一致</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    同步通信是指：发送方和接收方通过一定机制，实现收发步调协调。</span></span><br><span class="line"><span class="code">        如：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    异步通信是指：发送方的发送不管接收方的接收状态。</span></span><br><span class="line"><span class="code">        如：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">阻塞可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。</span><br><span class="line"></span><br><span class="line">同步是两个对象之间的关系，而阻塞是一个对象的状态。</span><br></pre></td></tr></table></figure>
<h3 id="四种组合方式">四种组合方式</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Copy同步阻塞方式：</span><br><span class="line"><span class="code">    发送方发送请求之后一直等待响应。</span></span><br><span class="line"><span class="code">    接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">同步非阻塞方式：</span><br><span class="line"><span class="code">	发送方发送请求之后，一直等待响应。</span></span><br><span class="line"><span class="code">	接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。</span></span><br><span class="line"><span class="code">	但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。</span></span><br><span class="line"><span class="code">	当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">异步阻塞方式：</span><br><span class="line"><span class="code">	发送方向接收方请求后，不等待响应，可以继续其他工作。</span></span><br><span class="line"><span class="code">	接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">异步非阻塞方式：</span><br><span class="line"><span class="code">	发送方向接收方请求后，不等待响应，可以继续其他工作。</span></span><br><span class="line"><span class="code">	接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。</span></span><br><span class="line"><span class="code">	当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数详解</title>
    <url>/archives/d59d73b9.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<p>这里先额外介绍一下C++类的存储方式，然后介绍虚函数。</p>
<p>C++程序的内存格局通常分为五个区：全局数据区（data area）,代码区（code area）、栈区（stack area）、堆区（heap area）（即自由存储区）,文字常量区。全局数据区存放全局变量和静态变量，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；文字常量区存储常量字符串，程序结束后由系统释放，余下的空间都被称为堆区。类的存储方式如下图所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/qzYkw63xWavR7XA.png" alt=""></p>
 <span id="more"></span>
<p>其中对象数据中存储非静态成员变量、虚函数表指针以及虚基类表指针（如果继承多个）。这里就有一个问题，既然对象里不存储类的成员函数的指针，那类的对象是怎么调用公用函数代码的呢？对象对公用函数代码的调用是在编译阶段就已经决定了的，例如有类对象a，成员函数为show()，如果有代码a.show()，那么在编译阶段会解释为 类名::show(&amp;a)。会给show()传一个对象的指针，即this指针。</p>
<p>从上面的this指针可以说明一个问题：静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，但是类为什么只能直接调用静态成员函数，而非静态成员函数（即使函数没有参数）只有类对象能够调用的问题？原因是类的非静态成员函数其实都内含了一个指向类对象的指针型参数（即this指针），因而只有类对象才能调用（此时this指针有实值）。</p>
<h2 id="虚函数表">虚函数表</h2>
<h3 id="内存布局">内存布局</h3>
<p>先说一下虚函数表的内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/Qz6Km5FUToVgtra.png" alt=""></p>
<p>每一个有虚函数的类都有一个虚函数表，虚函数是整个类所共有的，虚函数表存储在对象内存最开始的位置。如果子类继承了多个父类，并且父类有虚函数，则子类要存储多个虚函数指针。如上图所示，如果继承了n个父类，并且每个父类都有虚函数，那子类会有n个虚函数表指针。</p>
<h3 id="无继承">无继承</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base a;</span><br><span class="line">    Fun pf = <span class="literal">NULL</span>, pg = <span class="literal">NULL</span>, ph = <span class="literal">NULL</span>;</span><br><span class="line">    pf = (Fun)*((<span class="type">int</span>*)*((<span class="type">int</span>*)(&amp;a)));</span><br><span class="line">    pg = (Fun)*((<span class="type">int</span>*)*((<span class="type">int</span>*)(&amp;a))+<span class="number">1</span>);</span><br><span class="line">    ph = (Fun)*((<span class="type">int</span>*)*((<span class="type">int</span>*)(&amp;a))+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">pf</span>();</span><br><span class="line">    <span class="built_in">pg</span>();</span><br><span class="line">    <span class="built_in">ph</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Base的内存布局（<a href="https://blog.csdn.net/tennysonsky/article/details/52054291">类查看内存布局的方法</a>）：</p>
<p><img src="https://s2.loli.net/2023/11/11/g7B5TP6v3I4Xiha.png" alt=""></p>
<p>运行结果：</p>
<p><img src="https://s2.loli.net/2023/11/11/IFboJqH2B6fsNkV.png" alt=""></p>
<p>Base类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/seCQExyJrHB6438.png" alt=""></p>
<p>这里的sizeof(a) = 8 是虚函数表指针的大小 4 和 data的大小4。图3 最后一个虚函数表中的最后一个位置表示虚函数表的结束。</p>
<h3 id="一般继承（无虚函数覆盖）">一般继承（无虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node a;</span><br><span class="line">    Base b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/qMJKmtcWdGjYR2N.png" alt=""></p>
<p>输出结果：</p>
<p><img src="https://s2.loli.net/2023/11/11/XgQAPLhWk7Bnsio.png" alt=""></p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/zQci9L3IPGpJr4W.png" alt=""></p>
<p>如图4 所以，虚函数表现存储父类的虚函数，然后存子类的虚函数。</p>
<h3 id="一般继承（有虚函数覆盖）">一般继承（有虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="comment">//覆盖Base的f()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node a;</span><br><span class="line">    Base b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局:</p>
<p><img src="https://s2.loli.net/2023/11/11/iGzUsxoN2OTuWaQ.png" alt=""></p>
<p>类Base内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/RcOmu81sjNUgboV.png" alt=""></p>
<p>输出结果同上一个。</p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/gq21fsGLEQI3Rbo.png" alt=""></p>
<p>如图5 所示，如果子类覆盖了父类的虚函数，则父类的虚函数会替换为子类的虚函数，没有被覆盖的虚函数依旧，这样当把子类的地址赋给父类指针的时候就可以实现多态了。</p>
<h3 id="多重继承（无虚函数覆盖）">多重继承（无虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 b1;</span><br><span class="line">    Base2 b2;</span><br><span class="line">    Base3 b3;</span><br><span class="line">    Node a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b1) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b2) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b3) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/4SXV1MLEKYw6yrq.png" alt=""></p>
<p>输出结果：</p>
<p><img src="https://s2.loli.net/2023/11/11/AexRiWschFuY9dz.png" alt=""></p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/K7QB2VXDGLeJjFZ.png" alt=""></p>
<p>如图6 所示，虚函数表的指针是按照声明的顺序来的，子类的虚函数放入第一个虚函数表里。</p>
<h3 id="多重继承（有虚函数覆盖）">多重继承（有虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;  <span class="comment">//覆盖父类的f()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 b1;</span><br><span class="line">    Base2 b2;</span><br><span class="line">    Base3 b3;</span><br><span class="line">    Node a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/ziLgvSfOqUBet1N.png" alt=""></p>
<p>输出结果为：</p>
<p><img src="https://s2.loli.net/2023/11/11/KoUtNAq9u7La6vQ.png" alt=""></p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/Eay7YNCD1wz6eSR.png" alt=""></p>
<p>如图 7所示，父类被覆盖的函数f()，都被替换为子类的虚函数f()。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 虚函数表详解【建议收藏】: <a href="https://bbs.huaweicloud.com/blogs/302735">https://bbs.huaweicloud.com/blogs/302735</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门教程</title>
    <url>/archives/29207ea7.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Git简介">Git简介</h2>
<p><code>Git</code> 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 <code>Git</code> 来做自己的文档版本管理工具。</p>
<p>大概是大二的时候开始接触和使用Git，从一开始的零接触到现在的重度依赖，真是感叹 <code>Git</code> 的强大。</p>
<p><code>Git</code> 的api很多，但其实平时项目中90%的需求都只需要用到几个基本的功能即可，所以本文将从 <code>实用主义</code> 和 <code>深入探索</code> 2个方面去谈谈如何在项目中使用 <code>Git</code>，一般来说，看完 <code>实用主义</code> 这一节就可以开始在项目中动手用。</p>
<blockquote>
<p>“</p>
<p>说明：本文的操作都是基于 Mac 系统</p>
</blockquote>
<span id="more"></span>
<h2 id="实用主义">实用主义</h2>
<h3 id="准备阶段">准备阶段</h3>
<p>进入 Git官网 下载合适你的安装包，安装好 <code>Git</code> 后，打开命令行工具，进入工作文件夹（<em>为了便于理解我们在系统桌面上演示</em>），创建一个新的demo文件夹。</p>
<p><img src="https://s2.loli.net/2023/11/09/3pCe2amBO4Dh9tl.png" alt=""></p>
<p>进入 Github网站 注册一个账号并登录，进入 我的博客，点击 <code>Clone or download</code>，再点击 <code>Use HTTPS</code> ，复制项目地址 <code>https://github.com/gafish/gafish.github.com.git</code> 备用。</p>
<p>再回到命令行工具，一切就绪，接下来进入本文的重点。</p>
<h3 id="常用操作">常用操作</h3>
<p>所谓实用主义，就是掌握了以下知识就可以玩转 <code>Git</code>，轻松应对90%以上的需求。以下是实用主义型的Git命令列表，先大致看一下</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>git clone</code></p>
</li>
<li class="lvl-2">
<p><code>git config</code></p>
</li>
<li class="lvl-2">
<p><code>git branch</code></p>
</li>
<li class="lvl-2">
<p><code>git checkout</code></p>
</li>
<li class="lvl-2">
<p><code>git status</code></p>
</li>
<li class="lvl-2">
<p><code>git add</code></p>
</li>
<li class="lvl-2">
<p><code>git commit</code></p>
</li>
<li class="lvl-2">
<p><code>git push</code></p>
</li>
<li class="lvl-2">
<p><code>git pull</code></p>
</li>
<li class="lvl-2">
<p><code>git log</code></p>
</li>
<li class="lvl-2">
<p><code>git tag</code></p>
</li>
</ul>
<p>接下来，将通过对 我的博客 仓库进行实例操作，讲解如何使用 <code>Git</code> 拉取代码到提交代码的整个流程。</p>
<h4 id="git-clone">git clone</h4>
<blockquote>
<p>“</p>
<p>从git服务器拉取代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/gafish/gafish.github.com.git</span><br></pre></td></tr></table></figure>
<p>代码下载完成后在当前文件夹中会有一个 <code>gafish.github.com</code> 的目录，通过 <code>cd gafish.github.com</code> 命令进入目录。</p>
<h4 id="git-config">git config</h4>
<blockquote>
<p>“</p>
<p>配置开发者用户名和邮箱</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name gafish</span><br><span class="line">git config user.email gafish@qqqq.com</span><br></pre></td></tr></table></figure>
<p>每次代码提交的时候都会生成一条提交记录，其中会包含当前配置的用户名和邮箱。</p>
<h4 id="git-branch">git branch</h4>
<blockquote>
<p>“</p>
<p>创建、重命名、查看、删除项目分支，通过 <code>Git</code> 做项目开发时，一般都是在开发分支中进行，开发完成后合并分支到主干。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch daily/0.0.0</span><br></pre></td></tr></table></figure>
<p>创建一个名为 <code>daily/0.0.0</code> 的日常开发分支，分支名只要不包括特殊字符即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -m daily/0.0.0 daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>如果觉得之前的分支名不合适，可以为新建的分支重命名，重命名分支名为 <code>daily/0.0.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>通过不带参数的branch命令可以查看当前项目分支列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>如果分支已经完成使命则可以通过 <code>-d</code> 参数将分支删除，这里为了继续下一步操作，暂不执行删除操作</p>
<h4 id="git-checkout">git checkout</h4>
<blockquote>
<p>“</p>
<p>切换分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>切换到 <code>daily/0.0.1</code> 分支，后续的操作将在这个分支上进行</p>
<h4 id="git-status">git status</h4>
<blockquote>
<p>“</p>
<p>查看文件变动状态</p>
</blockquote>
<p>通过任何你喜欢的编辑器对项目中的 <code>README.md</code> 文件做一些改动，保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>通过 <code>git status</code> 命令可以看到文件当前状态 <code>Changes not staged for commit:</code>（<em>改动文件未提交到暂存区</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch daily/0.0.1</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    modified:   README.md</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="git-add">git add</h4>
<blockquote>
<p>“</p>
<p>添加文件变动到暂存区</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure>
<p>通过指定文件名 <code>README.md</code> 可以将该文件添加到暂存区，如果想添加所有文件可用 <code>git add .</code> 命令，这时候可通过 <code>git status</code> 看到文件当前状态 <code>Changes to be committed:</code> （<em>文件已提交到暂存区</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch daily/0.0.1</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure>
<h4 id="git-commit">git commit</h4>
<blockquote>
<p>“</p>
<p>提交文件变动到版本库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;这里写提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>通过 <code>-m</code> 参数可直接在命令行里输入提交描述文本</p>
<h4 id="git-push">git push</h4>
<blockquote>
<p>“</p>
<p>将本地的代码改动推送到服务器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin daily/0.0.1</span><br></pre></td></tr></table></figure>
<p><code>origin</code> 指代的是当前的git服务器地址，这行命令的意思是把 <code>daily/0.0.1</code> 分支推送到服务器，当看到命令行返回如下字符表示推送成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local objects.</span><br><span class="line">To https://github.com/gafish/gafish.github.com.git</span><br><span class="line"> * [new branch]      daily/0.0.1 -&gt; daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>现在我们回到Github网站的项目首页，点击 <code>Branch:master</code> 下拉按钮，就会看到刚才推送的 <code>daily/00.1</code> 分支了</p>
<h4 id="git-pull">git pull</h4>
<blockquote>
<p>“</p>
<p>将服务器上的最新代码拉取到本地</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>如果其它项目成员对项目做了改动并推送到服务器，我们需要将最新的改动更新到本地，这里我们来模拟一下这种情况。</p>
<p>进入Github网站的项目首页，再进入 <code>daily/0.0.1</code> 分支，在线对 <code>README.md</code> 文件做一些修改并保存，然后在命令中执行以上命令，它将把刚才在线修改的部分拉取到本地，用编辑器打开 <code>README.md</code> ，你会发现文件已经跟线上的内容同步了。</p>
<p><em>如果线上代码做了变动，而你本地的代码也有变动，拉取的代码就有可能会跟你本地的改动冲突，一般情况下 <code>Git</code> 会自动处理这种冲突合并，但如果改动的是同一行，那就需要手动来合并代码，编辑文件，保存最新的改动，再通过 <code>git add .</code>和 <code>git commit -m 'xxx'</code> 来提交合并。</em></p>
<h4 id="git-log">git log</h4>
<blockquote>
<p>“</p>
<p>查看版本提交记录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>通过以上命令，我们可以查看整个项目的版本提交记录，它里面包含了<code>提交人</code>、<code>日期</code>、<code>提交原因</code>等信息，得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit c334730f8dba5096c54c8ac04fdc2b31ede7107a</span><br><span class="line">Author: gafish &lt;gafish@qqqq.com&gt;</span><br><span class="line">Date:   Wed Jan 11 09:44:13 2017 +0800</span><br><span class="line">    Update README.md</span><br><span class="line">commit ba6e3d21fcb1c87a718d2a73cdd11261eb672b2a</span><br><span class="line">Author: gafish &lt;gafish@qqqq.com&gt;</span><br><span class="line">Date:   Wed Jan 11 09:31:33 2017 +0800</span><br><span class="line">    test</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>提交记录可能会非常多，按 <code>J</code> 键往下翻，按 <code>K</code> 键往上翻，按 <code>Q</code> 键退出查看</p>
<h4 id="git-tag">git tag</h4>
<blockquote>
<p>“</p>
<p>为项目标记里程碑</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag publish/0.0.1</span><br><span class="line">git push origin publish/0.0.1</span><br></pre></td></tr></table></figure>
<p>当我们完成某个功能需求准备发布上线时，应该将此次完整的项目代码做个标记，并将这个标记好的版本发布到线上，这里我们以 <code>publish/0.0.1</code> 为标记名并发布，当看到命令行返回如下内容则表示发布成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/gafish/gafish.github.com.git</span><br><span class="line"> * [new tag]         publish/0.0.1 -&gt; publish/0.0.1</span><br></pre></td></tr></table></figure>
<h4 id="gitignore">.gitignore</h4>
<blockquote>
<p>“</p>
<p>设置哪些内容不需要推送到服务器，这是一个配置文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure>
<p><code>.gitignore</code> 不是 <code>Git</code> 命令，而在项目中的一个文件，通过设置 <code>.gitignore</code> 的内容告诉 <code>Git</code> 哪些文件应该被忽略不需要推送到服务器，通过以上命令可以创建一个 <code>.gitignore</code> 文件，并在编辑器中打开文件，每一行代表一个要忽略的文件或目录，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo.html</span><br><span class="line">build/</span><br></pre></td></tr></table></figure>
<p>以上内容的意思是 <code>Git</code> 将忽略 <code>demo.html</code> 文件 和 <code>build/</code> 目录，这些内容不会被推送到服务器上</p>
<h4 id="小结">小结</h4>
<p>通过掌握以上这些基本命令就可以在项目中开始用起来了，如果追求实用，那关于 <code>Git</code> 的学习就可以到此结束了，偶尔遇到的问题也基本上通过 <code>Google</code> 也能找到答案，如果想深入探索 <code>Git</code> 的高阶功能，那就继续往下看 <code>深入探索</code> 部分。</p>
<h2 id="深入探索">深入探索</h2>
<h3 id="基本概念">基本概念</h3>
<h4 id="工作区（Working-Directory）">工作区（<em>Working Directory</em>）</h4>
<p>就是你在电脑里能看到的目录，比如上文中的 <code>gafish.github.com</code> 文件夹就是一个工作区<img src="https://s2.loli.net/2023/11/09/nbtfv64AZhByPRC.jpg" alt=""></p>
<h4 id="本地版本库（Local-Repository）">本地版本库（<em>Local Repository</em>）</h4>
<p>工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库。</p>
<p><img src="https://s2.loli.net/2023/11/09/mCwzseD6itVTPLr.jpg" alt=""></p>
<h4 id="暂存区（stage）">暂存区（<em>stage</em>）</h4>
<p>本地版本库里存了很多东西，其中最重要的就是称为 <code>stage</code>（或者叫index）的暂存区，还有 <code>Git</code> 为我们自动创建的第一个分支 <code>master</code>，以及指向 <code>master</code> 的一个指针叫 <code>HEAD</code>。</p>
<h4 id="远程版本库（Remote-Repository）">远程版本库（<em>Remote Repository</em>）</h4>
<p>一般指的是 <code>Git</code> 服务器上所对应的仓库，本文的示例所在的<code>github</code>仓库就是一个远程版本库<img src="https://s2.loli.net/2023/11/09/mAtY1qnOJVd2oRb.jpg" alt=""></p>
<h4 id="以上概念之间的关系">以上概念之间的关系</h4>
<p><code>工作区</code>、<code>暂存区</code>、<code>本地版本库</code>、<code>远程版本库</code>之间几个常用的 <code>Git</code> 操作流程如下图所示：</p>
<p><img src="https://s2.loli.net/2023/11/09/uj36xbnd7MsPRpa.jpg" alt=""></p>
<h4 id="分支（Branch）">分支（<em>Branch</em>）</h4>
<p>分支是为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改</p>
<p><img src="https://s2.loli.net/2023/11/09/yKgbNPiQkcB9RuU.png" alt=""></p>
<h4 id="主分支（Master）">主分支（<em>Master</em>）</h4>
<p>前面提到过 <code>master</code> 是 <code>Git</code> 为我们自动创建的第一个分支，也叫主分支，其它分支开发完成后都要合并到 <code>master</code></p>
<p><img src="https://s2.loli.net/2023/11/09/rUVFvK3J9elEqon.png" alt=""></p>
<h4 id="标签（Tag）">标签（<em>Tag</em>）</h4>
<p>标签是用于标记特定的点或提交的历史，通常会用来标记发布版本的名称或版本号（如：<code>publish/0.0.1</code>），虽然标签看起来有点像分支，但打上标签的提交是固定的，不能随意的改动，参见上图中的<code>1.0</code> / <code>2.0</code> / <code>3.0</code></p>
<h4 id="HEAD">HEAD</h4>
<p><code>HEAD</code> 指向的就是当前分支的最新提交</p>
<p><img src="https://s2.loli.net/2023/11/09/Xkp9wrj3F6gCInN.png" alt=""></p>
<blockquote>
<p>“</p>
<p>以上概念了解的差不多，那就可以继续往下看，下面将以具体的操作类型来讲解 <code>Git</code> 的高阶用法</p>
</blockquote>
<h3 id="操作文件">操作文件</h3>
<h4 id="git-add-2">git add</h4>
<blockquote>
<p>“</p>
<p>添加文件到暂存区</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure>
<p>通过此命令将打开交互式子命令系统，你将看到如下子命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***Commands***</span><br><span class="line">  1: status      2: update      3: revert      4: add untracked</span><br><span class="line">  5: patch      6: diff      7: quit      8: help</span><br></pre></td></tr></table></figure>
<p>通过输入序列号或首字母可以选择相应的功能，具体的功能解释如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>status</code>：功能上和 <code>git add -i</code> 相似，没什么鸟用</p>
</li>
<li class="lvl-2">
<p><code>update</code>：详见下方 <code>git add -u</code></p>
</li>
<li class="lvl-2">
<p><code>revert</code>：把已经添加到暂存区的文件从暂存区剔除，其操作方式和 <code>update</code>类似</p>
</li>
<li class="lvl-2">
<p><code>add untracked</code>：可以把新增的文件添加到暂存区，其操作方式和 <code>update</code> 类似</p>
</li>
<li class="lvl-2">
<p><code>patch</code>：详见下方 <code>git add -p</code></p>
</li>
<li class="lvl-2">
<p><code>diff</code>：比较暂存区文件和本地版本库的差异，其操作方式和 <code>update</code> 类似</p>
</li>
<li class="lvl-2">
<p><code>quit</code>：退出 <code>git add -i</code> 命令系统</p>
</li>
<li class="lvl-2">
<p><code>help</code>：查看帮助信息</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure>
<p>直接进入交互命令中最有用的 <code>patch</code> 模式</p>
<p>这是交互命令中最有用的模式，其操作方式和 <code>update</code> 类似，选择后 <code>Git</code> 会显示这些文件的当前内容与本地版本库中的差异，然后您可以自己决定是否添加这些修改到暂存区，在命令行 <code>Stage deletion [y,n,q,a,d,/,?]?</code> 后输入 <code>y,n,q,a,d,/,?</code> 其中一项选择操作方式，具体功能解释如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>y：接受修改</p>
</li>
<li class="lvl-2">
<p>n：忽略修改</p>
</li>
<li class="lvl-2">
<p>q：退出当前命令</p>
</li>
<li class="lvl-2">
<p>a：添加修改</p>
</li>
<li class="lvl-2">
<p>d：放弃修改</p>
</li>
<li class="lvl-2">
<p>/：通过正则表达式匹配修改内容</p>
</li>
<li class="lvl-2">
<p>?：查看帮助信息</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure>
<p>直接进入交互命令中的 <code>update</code> 模式</p>
<p>它会先列出工作区 <code>修改</code> 或 <code>删除</code> 的文件列表，<code>新增</code> 的文件不会被显示，在命令行 <code>Update&gt;&gt;</code> 后输入相应的列表序列号表示选中该项，回车继续选择，如果已选好，直接回车回到命令主界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add --ignore-removal .</span><br></pre></td></tr></table></figure>
<p>添加工作区 <code>修改</code> 或 <code>新增</code> 的文件列表， <code>删除</code> 的文件不会被添加</p>
<h4 id="git-commit-2">git commit</h4>
<blockquote>
<p>“</p>
<p>把暂存区的文件提交到本地版本库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;第一行提交原因&#x27;  -m &#x27;第二行提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>不打开编辑器，直接在命令行中输入多行提交原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -am &#x27;提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>将工作区 <code>修改</code> 或 <code>删除</code> 的文件提交到本地版本库， <code>新增</code> 的文件不会被提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend -m &#x27;提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>修改最新一条提交记录的提交原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -C HEAD</span><br></pre></td></tr></table></figure>
<p>将当前文件改动提交到 <code>HEAD</code> 或当前分支的历史ID</p>
<h4 id="git-mv">git mv</h4>
<blockquote>
<p>“</p>
<p>移动或重命名文件、目录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv a.md b.md -f</span><br></pre></td></tr></table></figure>
<p>将 <code>a.md</code> 重命名为 <code>b.md</code> ，同时添加变动到暂存区，加 <code>-f</code> 参数可以强制重命名，相比用 <code>mv a.md b.md</code> 命令省去了 <code>git add</code> 操作</p>
<h4 id="git-rm">git rm</h4>
<blockquote>
<p>“</p>
<p>从工作区和暂存区移除文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm b.md</span><br></pre></td></tr></table></figure>
<p>从工作区和暂存区移除文件 <code>b.md</code> ，同时添加变动到暂存区，相比用 <code>rm b.md</code> 命令省去了 <code>git add</code> 操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm src/ -r</span><br></pre></td></tr></table></figure>
<p>允许从工作区和暂存区移除目录</p>
<h4 id="git-status-2">git status</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure>
<p>以简短方式查看工作区和暂存区文件状态，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> M demo.html</span><br><span class="line">?? test.html</span><br><span class="line">git status --ignored</span><br></pre></td></tr></table></figure>
<p>查看工作区和暂存区文件状态，包括被忽略的文件</p>
<h3 id="操作分支">操作分支</h3>
<h4 id="git-branch-2">git branch</h4>
<blockquote>
<p>“</p>
<p>查看、创建、删除分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>查看本地版本库和远程版本库上的分支列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<p>查看远程版本库上的分支列表，加上 <code>-d</code> 参数可以删除远程版本库上的分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -D</span><br></pre></td></tr></table></figure>
<p>分支未提交到本地版本库前强制删除分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>
<p>查看带有最后提交id、最近提交原因等信息的本地版本库分支列表</p>
<p><img src="https://s2.loli.net/2023/11/09/vC3FyE5qDUiur9f.png" alt=""></p>
<h4 id="git-merge">git merge</h4>
<blockquote>
<p>“</p>
<p>将其它分支合并到当前分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge --squash</span><br></pre></td></tr></table></figure>
<p>将待合并分支上的 <code>commit</code> 合并成一个新的 <code>commit</code> 放入当前分支，适用于待合并分支的提交记录不需要保留的情况<img src="https://s2.loli.net/2023/11/09/KB5hNOTbUcn1sCE.gif" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>Git</code> 执行&quot;<code>快进式合并</code>&quot;（fast-farward merge），会直接将 <code>Master</code>分支指向 <code>Develop</code> 分支，使用 <code>--no-ff</code> 参数后，会执行正常合并，在 <code>Master</code>分支上生成一个新节点，保证版本演进更清晰。</p>
<p><img src="https://s2.loli.net/2023/11/09/bC41XyFQdtiW32s.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge --no-edit</span><br></pre></td></tr></table></figure>
<p>在没有冲突的情况下合并，不想手动编辑提交原因，而是用 <code>Git</code> 自动生成的类似 <code>Merge branch 'test'</code> 的文字直接提交</p>
<h4 id="git-checkout-2">git checkout</h4>
<blockquote>
<p>“</p>
<p>切换分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>创建 <code>daily/0.0.1</code> 分支，同时切换到这个新创建的分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout HEAD demo.html</span><br></pre></td></tr></table></figure>
<p>从本地版本库的 <code>HEAD</code>（也可以是提交ID、分支名、Tag名） 历史中检出 <code>demo.html</code> 覆盖当前工作区的文件，如果省略 <code>HEAD</code> 则是从暂存区检出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --orphan new_branch</span><br></pre></td></tr></table></figure>
<p>这个命令会创建一个全新的，完全没有历史记录的新分支，但当前源分支上所有的最新文件都还在，真是强迫症患者的福音，但这个新分支必须做一次 <code>git commit</code>操作后才会真正成为一个新分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -p other_branch</span><br></pre></td></tr></table></figure>
<p>这个命令主要用来比较两个分支间的差异内容，并提供交互式的界面来选择进一步的操作，这个命令不仅可以比较两个分支间的差异，还可以比较单个文件的差异。</p>
<h4 id="git-stash">git stash</h4>
<blockquote>
<p>“</p>
<p>在 <code>Git</code> 的栈中保存当前修改或删除的工作进度，当你在一个分支里做某项功能开发时，接到通知把昨天已经测试完没问题的代码发布到线上，但这时你已经在这个分支里加入了其它未提交的代码，这个时候就可以把这些未提交的代码存到栈里。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>将未提交的文件保存到Git栈中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>查看栈中保存的列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash show stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>显示栈中其中一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>移除栈中其中一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>从Git栈中检出最新保存的一条记录，并将它从栈中移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>从Git栈中检出其中一条记录，但不从栈中移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash branch new_banch</span><br></pre></td></tr></table></figure>
<p>把当前栈中最近一次记录检出并创建一个新分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
<p>清空栈里的所有记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash create</span><br></pre></td></tr></table></figure>
<p>为当前修改或删除的文件创建一个自定义的栈并返回一个ID，此时并未真正存储到栈里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash store xxxxxx</span><br></pre></td></tr></table></figure>
<p>将 <code>create</code> 方法里返回的ID放到 <code>store</code> 后面，此时在栈里真正创建了一个记录，但当前修改或删除的文件并未从工作区移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash create</span><br><span class="line">09eb9a97ad632d0825be1ece361936d1d0bdb5c7</span><br><span class="line">$ git stash store 09eb9a97ad632d0825be1ece361936d1d0bdb5c7</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: Created via &quot;git stash store&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="操作历史">操作历史</h3>
<h4 id="git-log-2">git log</h4>
<blockquote>
<p>“</p>
<p>显示提交历史记录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure>
<p>显示带提交差异对比的历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log demo.html</span><br></pre></td></tr></table></figure>
<p>显示 <code>demo.html</code> 文件的历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --since=&quot;2 weeks ago&quot;</span><br></pre></td></tr></table></figure>
<p>显示2周前开始到现在的历史记录，其它时间可以类推</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --before=&quot;2 weeks ago&quot;</span><br></pre></td></tr></table></figure>
<p>显示截止到2周前的历史记录，其它时间可以类推</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -10</span><br></pre></td></tr></table></figure>
<p>显示最近10条历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log f5f630a..HEAD</span><br></pre></td></tr></table></figure>
<p>显示从提交ID <code>f5f630a</code> 到 <code>HEAD</code> 之间的记录，<code>HEAD</code> 可以为空或其它提交ID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>在一行中输出简短的历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h&quot;</span><br></pre></td></tr></table></figure>
<p>格式化输出历史记录</p>
<p><code>Git</code> 用各种 <code>placeholder</code> 来决定各种显示内容，我挑几个常用的显示如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>%H: commit hash</p>
</li>
<li class="lvl-2">
<p>%h: 缩短的commit hash</p>
</li>
<li class="lvl-2">
<p>%T: tree hash</p>
</li>
<li class="lvl-2">
<p>%t: 缩短的 tree hash</p>
</li>
<li class="lvl-2">
<p>%P: parent hashes</p>
</li>
<li class="lvl-2">
<p>%p: 缩短的 parent hashes</p>
</li>
<li class="lvl-2">
<p>%an: 作者名字</p>
</li>
<li class="lvl-2">
<p>%aN: mailmap的作者名</p>
</li>
<li class="lvl-2">
<p>%ae: 作者邮箱</p>
</li>
<li class="lvl-2">
<p>%ad: 日期 (–date= 制定的格式)</p>
</li>
<li class="lvl-2">
<p>%ar: 日期, 相对格式(1 day ago)</p>
</li>
<li class="lvl-2">
<p>%cn: 提交者名字</p>
</li>
<li class="lvl-2">
<p>%ce: 提交者 email</p>
</li>
<li class="lvl-2">
<p>%cd: 提交日期 (–date= 制定的格式)</p>
</li>
<li class="lvl-2">
<p>%cr: 提交日期, 相对格式(1 day ago)</p>
</li>
<li class="lvl-2">
<p>%d: ref名称</p>
</li>
<li class="lvl-2">
<p>%s: commit信息标题</p>
</li>
<li class="lvl-2">
<p>%b: commit信息内容</p>
</li>
<li class="lvl-2">
<p>%n: 换行</p>
</li>
</ul>
<h4 id="git-cherry-pick">git cherry-pick</h4>
<blockquote>
<p>“</p>
<p>合并分支的一条或几条提交记录到当前分支末梢</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick 170a305</span><br></pre></td></tr></table></figure>
<p>合并提交ID <code>170a305</code> 到当前分支末梢</p>
<h4 id="git-reset">git reset</h4>
<blockquote>
<p>“</p>
<p>将当前的分支重设（reset）到指定的 <code>&lt;commit&gt;</code> 或者 <code>HEAD</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --mixed &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<p><code>--mixed</code> 是不带参数时的默认参数，它退回到某个版本，保留文件内容，回退提交历史</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --soft &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<p>暂存区和工作区中的内容不作任何改变，仅仅把 <code>HEAD</code> 指向 <code>&lt;commit&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<p>自从 <code>&lt;commit&gt;</code> 以来在工作区中的任何改变都被丢弃，并把 <code>HEAD</code> 指向 <code>&lt;commit&gt;</code></p>
<h4 id="git-rebase">git rebase</h4>
<blockquote>
<p>“</p>
<p>重新定义分支的版本库状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase branch_name</span><br></pre></td></tr></table></figure>
<p>合并分支，这跟 <code>merge</code> 很像，但还是有本质区别，看下图：</p>
<p><img src="https://s2.loli.net/2023/11/09/WgEdkbiAX6nHuyK.jpg" alt=""></p>
<p>合并过程中可能需要先解决冲突，然后执行 <code>git rebase --continue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~~</span><br></pre></td></tr></table></figure>
<p>打开文本编辑器，将看到从 <code>HEAD</code> 到 <code>HEAD~~</code> 的提交如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 9a54fd4 添加commit的说明</span><br><span class="line">pick 0d4a808 添加pull的说明</span><br><span class="line"># Rebase 326fc9f..0d4a808 onto d286baa</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>将第一行的 <code>pick</code> 改成 <code>Commands</code> 中所列出来的命令，然后保存并退出，所对应的修改将会生效。如果移动提交记录的顺序，将改变历史记录中的排序。</p>
<h4 id="git-revert">git revert</h4>
<blockquote>
<p>“</p>
<p>撤销某次操作，此次操作之前和之后的 <code>commit</code> 和 <code>history</code> 都会保留，并且把这次撤销作为一次最新的提交</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure>
<p>撤销前一次提交操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert HEAD --no-edit</span><br></pre></td></tr></table></figure>
<p>撤销前一次提交操作，并以默认的 <code>Revert &quot;xxx&quot;</code> 为提交原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert -n HEAD</span><br></pre></td></tr></table></figure>
<p>需要撤销多次操作的时候加 <code>-n</code> 参数，这样不会每次撤销操作都提交，而是等所有撤销都完成后一起提交</p>
<h4 id="git-diff">git diff</h4>
<blockquote>
<p>“</p>
<p>查看工作区、暂存区、本地版本库之间的文件差异，用一张图来解释</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/6t2I5GeE1WYS4ur.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --stat</span><br></pre></td></tr></table></figure>
<p>通过 <code>--stat</code> 参数可以查看变更统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.md | 1 -</span><br><span class="line">1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure>
<h4 id="git-reflog">git reflog</h4>
<p><code>reflog</code> 可以查看所有分支的所有操作记录（包括commit和reset的操作、已经被删除的commit记录，跟 <code>git log</code> 的区别在于它不能查看已经删除了的commit记录<img src="https://s2.loli.net/2023/11/11/VpM9WLKwcDItBHn.jpg" alt=""></p>
<h3 id="远程版本库连接">远程版本库连接</h3>
<p>如果在GitHub项目初始化之前，文件已经存在于本地目录中，那可以在本地初始化本地版本库，再将本地版本库跟远程版本库连接起来</p>
<h4 id="git-init">git init</h4>
<blockquote>
<p>“</p>
<p>在本地目录内部会生成.git文件夹</p>
</blockquote>
<h4 id="git-remote">git remote</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>不带参数，列出已经存在的远程分支，加上 <code>-v</code> 列出详细信息，在每一个名字后面列出其远程url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/gafish/gafish.github.com.git</span><br></pre></td></tr></table></figure>
<p>添加一个新的远程仓库，指定一个名字，以便引用后面带的URL</p>
<h4 id="git-fetch">git fetch</h4>
<blockquote>
<p>“</p>
<p>将远程版本库的更新取回到本地版本库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>git fetch</code> 取回所有分支的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<h3 id="问题排查">问题排查</h3>
<h4 id="git-blame">git blame</h4>
<blockquote>
<p>“</p>
<p>查看文件每行代码块的历史信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git blame -L 1,10 demo.html</span><br></pre></td></tr></table></figure>
<p>截取 <code>demo.html</code> 文件1-10行历史信息</p>
<h4 id="git-bisect">git bisect</h4>
<blockquote>
<p>“</p>
<p>二分查找历史记录，排查BUG</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect start</span><br></pre></td></tr></table></figure>
<p>开始二分查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect bad</span><br></pre></td></tr></table></figure>
<p>标记当前二分提交ID为有问题的点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect good</span><br></pre></td></tr></table></figure>
<p>标记当前二分提交ID为没问题的点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect reset</span><br></pre></td></tr></table></figure>
<p>查到有问题的提交ID后回到原分支</p>
<h3 id="更多操作">更多操作</h3>
<h4 id="git-submodule">git submodule</h4>
<blockquote>
<p>“</p>
<p>通过 Git 子模块可以跟踪外部版本库，它允许在某一版本库中再存储另一版本库，并且能够保持2个版本库完全独立</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/gafish/demo.git demo</span><br></pre></td></tr></table></figure>
<p>将 <code>demo</code> 仓库添加为子模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update demo</span><br></pre></td></tr></table></figure>
<p>更新子模块 <code>demo</code></p>
<h4 id="git-gc">git gc</h4>
<blockquote>
<p>“</p>
<p>运行Git的垃圾回收功能，清理冗余的历史快照</p>
</blockquote>
<h4 id="git-archive">git archive</h4>
<blockquote>
<p>“</p>
<p>将加了tag的某个版本打包提取</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git archive -v --format=zip v0.1 &gt; v0.1.zip</span><br></pre></td></tr></table></figure>
<p><code>--format</code> 表示打包的格式，如 <code>zip</code>，<code>-v</code> 表示对应的tag名，后面跟的是tag名，如 <code>v0.1</code>。</p>
<h2 id="总结">总结</h2>
<p>本文只是对 <code>Git</code> 的所有功能中的部分实用功能做了一次探秘，Git非常强大，还有很多功能有待我们去发现，限于本文篇幅，咱就此打住吧，预知更多好用功能，请善用谷歌。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	gafish-<a href="https://github.com/gafish/gafish.github.com">https://github.com/gafish/gafish.github.com</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim入门教程</title>
    <url>/archives/e72b9632.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<p>你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。</p>
<p><a href="http://www.vim.org/">Vim</a> the Six Billion Dollar editor</p>
<blockquote>
<p>Better, Stronger, Faster.</p>
</blockquote>
<p>学习 <a href="http://www.vim.org/">vim</a> 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p>
<span id="more"></span>
<p>我建议下面这四个步骤：</p>
<ol>
<li class="lvl-3">
<p>存活</p>
</li>
<li class="lvl-3">
<p>感觉良好</p>
</li>
<li class="lvl-3">
<p>觉得更好，更强，更快</p>
</li>
<li class="lvl-3">
<p>使用VIM的超能力</p>
</li>
</ol>
<p>当你走完这篇文章，你会成为一个vim的 superstar。</p>
<p>在开始学习以前，我需要给你一些警告：学习vim在开始时是痛苦的；需要时间；需要不断地练习，就像你学习一个乐器一样；不要期望你能在3天内把vim练得比别的编辑器更有效率；事实上，你需要2周时间的苦练，而不是3天。</p>
<h3 id="第一级-–-存活">第一级 – 存活</h3>
<ol>
<li class="lvl-3">
<p>安装 <a href="http://www.vim.org/">vim</a></p>
</li>
<li class="lvl-3">
<p>启动 vim</p>
</li>
<li class="lvl-3">
<p><strong>什么也别干！</strong> 请先阅读</p>
</li>
</ol>
<p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>启 动Vim后，vim在 <em>Normal</em> 模式下。</p>
</li>
<li class="lvl-2">
<p>让我们进入 <em>Insert</em> 模式，请按下键 <code>i </code>。(vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</p>
</li>
<li class="lvl-2">
<p>此时，你可以输入文本了，就像你用“记事本”一样。</p>
</li>
<li class="lvl-2">
<p>如果你想返回 <em>Normal</em> 模式，请按 <code>ESC</code> 键。</p>
</li>
</ul>
<p>现在，你知道如何在 <em>Insert</em> 和 <em>Normal</em> 模式下切换了。下面是一些命令，可以让你在 <em>Normal</em> 模式下幸存下来：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</p>
</li>
<li class="lvl-2">
<p><code>x</code> → 删当前光标所在的一个字符。</p>
</li>
<li class="lvl-2">
<p><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)  （:w 后可以跟文件名）</p>
</li>
<li class="lvl-2">
<p><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</p>
</li>
<li class="lvl-2">
<p><code>p</code> → 粘贴剪贴板</p>
</li>
</ul>
<p><strong>推荐</strong>:</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</p>
</li>
<li class="lvl-2">
<p><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（退出帮助需要输入:q）</p>
</li>
</ul>
</blockquote>
<p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>当是，在你进入第二级时，需要再说一下 <em>Normal</em> 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 <code>Ctrl</code> 键，比如：<code>Ctrl-C</code>。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，<strong>在VIM的Normal模式下，所有的键就是功能键了</strong>。这个你需要知道。</p>
<p>标记:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>下面的文字中，如果是 <code>Ctrl-λ</code>我会写成 <code>&lt;C-λ&gt;</code>.</p>
</li>
<li class="lvl-2">
<p>以 <code>:</code> 开始的命令你需要输入 <code>&lt;enter&gt;</code>回车，例如 — 如果我写成 <code>:q</code> 也就是说你要输入 <code>:q&lt;enter&gt;</code>.</p>
</li>
</ul>
<h3 id="第二级-–-感觉良好">第二级 – 感觉良好</h3>
<p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）</p>
<ol>
<li class="lvl-3">
<p><strong>各种插入模式</strong></p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>a</code> → 在光标后插入</li>
<li class="lvl-2"><code>o</code> → 在当前行后插入一个新行</li>
<li class="lvl-2"><code>O</code> → 在当前行前插入一个新行</li>
<li class="lvl-2"><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>简单的移动光标</strong></p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>0</code> → 数字零，到行头</li>
<li class="lvl-2"><code>^</code> → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li>
<li class="lvl-2"><code>$</code> → 到本行行尾</li>
<li class="lvl-2"><code>g_</code> → 到本行最后一个不是blank字符的位置。</li>
<li class="lvl-2"><code>/pattern</code> → 搜索 <code>pattern</code> 的字符串（如果搜索出多个匹配，可按n键到下一个）</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>拷贝/粘贴</strong>（p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>P</code> → 粘贴</li>
<li class="lvl-2"><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>Undo/Redo</strong></p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>u</code> → undo</li>
<li class="lvl-2"><code>&lt;C-r&gt;</code> → redo</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>打开/保存/退出/改变文件</strong>(Buffer)</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li>
<li class="lvl-2"><code>:w</code> → 存盘</li>
<li class="lvl-2"><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></li>
<li class="lvl-2"><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li>
<li class="lvl-2"><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li>
<li class="lvl-2"><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（我喜欢使用:n到下一个文件）</li>
</ul>
</blockquote>
</li>
</ol>
<p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p>
<h3 id="第三级-–-更好，更强，更快">第三级 – 更好，更强，更快</h3>
<p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p>
<h4 id="更好">更好</h4>
<p>下面，让我们看一下vim是怎么重复自己的：</p>
<ol>
<li class="lvl-3">
<p><code>.</code> → (小数点) 可以重复上一次的命令</p>
</li>
<li class="lvl-3">
<p>N<command> → 重复某个命令N次</p>
</li>
</ol>
<p>下面是一个示例，找开一个文件你可以试试下面的命令：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>2dd</code> → 删除2行</p>
</li>
<li class="lvl-2">
<p><code>3p</code> → 粘贴文本3次</p>
</li>
<li class="lvl-2">
<p><code>100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</p>
</li>
<li class="lvl-2">
<p><code>.</code> → 重复上一个命令—— 100 “desu “.</p>
</li>
<li class="lvl-2">
<p><code>3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</p>
</li>
</ul>
</blockquote>
<h4 id="更强">更强</h4>
<p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong>。</p>
<ol>
<li class="lvl-3">
<p>N<code>G</code> → 到第 N 行 （注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</p>
</li>
<li class="lvl-3">
<p><code>gg</code> → 到第一行。（相当于1G，或 :1）</p>
</li>
<li class="lvl-3">
<p><code>G</code> → 到最后一行。</p>
</li>
<li class="lvl-3">
<p>按单词移动：</p>
<blockquote>
<ol>
<li class="lvl-3"><code>w</code> → 到下一个单词的开头。</li>
<li class="lvl-3"><code>e</code> → 到下一个单词的结尾。</li>
</ol>
<p>&gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（程序变量）</p>
<p>&gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（程序语句）</p>
<p><img src="https://s2.loli.net/2023/11/09/mBIdizGN6uRQYsr.jpg" alt=""></p>
</blockquote>
</li>
</ol>
<p>下面，让我来说说最强的光标移动：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>&#123;</code>, <code>[</code>. （你需要把光标先移到括号上）</p>
</li>
<li class="lvl-2">
<p><code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</p>
</li>
</ul>
</blockquote>
<p>相信我，上面这三个命令对程序员来说是相当强大的。</p>
<h4 id="更快">更快</h4>
<p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p>
<p><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code></p>
<p>例如 <code>0y$</code> 命令意味着：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>0</code> → 先到行头</p>
</li>
<li class="lvl-2">
<p><code>y</code> → 从这里开始拷贝</p>
</li>
<li class="lvl-2">
<p><code>$</code> → 拷贝到本行最后一个字符</p>
</li>
</ul>
<p>你可可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p>
<p>你也可以输入 <code>y2/foo</code> 来拷贝2个 “foo” 之间的字符串。</p>
<p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>d</code> (删除 )</p>
</li>
<li class="lvl-2">
<p><code>v</code> (可视化的选择)</p>
</li>
<li class="lvl-2">
<p><code>gU</code> (变大写)</p>
</li>
<li class="lvl-2">
<p><code>gu</code> (变小写)</p>
</li>
<li class="lvl-2">
<p>等等</p>
</li>
</ul>
<p>（可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）</p>
<h3 id="第四级-–-Vim-超能力">第四级 – Vim 超能力</h3>
<p>你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p>
<h4 id="在当前行上移动光标-0-f-F-t-T">在当前行上移动光标: <code>0</code> <code>^</code> <code>$</code> <code>f</code> <code>F</code> <code>t</code> <code>T</code> <code>,</code> <code>;</code></h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>0</code> → 到行头</p>
</li>
<li class="lvl-2">
<p><code>^</code> → 到本行的第一个非blank字符</p>
</li>
<li class="lvl-2">
<p><code>$</code> → 到行尾</p>
</li>
<li class="lvl-2">
<p><code>g_</code> → 到本行最后一个不是blank字符的位置。</p>
</li>
<li class="lvl-2">
<p><code>fa</code> → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</p>
</li>
<li class="lvl-2">
<p><code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</p>
</li>
<li class="lvl-2">
<p><code>3fa</code> → 在当前行查找第三个出现的a。</p>
</li>
<li class="lvl-2">
<p><code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。<br>
<img src="https://s2.loli.net/2023/11/09/W43m7EYbDtGw8s9.jpg" alt=""></p>
</li>
</ul>
</blockquote>
<p>还有一个很有用的命令是 <code>dt&quot;</code> → 删除所有的内容，直到遇到双引号—— <code>&quot;。</code></p>
<h4 id="区域选择-action-a-object-或-action-i-object">区域选择 <code>&lt;action&gt;a&lt;object&gt;</code> 或 <code>&lt;action&gt;i&lt;object&gt;</code></h4>
<p>在visual 模式下，这些命令很强大，其命令格式为</p>
<p><code>&lt;action&gt;a&lt;object&gt;</code> 和 <code>&lt;action&gt;i&lt;object&gt;</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>action可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)。</p>
</li>
<li class="lvl-2">
<p>object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>&quot;、</code> <code>'、</code> <code>)、</code> <code>&#125;、</code> <code>]。</code></p>
</li>
</ul>
<p>假设你有一个字符串 <code>(map (+) (&quot;foo&quot;))</code>.而光标键在第一个 <code>o </code>的位置。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>vi&quot;</code> → 会选择 <code>foo</code>.</p>
</li>
<li class="lvl-2">
<p><code>va&quot;</code> → 会选择 <code>&quot;foo&quot;</code>.</p>
</li>
<li class="lvl-2">
<p><code>vi)</code> → 会选择 <code>&quot;foo&quot;</code>.</p>
</li>
<li class="lvl-2">
<p><code>va)</code> → 会选择<code>(&quot;foo&quot;)</code>.</p>
</li>
<li class="lvl-2">
<p><code>v2i)</code> → 会选择 <code>map (+) (&quot;foo&quot;)</code></p>
</li>
<li class="lvl-2">
<p><code>v2a)</code> → 会选择 <code>(map (+) (&quot;foo&quot;))</code></p>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/9yNEFqn7KPxBZVD.png" alt=""></p>
<h4 id="块操作-C-v">块操作: <code>&lt;C-v&gt;</code></h4>
<p>块操作，典型的操作： <code>0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>^</code> → 到行头</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-v&gt;</code> → 开始块操作</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-d&gt;</code> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)</p>
</li>
<li class="lvl-2">
<p><code>I-- [ESC]</code> → I是插入，插入“<code>--</code>”，按ESC键来为每一行生效。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/09/96cr5YmoZ4BzFXg.gif" alt=""></p>
<p>在Windows下的vim，你需要使用 <code>&lt;C-q&gt;</code> 而不是 <code>&lt;C-v&gt;</code> ，<code>&lt;C-v&gt;</code> 是拷贝剪贴板。</p>
<h4 id="自动提示：-C-n-和-C-p">自动提示： <code>&lt;C-n&gt;</code> 和 <code>&lt;C-p&gt;</code></h4>
<p>在 Insert 模式下，你可以输入一个词的开头，然后按 <code>&lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了……</code></p>
<p>``<img src="https://s2.loli.net/2023/11/09/XuSiyhszGdOlreT.gif" alt=""></p>
<h4 id="宏录制：-qa-操作序列-q-a">宏录制： <code>qa</code> 操作序列 <code>q</code>, <code>@a</code>, <code>@@</code></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>qa</code> 把你的操作记录在寄存器 <code>a。</code></p>
</li>
<li class="lvl-2">
<p>于是 <code>@a</code> 会replay被录制的宏。</p>
</li>
<li class="lvl-2">
<p><code>@@</code> 是一个快捷键用来replay最新录制的宏。</p>
</li>
</ul>
<blockquote>
<p>*<strong>示例*</strong></p>
<p>在一个只有一行且这一行只有“1”的文本中，键入如下命令：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>qaYp&lt;C-a&gt;q</code>→</p>
<ul class="lvl-3">
<li class="lvl-4"><code>qa</code> 开始录制</li>
<li class="lvl-4"><code>Yp</code> 复制行.</li>
<li class="lvl-4"><code>&lt;C-a&gt;</code> 增加1.</li>
<li class="lvl-4"><code>q</code> 停止录制.</li>
</ul>
</li>
<li class="lvl-2">
<p><code>@a</code> → 在1下面写下 2</p>
</li>
<li class="lvl-2">
<p><code>@@</code> → 在2 正面写下3</p>
</li>
<li class="lvl-2">
<p>现在做 <code>100@@</code> 会创建新的100行，并把数据增加到 103.</p>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/XfDJhsqvOPctITK.gif" alt=""></p>
<h4 id="可视化选择：-v-V-C-v">可视化选择： <code>v</code>,<code>V</code>,<code>&lt;C-v&gt;</code></h4>
<p>前面，我们看到了 <code>&lt;C-v&gt;</code>的示例 （在Windows下应该是<C-q>），我们可以使用 <code>v</code> 和 <code>V</code>。一但被选好了，你可以做下面的事：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>J</code> → 把所有的行连接起来（变成一行）</p>
</li>
<li class="lvl-2">
<p><code>&lt;</code> 或 <code>&gt;</code> → 左右缩进</p>
</li>
<li class="lvl-2">
<p><code>=</code> → 自动给缩进 （这个功能相当强大，我太喜欢了）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/09/IL7gktZrFwiauRW.gif" alt=""></p>
<p>在所有被选择的行后加上点东西：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;C-v&gt;</code></p>
</li>
<li class="lvl-2">
<p>选中相关的行 (可使用 <code>j</code> 或 <code>&lt;C-d&gt;</code> 或是 <code>/pattern</code> 或是 <code>%</code> 等……)</p>
</li>
<li class="lvl-2">
<p><code>$</code> 到行最后</p>
</li>
<li class="lvl-2">
<p><code>A</code>, 输入字符串，按 <code>ESC。</code></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/09/vCgLYdQp6VAlmyq.gif" alt=""></p>
<h4 id="分屏-split-和-vsplit">分屏: <code>:split</code> 和 <code>vsplit</code>.</h4>
<p>下面是主要的命令，你可以使用VIM的帮助 <code>:help split</code></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>:split</code> → 创建分屏 (<code>:vsplit</code>创建垂直分屏)</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-w&gt;&lt;dir&gt;</code> : dir就是方向，可以是 <code>hjkl</code> 或是 ←↓↑→ 中的一个，其用来切换分屏。</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-w&gt;_</code> (或 <code>&lt;C-w&gt;|</code>) : 最大化尺寸 (<C-w>| 垂直分屏)</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-w&gt;+</code> (或 <code>&lt;C-w&gt;-</code>) : 增加尺寸</p>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/837saHlWQKLdbZr.gif" alt=""></p>
<h3 id="结束语">结束语</h3>
<p>这是我每天使用的命令的 90%。我建议您每天学习的新命令不超过一两个。两到三周后，您将开始感受到 vim 在您手中的力量。</p>
<p>学习 Vim 更多的是训练而不是简单的记忆。幸运的是，vim 附带了一些非常好的工具和优秀的文档。运行 vimtutor 直到您熟悉最基本的命令。另外，您应该仔细阅读此页面：<code>:help usr_02.txt</code>。</p>
<p>然后，您将了解<code>!</code>、折叠、寄存器、插件和许多其他功能。像学习钢琴一样学习 vim 一切都应该没问题。学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p>
<blockquote>
<p>如果您喜欢这篇文章，可以阅读后续文章：<a href="http://yannesposito.com/Scratch/en/blog/Vim-as-IDE/"><em>Vim 作为 IDE</em></a></p>
</blockquote>
<h3 id="Reference">Reference</h3>
<p>[1]	简明 VIM 练级攻略: <a href="https://coolshell.cn/articles/5426.html#%E6%9B%B4%E5%BF%AB">https://coolshell.cn/articles/5426.html#更快</a></p>
<p>[2]	Learn Vim Progressively: <a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>C++设计模式</title>
    <url>/archives/9725cb23.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="单例模式">单例模式</h2>
<p>单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p>
<p>单例模式有两种实现方法，分别是懒汉和饿汉模式。顾名思义，懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；饿汉模式，即迫不及待，在程序运行时立即初始化。</p>
<span id="more"></span>
<h3 id="经典的线程安全懒汉模式"><strong>经典的线程安全懒汉模式</strong></h3>
<p>单例模式的实现思路如前述所示，其中，经典的线程安全懒汉模式，使用双检测锁模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有静态指针变量指向唯一实例</span></span><br><span class="line">    <span class="type">static</span> single *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态锁，是由于静态函数只能访问静态成员</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="built_in">single</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有静态方法获取实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> single::lock;</span><br><span class="line">single* single::p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>为什么要用双检测，只检测一次不行吗？</mark></p>
<p>如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。</p>
<h3 id="局部静态变量之线程安全懒汉模式"><strong>局部静态变量之线程安全懒汉模式</strong></h3>
<p>前面的双检测锁模式，写起来不太优雅，《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> single obj;</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>这时候有人说了，这种方法不加锁会不会造成线程安全问题？</mark></p>
<p>其实，C<ins>0X以后，要求编译器保证内部静态变量的线程安全性，故C</ins>0x之后该实现是线程安全的，C<ins>0x之前仍需加锁，其中C</ins>0x是C++11标准成为正式标准之前的草案临时名字。</p>
<p>所以，如果使用C++11之前的标准，还是需要加锁，这里同样给出加锁的版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">single</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> single::lock;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">    <span class="type">static</span> single obj;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态变量在C++中具有特定的作用域和生命周期，这些特性与普通局部变量或全局变量有所不同。</p>
<ol>
<li class="lvl-3">
<p>作用域（Scope）：</p>
<ul class="lvl-3">
<li class="lvl-5">静态局部变量（局部静态变量）：静态局部变量的作用域限于定义它的函数内，它在函数内可见，但在函数外不可访问。</li>
<li class="lvl-5">静态全局变量：静态全局变量的作用域是整个文件（或编译单元），即它在定义它的文件内可见，但在其他文件中不可访问。</li>
</ul>
</li>
<li class="lvl-3">
<p>生命周期（Lifetime）：</p>
<ul class="lvl-3">
<li class="lvl-5">静态局部变量：静态局部变量的生命周期贯穿整个程序的执行过程，从首次初始化到程序结束。它会一直存在于内存中，而不是在函数退出时销毁，这使得它可以在多次函数调用之间保持其值。</li>
<li class="lvl-5">静态全局变量：静态全局变量的生命周期也贯穿整个程序的执行过程，从程序启动到结束。与普通全局变量不同，静态全局变量只在定义它的文件内可见。</li>
</ul>
</li>
</ol>
<p>静态变量适用于需要在多次函数调用之间保持状态的情况，因为它们的值在函数调用之间保持不变，且不会被销毁。它们也用于实现单例模式或共享状态的情况。</p>
<p>需要注意的是，静态变量的初始化只会发生一次，无论是静态局部变量还是静态全局变量，它们的值在首次初始化后将保持不变。</p>
</blockquote>
<h3 id="饿汉模式"><strong>饿汉模式</strong></h3>
<p>饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> single* p;</span><br><span class="line">    <span class="built_in">single</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p = <span class="keyword">new</span> <span class="built_in">single</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    single* p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">    single* p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>
<h2 id="工厂模式">工厂模式</h2>
<p>我们先看工厂模式的介绍</p>
<blockquote>
<p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<p>简单来说，使用了C++<strong>多态</strong>的特性，将存在<strong>继承</strong>关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</p>
<p>工厂模式的实现方式可分别<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong>，每个实现方式都存在优和劣。</p>
<p>最近炒鞋炒的非常的火，那么以鞋厂的形式，一一分析针对每个实现方式进行分析。</p>
<h3 id="简单工厂模式"><strong>简单工厂模式</strong></h3>
<p><strong>具体的情形</strong>：</p>
<p>鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋子。哪个鞋炒的火爆，老板就生产哪个，看形势生产。</p>
<p><strong>UML图：</strong></p>
<p><img src="https://s2.loli.net/2023/11/05/F4uySOnkEKUBcbd.jpg" alt=""></p>
<p><strong>简单工厂模式的结构组成</strong>：</p>
<ol>
<li class="lvl-3">
<p>工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。</p>
</li>
<li class="lvl-3">
<p>抽象产品类：是具体产品类的继承的父类或实现的接口。</p>
</li>
<li class="lvl-3">
<p>具体产品类：工厂类所创建的对象就是此具体产品实例。</p>
</li>
</ol>
<p><strong>简单工厂模式的特点：</strong></p>
<p>工厂类封装了创建具体产品对象的函数。</p>
<p><strong>简单工厂模式的缺陷：</strong></p>
<p>扩展性非常差，新增产品的时候，需要去修改工厂类。</p>
<p><strong>简单工厂模式的代码：</strong></p>
<p>Shoes为鞋子的抽象类（基类），接口函数为Show()，用于显示鞋子广告。</p>
<p>NiKeShoes、AdidasShoes、LiNingShoes为具体鞋子的类，分别是耐克、阿迪达斯和李宁鞋牌的鞋，它们都继承于Shoes抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鞋子抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是李宁球鞋，我的广告语：Everything is possible&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ShoesFactory为工厂类，类里实现根据鞋子类型创建对应鞋子产品对象的CreateShoes(SHOES_TYPE type)函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SHOES_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    NIKE,</span><br><span class="line">    LINING,</span><br><span class="line">    ADIDAS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据鞋子类型创建对应的鞋子对象</span></span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">(SHOES_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NIKE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LINING:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADIDAS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数，先是构造了工厂对象，后创建指定类型的具体鞋子产品对象，创建了具体鞋子产品的对象便可直接打印广告。因为采用的是<code>new</code>的方式创建了对象，用完了要通过<code>delete</code> 释放资源资源哦！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造工厂对象</span></span><br><span class="line">    ShoesFactory shoesFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pNikeShoes = shoesFactory.<span class="built_in">CreateShoes</span>(NIKE);</span><br><span class="line">    <span class="keyword">if</span> (pNikeShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">        pNikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">        pNikeShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pLiNingShoes = shoesFactory.<span class="built_in">CreateShoes</span>(LINING);</span><br><span class="line">    <span class="keyword">if</span> (pLiNingShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 李宁球鞋广告喊起</span></span><br><span class="line">        pLiNingShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pLiNingShoes;</span><br><span class="line">        pLiNingShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pAdidasShoes = shoesFactory.<span class="built_in">CreateShoes</span>(ADIDAS);</span><br><span class="line">    <span class="keyword">if</span> (pAdidasShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阿迪达斯球鞋广告喊起</span></span><br><span class="line">        pAdidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pAdidasShoes;</span><br><span class="line">        pAdidasShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@lincoding factory]# ./simpleFactory </span><br><span class="line">我是耐克球鞋，我的广告语：Just do it</span><br><span class="line">我是阿迪达斯球鞋，我的广告语:Impossible is nothing</span><br><span class="line">我是李宁球鞋，我的广告语：Everything is possible</span><br></pre></td></tr></table></figure>
<h3 id="工厂方法模式"><strong>工厂方法模式</strong></h3>
<p><strong>具体情形：</strong></p>
<p>现各类鞋子抄的非常火热，于是为了大量生产每种类型的鞋子，则要针对不同品牌的鞋子开设独立的生产线，那么每个生产线就只能生产同类型品牌的鞋。</p>
<p><strong>UML图：</strong></p>
<p><img src="https://s2.loli.net/2023/11/05/nr6y2ld3ZpEgkUV.jpg" alt=""></p>
<p><strong>工厂方法模式的结构组成：</strong></p>
<ol>
<li class="lvl-3">
<p>抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</p>
</li>
<li class="lvl-3">
<p>具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。</p>
</li>
<li class="lvl-3">
<p>抽象产品类：它是具体产品继承的父类（基类）。</p>
</li>
<li class="lvl-3">
<p>具体产品类：具体工厂所创建的对象，就是此类。</p>
</li>
</ol>
<p><strong>工厂方法模式的特点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。</p>
</li>
<li class="lvl-2">
<p>工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。</p>
</li>
</ul>
<p><strong>工厂方法模式的缺陷：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义。</p>
</li>
<li class="lvl-2">
<p>一条生产线只能一个产品。</p>
</li>
</ul>
<p><strong>工厂方法模式的代码：</strong></p>
<p>ShoesFactory抽象工厂类，提供了创建具体鞋子产品的纯虚函数。</p>
<p>NiKeProducer、AdidasProducer、LiNingProducer`具体工厂类，继承持续工厂类，实现对应具体鞋子产品对象的创建。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShoesFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数针对每种类型的鞋子，构造了每种类型的生产线，再由每个生产线生产出对应的鞋子。需注意的是具体工厂对象和具体产品对象，用完了需要通过delete释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    ShoesFactory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line">    <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================ 生产阿迪达斯流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设阿迪达斯生产者</span></span><br><span class="line">    ShoesFactory *adidasProducer = <span class="keyword">new</span> <span class="built_in">AdidasProducer</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯生产线产出球鞋</span></span><br><span class="line">    Shoes *adidasShoes = adidasProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯球鞋广喊起</span></span><br><span class="line">    adidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> adidasShoes;</span><br><span class="line">    <span class="keyword">delete</span> adidasProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@lincoding factory]# ./methodFactory </span><br><span class="line">我是耐克球鞋，我的广告语：Just do it</span><br><span class="line">我是阿迪达斯球鞋，我的广告语:Impossible is nothing</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><strong>抽象工厂模式</strong></h3>
<p><strong>具体情形：</strong></p>
<p>鞋厂为了扩大了业务，不仅只生产鞋子，把运动品牌的衣服也一起生产了。</p>
<p><strong>UML图：</strong></p>
<p><img src="https://s2.loli.net/2023/11/05/Do6KdgTftqWbklM.jpg" alt=""></p>
<p><strong>抽象工厂模式的结构组成（和工厂方法模式一样）：</strong></p>
<ol>
<li class="lvl-3">
<p>抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</p>
</li>
<li class="lvl-3">
<p>具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。</p>
</li>
<li class="lvl-3">
<p>抽象产品类：它是具体产品继承的父类（基类）。</p>
</li>
<li class="lvl-3">
<p>具体产品类：具体工厂所创建的对象，就是此类。</p>
</li>
</ol>
<p><strong>抽象工厂模式的特点：</strong></p>
<p>提供一个接口，可以创建多个产品族中的产品对象。如创建耐克工厂，则可以创建耐克鞋子产品、衣服产品、裤子产品等。</p>
<p><strong>抽象工厂模式的缺陷：</strong></p>
<p>同工厂方法模式一样，新增产品时，都需要增加一个对应的产品的具体工厂类。</p>
<p><strong>抽象工厂模式的代码：</strong></p>
<p>Clothe和Shoes，分别为衣服和鞋子的抽象产品类。</p>
<p>NiKeClothe和NiKeShoes，分别是耐克衣服和耐克衣服的具体产品类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeClothe</span> : <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克衣服，时尚我最在行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，让你酷起来！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Factory为抽象工厂，提供了创建鞋子CreateShoes()和衣服产品CreateClothe()对象的接口。</p>
<p>NiKeProducer为具体工厂，实现了创建耐克鞋子和耐克衣服的方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Clothe *<span class="title">CreateClothe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Clothe *<span class="title">CreateClothe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeClothe</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数，构造耐克工厂对象，通过耐克工厂对象再创建耐克产品族的衣服和鞋子对象。同样，对象不再使用时，需要手动释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    Factory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">	<span class="comment">// 耐克生产线产出衣服</span></span><br><span class="line">    Clothe *nikeClothe = niKeProducer-&gt;<span class="built_in">CreateClothe</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">	<span class="comment">// 耐克衣服广告喊起</span></span><br><span class="line">    nikeClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">	<span class="keyword">delete</span> nikeClothe;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@lincoding factory]# ./abstractFactory </span><br><span class="line">我是耐克球鞋，让你酷起来！</span><br><span class="line">我是耐克衣服，时尚我最在行！</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>以上三种工厂模式，在新增产品时，都存在一定的缺陷。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单工厂模式，，需要去修改工厂类，这违背了开闭法则。</p>
</li>
<li class="lvl-2">
<p>工厂方式模式和抽象工厂模式，都需要增加一个对应的产品的具体工厂类，这就会增大了代码的编写量。</p>
</li>
</ul>
<blockquote>
<p>那么有什么好的方法，在新增产品时，即不用修改工厂类，也不用新增具体的工厂类？详细内容可以跳转至 <a href="https://zhuanlan.zhihu.com/p/83537599">C++ 深入浅出工厂模式（进阶篇）</a></p>
</blockquote>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 深入浅出工厂模式（初识篇）: <a href="https://zhuanlan.zhihu.com/p/83535678">https://zhuanlan.zhihu.com/p/83535678</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++参数传递</title>
    <url>/archives/9460e0c1.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<p>在C++中，参数传递的方式是“实虚结合”。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>按值传递(pass by value)</p>
</li>
<li class="lvl-2">
<p>地址传递(pass by pointer)</p>
</li>
<li class="lvl-2">
<p>引用传递(pass by reference)</p>
</li>
</ul>
<span id="more"></span>
<h2 id="1-按值传递"><strong>1.按值传递</strong></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在按值传递中，函数参数是通过将其值复制给形式参数（函数内部的参数）来传递的。</p>
</li>
<li class="lvl-2">
<p>这意味着在函数内部对参数的任何修改都不会影响函数外部的原始值。</p>
</li>
<li class="lvl-2">
<p>按值传递适用于不需要修改原始值的情况，或者需要在函数内部创建局部副本以避免影响原始值的情况。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modifyValue</span>(value); <span class="comment">// value的值不会改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-引用传递"><strong>2.引用传递</strong></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在引用传递中，函数参数是通过传递它们的引用（或指针）来传递的，这意味着函数内部可以直接访问和修改原始值。</p>
</li>
<li class="lvl-2">
<p>这允许函数对原始数据进行修改，而不需要创建副本。</p>
</li>
<li class="lvl-2">
<p>按引用传递通常用于需要修改原始值或避免创建副本的情况。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modifyValue</span>(value); <span class="comment">// value的值被修改为42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-传址调用（传指针）">3.传址调用（传指针）</h2>
<h3 id="一级指针做参数"><strong>一级指针做参数</strong></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">int</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">func_2</span>(&amp;a);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数接受一个值，这个值是地址，谁的地址？外部变量 <code>a</code> 的地址，函数创建一个临时变量（指针类型）来存储外部变量 <code>a</code> 的地址</p>
</li>
<li class="lvl-2">
<p>在函数内部使用临时变量 <code>a</code> 可得到外部变量 <code>a</code> 的地址，使用 <code>*a</code> 可以获取外部变量 <code>a</code> 地址中所存储的值</p>
</li>
<li class="lvl-2">
<p>这个临时变量 <code>a</code> 复制的是外部变量的地址，按值传递，无论怎么复制，地址是唯一的，通过地址来修改外部变量的值是可以实现的</p>
</li>
</ul>
<p><mark><strong>改变指针指向？</strong></mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">int</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="literal">NULL</span>;<span class="comment">//让指针指向空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> *b = &amp;a; <span class="comment">//这个b存储的是变量a的地址</span></span><br><span class="line"> <span class="built_in">func_2</span>(b);   <span class="comment">//要修改b的指向，看似可以修改，其实不可以,注意我说的是指向。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数创建临时变量a存储b的值，也就是变量a的地址；</p>
</li>
<li class="lvl-2">
<p>给变量a赋值为空，结果只是临时变量a被修改了值，而原外部变量b的值还是指向外部变量a的地址；</p>
</li>
<li class="lvl-2">
<p>所以该函数实现不了预期的功能。</p>
</li>
</ul>
<h3 id="二级指针做参数"><strong>二级指针做参数</strong></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_3</span><span class="params">(<span class="type">int</span> ** a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br><span class="line"><span class="type">int</span> ** c = &amp;b;</span><br><span class="line"><span class="built_in">func_3</span>(c);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数创建一个临时变量 <code>a</code> 来存储 <code>c</code> 的值，即 <code>b</code> 的地址。</p>
</li>
<li class="lvl-2">
<p>函数内部使用 <code>*a</code> 获取外部变量 <code>b</code> 存储的地址，从而可以修改 <code>b</code> 指针的指向。</p>
</li>
<li class="lvl-2">
<p>通过 <code>**a</code> 可以访问外部变量 <code>a</code> 的值，并对其进行修改。</p>
</li>
</ul>
<h2 id="总结"><strong>总结</strong></h2>
<blockquote>
<ol>
<li class="lvl-3">
<p>如果想要修改指针指向变量的值，则无需传入高一级的指针，使用同级指针即可；</p>
</li>
<li class="lvl-3">
<p>如果想要修改指针本身的值，也就是地址，则应使用比原指针高一级的指针来实现。</p>
</li>
</ol>
</blockquote>
<h2 id="Reference">Reference</h2>
<p>[1]	C/C++什么时候使用二级指针，你知道吗？: <a href="https://cloud.tencent.com/developer/article/1732047">https://cloud.tencent.com/developer/article/1732047</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>参数传递</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序与快速排序</title>
    <url>/archives/d48e34d2.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h1>选择排序</h1>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="算法步骤">算法步骤</h2>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<p>重复第二步，直到所有元素均排序完毕</p>
<span id="more"></span>
<h2 id="C-实现">C++实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr1 = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">selection_sort</span>(arr1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array (int): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; arr1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; arr2 = &#123;<span class="number">3.14</span>, <span class="number">2.71</span>, <span class="number">1.618</span>, <span class="number">0.707</span>, <span class="number">2.718</span>&#125;;</span><br><span class="line">    <span class="built_in">selection_sort</span>(arr2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array (float): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间复杂度 O(n^2)，需要遍历每个元素</p>
</li>
<li class="lvl-2">
<p>空间复杂度O(1)，不占用额外空间</p>
</li>
</ul>
<h1>快速排序</h1>
<p>快速排序是一种使用分治策略的排序算法。它选择一个元素作为“枢纽”或“基准”元素，然后将数组分为两个子数组——一个包含所有比基准元素小的元素，另一个包含所有比基准元素大的元素。然后对这两个子数组进行递归地快速排序。</p>
<h2 id="算法步骤-2">算法步骤</h2>
<ol>
<li class="lvl-3">
<p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>
</li>
<li class="lvl-3">
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li class="lvl-3">
<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
</li>
</ol>
<h2 id="C-实现：">C++实现：</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">Partition</span>(A, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++11优化随机快排</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机快排</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> leftBorder, <span class="type">int</span> rightBorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftBorder &gt;= rightBorder) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机中轴</span></span><br><span class="line">        <span class="type">int</span> pivot = leftBorder + <span class="built_in">rand</span>() % (rightBorder - leftBorder + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[pivot], nums[leftBorder]);</span><br><span class="line">        <span class="type">int</span> left = leftBorder, right = rightBorder;</span><br><span class="line">        <span class="type">int</span> pivotNum = nums[leftBorder];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通快排</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivotNum) --right;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivotNum) ++left;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivotNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码是关键优化，缩小一下中轴范围，针对2，2，2，2，2...这种重复样本有效</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;<span class="number">0</span> &amp;&amp; nums[left] == nums[left<span class="number">-1</span>]) --left;</span><br><span class="line">        <span class="keyword">while</span>(right&lt; nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) ++right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归缩小范围的左右区域</span></span><br><span class="line">        <span class="built_in">qSort</span>(nums, leftBorder,left<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">qSort</span>(nums, right+<span class="number">1</span>, rightBorder);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">qSort</span>(nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间空间复杂度分析">时间空间复杂度分析</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间复杂度</p>
<p>对于最好和平均情况，快速排序的时间复杂度是 O(nlogn)。这是因为在这些情况下，每次分区操作，我们可以将数组分为两个近乎相等的部分。这就意味着每次递归调用处理一半的大小。</p>
<p>但是在最坏情况下（即当给定的数组已经完全排序或者完全逆序排列时），快排的时间复杂度是 O(n^2)。这是因为每次分区操作只能减少数组大小1。</p>
</li>
<li class="lvl-2">
<p>空间复杂度</p>
<ul class="lvl-2">
<li class="lvl-4">快速排序是原地排序，不需要额外的存储空间，所以空间复杂度为 O(1)。</li>
<li class="lvl-4">但是，快速排序是递归的，因此需要考虑递归栈的空间。在最坏的情况下，递归栈的深度为 O(n)。在平均情况下，递归栈的深度为 O(logn)。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>链表理论基础</title>
    <url>/archives/d993e4b5.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h1>链表理论基础</h1>
<p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。</p>
<p>如图所示：<br>
<img src="https://s2.loli.net/2023/07/20/v4NiFGLQ2RKoVct.png" alt=""></p>
<span id="more"></span>
<h2 id="链表的类型">链表的类型</h2>
<p>接下来说一下链表的几种类型:</p>
<h3 id="单链表">单链表</h3>
<p>刚刚说的就是单链表。</p>
<h3 id="双链表">双链表</h3>
<p>单链表中的指针域只能指向节点的下一个节点。</p>
<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<p>如图所示：<br>
<img src="https://s2.loli.net/2023/07/20/i9AY6NcoVEPCuTI.png" alt=""></p>
<h3 id="循环链表">循环链表</h3>
<p>循环链表，顾名思义，就是链表首尾相连。</p>
<p>循环链表可以用来解决约瑟夫环问题。</p>
<p><img src="https://s2.loli.net/2023/07/20/k5WugEJ743vYxfB.png" alt=""></p>
<h2 id="链表的存储方式">链表的存储方式</h2>
<p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p>
<p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<p>如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/lH21brhLCXZJysm.png" alt=""></p>
<p>这个链表起始节点为2， 终止节点为7，  各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p>
<h2 id="链表的定义">链表的定义</h2>
<p>接下来说一说链表的定义。</p>
<p>链表节点的定义，很多同学在面试的时候都写不好。</p>
<p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p>
<p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p>
<p>这里我给出C/C++的定义链表节点方式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p>
<p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p>
<p>通过自己定义构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>
<h2 id="链表的操作">链表的操作</h2>
<h3 id="删除节点">删除节点</h3>
<p>删除D节点，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/rji16Yx5Pu8SnwM.png" alt=""></p>
<p>只要将C节点的next指针 指向E节点就可以了。</p>
<p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p>
<p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p>
<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>
<h3 id="添加节点">添加节点</h3>
<p>如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/IDXKom186eRbqkz.png" alt=""></p>
<p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p>
<p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p>
<h2 id="性能分析">性能分析</h2>
<p>再把链表的特性和数组的特性进行一个对比，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/me92ILFzh1TJUnV.png" alt=""></p>
<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h2 id="其他语言版本">其他语言版本</h2>
<h3 id="Python：">Python：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	代码随想录: <a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数组理论基础</title>
    <url>/archives/6193d61a.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="数组理论基础">数组理论基础</h2>
<p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力</p>
<p>也就是说，想法很简单，但实现起来 可能就不是那么回事了。</p>
<span id="more"></span>
<p>首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题</p>
<p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p>
<p>举一个字符数组的例子，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/19/QksAyZeBXjWdVK9.png" alt=""></p>
<p>需要两点注意的是</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数组下标都是从0开始的。</strong></p>
</li>
<li class="lvl-2">
<p><strong>数组内存空间的地址是连续的</strong></p>
</li>
</ul>
<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/19/5fqvJkEZWtDjSRL.png" alt=""></p>
<p>而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p>那么二维数组直接上图，大家应该就知道怎么回事了</p>
<p><img src="https://s2.loli.net/2023/07/19/inkBdNrhVDG3a5q.png" alt=""></p>
<p><strong>那么二维数组在内存的空间地址是连续的么？</strong></p>
<p>不同编程语言的内存管理是不一样的，以C<ins>为例，在C</ins>中二维数组是连续分布的。</p>
<p>我们来做一个实验，C++测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_arr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试地址为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffee4065820 0x7ffee4065824 0x7ffee4065828</span><br><span class="line">0x7ffee406582c 0x7ffee4065830 0x7ffee4065834</span><br></pre></td></tr></table></figure>
<p>注意地址为16进制，可以看出二维数组地址是连续一条线的。</p>
<p>一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节。</p>
<p>0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12。</p>
<p>如图：</p>
<p><img src="https://s2.loli.net/2023/07/19/1zu7ArUa3B6ZoLf.png" alt=""></p>
<p><strong>所以可以看出在C++中二维数组在地址空间上是连续的</strong>。</p>
<p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p>
<p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_arr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[I@7852e922</span><br><span class="line">[I@4e25154f</span><br><span class="line">[I@70dea4e</span><br><span class="line">[I@5c647e05</span><br></pre></td></tr></table></figure>
<p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p>
<p>所以Java的二维数组可能是如下排列的方式：</p>
<p><img src="https://s2.loli.net/2023/07/19/wxgSvju5EWHZlfL.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	代码随想录: <a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法的时间与空间复杂度</title>
    <url>/archives/bc5d8ac6.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<h3 id="究竟什么是时间复杂度">究竟什么是时间复杂度</h3>
<p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。</p>
<p>我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。</p>
<p>那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。</p>
<span id="more"></span>
<p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p>
<h3 id="什么是大O">什么是大O</h3>
<p>这里的大O是指什么呢，说到时间复杂度，<strong>大家都知道O(n)，O(n^2)，却说不清什么是大O</strong>。</p>
<p>算法导论给出的解释：<strong>大O用来表示上界的</strong>，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。</p>
<p>同样算法导论给出了例子：拿插入排序来说，插入排序的时间复杂度我们都说是O(n^2) 。</p>
<p>输入数据的形式对程序运算时间是有很大影响的，在数据本来有序的情况下时间复杂度是O(n)，但如果数据是逆序的话，插入排序的时间复杂度就是O(n<sup>2)，也就对于所有输入情况来说，最坏是O(n</sup>2) 的时间复杂度，所以称插入排序的时间复杂度为O(n^2)。</p>
<p>同样的同理再看一下快速排序，都知道快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，<strong>所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)</strong>。</p>
<p><strong>但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界</strong>。如图所示：<br>
<img src="https://s2.loli.net/2023/07/19/HsbCE5wfolQtXMG.png" alt=""></p>
<p>我们主要关心的还是一般情况下的数据形式。</p>
<p><strong>面试中说道算法的时间复杂度是多少指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p>
<h3 id="不同数据规模的差异">不同数据规模的差异</h3>
<p>如下图中可以看出不同算法的时间复杂度在不同数据输入规模下的差异。</p>
<p><img src="https://s2.loli.net/2023/07/19/e9n3dqxmjJMt2U8.png" alt=""></p>
<p>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）。</p>
<p>就像上图中 O(5n^2) 和 O(100n) 在n为20之前 很明显 O(5n^2)是更优的，所花费的时间也是最少的。</p>
<p>那为什么在计算时间复杂度的时候要忽略常数项系数呢，也就说O(100n) 就是O(n)的时间复杂度，O(5n^2) 就是O(n^2)的时间复杂度，而且要默认O(n) 优于O(n^2) 呢 ？</p>
<p>这里就又涉及到大O的定义，<strong>因为大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong>。</p>
<p>例如上图中20就是那个点，n只要大于20 常数项系数已经不起决定性作用了。</p>
<p><strong>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt;  O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
<p>但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了。</p>
<h3 id="复杂表达式的化简">复杂表达式的化简</h3>
<p>有时候我们去计算时间复杂度的时候发现不是一个简单的O(n) 或者O(n^2)， 而是一个复杂的表达式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(2*n^2 + 10*n + 1000)</span><br></pre></td></tr></table></figure>
<p>那这里如何描述这个算法的时间复杂度呢，一种方法就是简化法。</p>
<p>去掉运行时间中的加法常数项 （因为常数项并不会因为n的增大而增加计算机的操作次数）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(2*n^2 + 10*n)</span><br></pre></td></tr></table></figure>
<p>去掉常数系数（上文中已经详细讲过为什么可以去掉常数项的原因）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n^2 + n)</span><br></pre></td></tr></table></figure>
<p>只保留保留最高项，去掉数量级小一级的n （因为n^2 的数据规模远大于n），最终简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n^2)</span><br></pre></td></tr></table></figure>
<p>如果这一步理解有困难，那也可以做提取n的操作，变成O(n(n+1)) ，省略加法常数项后也就别变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n^2)</span><br></pre></td></tr></table></figure>
<p>所以最后我们说：这个算法的算法时间复杂度是O(n^2) 。</p>
<p>也可以用另一种简化的思路，其实当n大于40的时候， 这个复杂度会恒小于O(3 × n^2)，<br>
O(2 × n^2 + 10 × n + 1000) &lt; O(3 × n<sup>2)，所以说最后省略掉常数项系数最终时间复杂度也是O(n</sup>2)。</p>
<h3 id="O-logn-中的log是以什么为底？">O(logn)中的log是以什么为底？</h3>
<p>平时说这个算法的时间复杂度是logn的，那么一定是log 以2为底n的对数么？</p>
<p>其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，<strong>但我们统一说 logn，也就是忽略底数的描述</strong>。</p>
<p>为什么可以这么做呢？如下图所示：</p>
<p><img src="https://s2.loli.net/2023/07/19/9cEr5iqM2uHGS3N.png" alt=""></p>
<p>假如有两个算法的时间复杂度，分别是log以2为底n的对数和log以10为底n的对数，那么这里如果还记得高中数学的话，应该不难理解<code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code>。</p>
<p>而以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。</p>
<p>抽象一下就是在时间复杂度的计算过程中，log以i为底n的对数等于log 以j为底n的对数，所以忽略了i，直接说是logn。</p>
<p>这样就应该不难理解为什么忽略底数了。</p>
<h3 id="举一个例子">举一个例子</h3>
<p>通过这道面试题目，来分析一下时间复杂度。题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。</p>
<p>如果是暴力枚举的话，时间复杂度是多少呢，是O(n^2)么？</p>
<p>这里一些同学会忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单，除了n^2 次的遍历次数外，字符串比较依然要消耗m次操作（m也就是字母串的长度），所以时间复杂度是O(m × n × n)。</p>
<p>接下来再想一下其他解题思路。</p>
<p>先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。</p>
<p>那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。</p>
<p>之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。</p>
<p>我们对O(m × n × log n + n × m) 进行简化操作，把m × n提取出来变成 O(m × n × (logn + 1))，再省略常数项最后的时间复杂度是 O(m × n × log n)。</p>
<p>最后很明显O(m × n × logn) 要优于O(m × n × n)！</p>
<p>所以先把字符串集合排序再遍历一遍找到两个相同字符串的方法要比直接暴力枚举的方式更快。</p>
<p>这就是我们通过分析两种算法的时间复杂度得来的。</p>
<h2 id="空间复杂度分析">空间复杂度分析</h2>
<p>那么一直还没有讲空间复杂度，所以打算陆续来补上，内容不难，大家可以读一遍文章就有整体的了解了。</p>
<p>什么是空间复杂度呢？</p>
<p>是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)。</p>
<p>空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。</p>
<p>关注空间复杂度有两个常见的相关问题</p>
<ol>
<li class="lvl-3">
<p>空间复杂度是考虑程序（可执行文件）的大小么？</p>
</li>
</ol>
<p>很多同学都会混淆程序运行时内存大小和程序本身的大小。这里强调一下<strong>空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。</strong></p>
<ol start="2">
<li class="lvl-3">
<p>空间复杂度是准确算出程序运行时所占用的内存么？</p>
</li>
</ol>
<p>不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。</p>
<p>所以空间复杂度是预先大体评估程序内存使用的大小。</p>
<p>说到空间复杂度，我想同学们在OJ（online judge）上应该遇到过这种错误，就是超出内存限制，一般OJ对程序运行时的所消耗的内存都有一个限制。</p>
<p>为了避免内存超出限制，这也需要我们对算法占用多大的内存有一个大体的预估。</p>
<p>同样在工程实践中，计算机的内存空间也不是无限的，需要工程师对软件运行时所使用的内存有一个大体评估，这都需要用到算法空间复杂度的分析。</p>
<p>来看一下例子，什么时候的空间复杂度是$O(1)$呢，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。</p>
<p>什么时候的空间复杂度是O(n)？</p>
<p>当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。</p>
<p>其他的 O(n^2)， O(n^3) 我想大家应该都可以以此例举出来了，<strong>那么思考一下 什么时候空间复杂度是 O(logn)呢？</strong></p>
<p>空间复杂度是logn的情况确实有些特殊，其实是在<strong>递归的时候，会出现空间复杂度为logn的情况</strong>。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	代码随想录: <a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>C++初始化列表与赋值</title>
    <url>/archives/29ca4c7e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<ul class="lvl-0">
<li class="lvl-2">const成员的初始化只能在构造函数初始化列表中进行</li>
<li class="lvl-2">引用成员的初始化也只能在构造函数初始化列表中进行</li>
<li class="lvl-2">对象成员（对象成员所对应的类没有默认构造函数）的初始化，也只能在构造函数初始化列表中进行</li>
</ul>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a), _p(<span class="literal">nullptr</span>) &#123;     <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> *_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="类之间嵌套">类之间嵌套</h2>
<p><strong>第一种： 使用初始化列表。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal(animal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal __animal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal animal;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(animal)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span>() <span class="function">is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Animal</span> <span class="params">(<span class="type">const</span> Animal &amp;)</span> is called</span></span><br><span class="line"><span class="function"><span class="title">Dog</span><span class="params">(<span class="type">const</span> Animal &amp;animal)</span> is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">~<span class="title">Dog</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br></pre></td></tr></table></figure>
<p>依次分析从上到下：</p>
<p>main函数中<code>Animal animal;</code>调用默认构造。</p>
<p><code>Dog d(animal);</code>等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Animal __animal = animal;</span><br></pre></td></tr></table></figure>
<p>实际上就是调用了拷贝构造，因此输出了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span> (<span class="type">const</span> Animal &amp;) is called</span><br></pre></td></tr></table></figure>
<p>再然后打印Dog的构造函数里面的输出。</p>
<p>最后调用析构，程序结束。</p>
<p><strong>第二种：构造函数赋值来初始化对象。</strong></p>
<p>构造函数修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) &#123;</span><br><span class="line">    __animal = animal;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span>() <span class="function">is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">Animal &amp; <span class="keyword">operator</span></span>=(<span class="type">const</span> Animal &amp;) <span class="function">is called</span></span><br><span class="line"><span class="function"><span class="title">Dog</span><span class="params">(<span class="type">const</span> Animal &amp;animal)</span> is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">~<span class="title">Dog</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br></pre></td></tr></table></figure>
<p>于是得出：</p>
<p>当调用<code>Dog d(animal);</code>时，等价于：</p>
<p>先定义对象，再进行赋值，因此先调用了默认构造，再调用=操作符重载函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设之前已经有了animal对象</span></span><br><span class="line">Animal __animal;</span><br><span class="line">__animal = animal;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小结</p>
</blockquote>
<p>通过上述我们得出如下结论：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>类中包含其他自定义的class或者struct，采用初始化列表，实际上就是创建对象同时并初始化</strong></p>
</li>
<li class="lvl-2">
<p><strong>而采用类中赋值方式，等价于先定义对象，再进行赋值，一般会先调用默认构造，在调用=操作符重载函数。</strong></p>
</li>
</ul>
<h2 id="无默认构造函数的继承关系中">无默认构造函数的继承关系中</h2>
<p>现考虑把上述的关系改为继承，并修改Animal与Dog的构造函数，如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp; animal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp; amimal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">int</span> age) : <span class="built_in">Animal</span>(age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述是通过初始化列表给基类带参构造传递参数，如果不通过初始化列表传递，会发生什么影响？</p>
<p>去掉初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">int</span> age)  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">error: no matching function <span class="keyword">for</span> call to ‘Animal::<span class="built_in">Animal</span>()’</span><br></pre></td></tr></table></figure>
<p>由于在Animal中没有默认构造函数，所以报错，遇到这种问题属于灾难性的，我们应该尽量避免，可以通过初始化列表给基类的构造初始化。</p>
<h2 id="类中const数据成员、引用数据成员">类中const数据成员、引用数据成员</h2>
<p>特别是引用数据成员，必须用初始化列表初始化，而不能通过赋值初始化！</p>
<p>例如：在上述的Animal中添加私有成员，并修改构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age,std::string name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;age_;</span><br><span class="line">    <span class="type">const</span> std::string name_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>报下面错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: uninitialized reference member in ‘int&amp;’</span><br></pre></td></tr></table></figure>
<p>应该改为下面：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span>(<span class="type">int</span> age, std::string name) : <span class="built_in">age_</span>(age), <span class="built_in">name_</span>(name) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>初始化列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda函数</title>
    <url>/archives/3065ab21.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>Lambda表达式是一种用于创建匿名函数的语法构造。它可以在需要函数对象的地方使用，而无需显式定义一个命名函数。</p>
</blockquote>
<p>Lambda表达式有如下优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</p>
</li>
<li class="lvl-2">
<p>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</p>
</li>
<li class="lvl-2">
<p>在需要的时间和地点实现功能闭包，使程序更灵活。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="python中的Lambda">python中的Lambda</h2>
<p>在Python中，Lambda表达式用于创建匿名函数。Lambda表达式的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>lambda</code>关键字表示Lambda表达式的开始。</p>
</li>
<li class="lvl-2">
<p><code>arguments</code>表示参数列表，可以是零个或多个参数，参数之间使用逗号分隔。</p>
</li>
<li class="lvl-2">
<p><code>expression</code>表示Lambda函数的返回值，即函数体的表达式。</p>
</li>
</ul>
<p><strong>1. 将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不带参数</span></span><br><span class="line">greeting = <span class="keyword">lambda</span>: <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(greeting())  <span class="comment"># 输出: Hello, world</span></span><br><span class="line"><span class="comment"># 带参数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 输出: 7</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了把标准库time中的函数sleep的功能屏蔽(Mock)</span></span><br><span class="line">time.sleep=<span class="keyword">lambda</span> x:<span class="literal">None</span></span><br><span class="line">time.sleep(<span class="number">3</span>) <span class="comment">#程序不会休眠3秒钟，而是什么都不做</span></span><br></pre></td></tr></table></figure>
<p>在后续代码中调用time库的sleep函数将不会执行原有的功能</p>
<p><strong>3. 将lambda函数作为参数传递给其他函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squared))  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>部分Python内置函数接受函数作为参数</strong>,典型的<strong>此类内置函数有</strong>这些:</p>
<p><strong>filter函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3]。</span></span><br></pre></td></tr></table></figure>
<p><strong>sorted函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(<span class="number">5</span>-x))</span><br><span class="line"><span class="comment"># 将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序</span></span><br><span class="line"><span class="comment"># 其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]</span></span><br></pre></td></tr></table></figure>
<p><strong>map函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x+<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">#将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p><strong>reduce函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> a, b: <span class="string">&#x27;&#123;&#125;, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="comment"># 将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是&#x27;1, 2, 3, 4, 5, 6, 7, 8, 9&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="排序：">排序：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">80</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">90</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">70</span>&#125;</span><br><span class="line">]</span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> student: student[<span class="string">&quot;score&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [&#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;score&#x27;: 70&#125;, &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 80&#125;, &#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;score&#x27;: 90&#125;]</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，Lambda表达式用于创建匿名函数，并在不同的上下文中使用。Lambda表达式可以在需要函数对象的地方直接使用，无需显式定义一个命名函数。</p>
<h2 id="C-中的Lambda">C++中的Lambda</h2>
<h3 id="Lambda-表达式的各个部分">Lambda 表达式的各个部分</h3>
<p>下面是作为第三个参数 <code>std::sort()</code> 传递给函数的简单 lambda：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abssort</span><span class="params">(<span class="type">float</span>* x, <span class="type">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n,</span><br><span class="line">        <span class="comment">// Lambda expression begins</span></span><br><span class="line">        [](<span class="type">float</span> a, <span class="type">float</span> b) &#123;</span><br><span class="line">            <span class="built_in">return</span> (std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b));</span><br><span class="line">        &#125; <span class="comment">// end of lambda expression</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图显示了 lambda 语法的各个部分：</p>
<p><img src="https://s2.loli.net/2023/07/12/9vK8Vp4euns2TgY.png" alt=""></p>
<ol>
<li class="lvl-3">
<p>capture 子句（在 C++ 规范中也称为 Lambda 引导。）</p>
</li>
<li class="lvl-3">
<p>参数列表（可选）。 （也称为 Lambda 声明符）</p>
</li>
<li class="lvl-3">
<p>mutable 规范（可选）。</p>
</li>
<li class="lvl-3">
<p>exception-specification（可选）。</p>
</li>
<li class="lvl-3">
<p>trailing-return-type（可选）。</p>
</li>
<li class="lvl-3">
<p>Lambda 体。</p>
</li>
</ol>
<h3 id="捕获列表">捕获列表 [ ]</h3>
<p>捕获列表是零或多个捕获符的逗号分隔符列表，可选地以默认捕获符开始（仅有的默认捕获符是 &amp; 和 = ）。默认情况下，从lambda生成的类都包含一个对应该lambda所捕获变量的数据成员。类似任何普通类地数据成员，lambda的数据成员也在lambda对象创建时被初始化。类似参数传递，变量的捕获方式也可以是值或引用。</p>
<p><strong>值捕获：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;<span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">//将i拷贝到明位f的可调用对象</span></span><br><span class="line">	<span class="keyword">auto</span> f = [i] &#123; <span class="keyword">return</span> i; &#125;;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">f</span>(); <span class="comment">//j=100,因为i是创建时拷贝的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用捕获：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;<span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">//对象f包含i的引用</span></span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;i] &#123; <span class="keyword">return</span> i; &#125;;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">f</span>(); <span class="comment">//j=0,传递的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了自己列出捕获列表的变量，还可以让编译器根据lambda中代码来推断我们要使用哪些变量（<strong>隐式捕获</strong>），用过使用&amp;或=指示编译器推断捕获列表。&amp;则采用引用捕获的方式，=则采用值捕获的方式。混合使用隐式捕获和显示捕获，则两者须使用不同的方式，一个为引用捕获，一个为值捕获。</p>
<p><strong>lambda捕获列表：</strong></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>[ ]。空捕获列表，lambda不能使用所在函数中的变量。</p>
</li>
<li class="lvl-2">
<p>[=]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</p>
</li>
<li class="lvl-2">
<p>[&amp;]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</p>
</li>
<li class="lvl-2">
<p>[this]。函数体内可以使用Lambda所在类中的成员变量。</p>
</li>
<li class="lvl-2">
<p>[a]。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</p>
</li>
<li class="lvl-2">
<p>[&amp;a]。将a按引用进行传递。</p>
</li>
<li class="lvl-2">
<p>[=，&amp;a, &amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</p>
</li>
<li class="lvl-2">
<p>[&amp;, a, b]。除a和b按值进行传递外，其他参数都按引用进行传递。</p>
</li>
</ul>
</blockquote>
<p><strong>悬垂引用：</strong></p>
<p>若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++ 的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。</p>
<h3 id="形参列表">形参列表 ( )</h3>
<p>lambda形参列表和一般的函数形参列表类似，但不允许默认实参(C<ins>14 前)。当以 auto 为形参类型时，该 lambda 为泛型 lambda(C</ins>14 起)。与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span></span><br><span class="line">	<span class="keyword">auto</span> f = [i, &amp;j]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">		i = <span class="number">100</span>, j = <span class="number">100</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">f</span>();</span><br><span class="line">	<span class="comment">//输出:0 100</span></span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="说明符">说明符</h3>
<p>允许以下说明符：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>mutable：允许 函数体修改各个复制捕获的对象，以及调用其非 const 成员函数；</p>
</li>
<li class="lvl-2">
<p>constexpr：显式指定函数调用运算符为 constexpr 函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr 函数的所有要求，则它也会是 constexpr； (C++17 起)</p>
</li>
<li class="lvl-2">
<p>consteval：指定函数调用运算符为立即函数。不能同时使用 consteval 和 constexpr。(C++20 起)</p>
</li>
</ul>
</blockquote>
<p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。假如我们希望能改变一个被捕获的变量的值，就必须在参数列表后面加上关键字mutable。而一个引用捕获的变量则不受此限制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span></span><br><span class="line">	<span class="keyword">auto</span> f = [i, &amp;j]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">		i = <span class="number">100</span>, j = <span class="number">100</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">f</span>();</span><br><span class="line">	<span class="comment">//输出:0 100</span></span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回类型">返回类型 -&gt;</h3>
<p>当我们需要为一个lambda定义返回类型时，需要使用尾置返回类型。返回类型若缺省，则根据函数体中的 return 语句进行推断（如果有多条return语句，需要保证类型一直，否则编译器无法自动推断）。默认情况下，如果一个lambda函数体不包含return语句，则编译器假定返回void。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> f = []() -&gt;<span class="type">double</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="number">2.0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不显示指定返回类型，则int和double两种返回类型会导致推断冲突。</p>
<p><img src="https://s2.loli.net/2023/07/12/LB7RPprWyMbjYH3.png" alt=""></p>
<h3 id="函数体">函数体 { }</h3>
<p>略，同普通函数的函数体。</p>
<h3 id="综合示例">综合示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [introducer](optional)mutable throwSpec-&gt;retType &#123;&#125;</span></span><br><span class="line"><span class="comment">// mutable决定[]能够被改写  mutable throwSpec retType都是选择的,只要有一个存在就得写()</span></span><br><span class="line"><span class="comment">// retType 返回类型</span></span><br><span class="line"><span class="comment">// ()放参数</span></span><br><span class="line"><span class="comment">// []放外面变量 passed by value or reference</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnNamedLocalFunction</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> localVar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnNamedLocalFunction</span>(<span class="type">int</span> var) : <span class="built_in">localVar</span>(var) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val == localVar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string firstname;</span><br><span class="line">    string lastname;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LambdaFunctor</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_a &lt; n &amp;&amp; n &lt; m_b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> __x, __y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x, <span class="type">int</span> y) : __x(x), __y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下列 lambda 的语境是成员函数 X::f</span></span><br><span class="line">        <span class="comment">// 对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> [&amp;]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">operator</span>()(<span class="keyword">this</span>-&gt;__x + __y); <span class="comment">// X::operator()(this-&gt;x + (*this).y)</span></span><br><span class="line">            <span class="comment">// 拥有类型 X*</span></span><br><span class="line">        &#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__x;</span><br><span class="line">        &#125;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    [] &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> I = [] &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">I</span>();</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先看前面的id 如果没有mutable error: increment of read-only variable ‘id’</span></span><br><span class="line">    <span class="keyword">auto</span> f = [id]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        ++id;</span><br><span class="line">    &#125;;</span><br><span class="line">    id = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">f</span>();    <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">f</span>();    <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f</span>();    <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述lambda就相当于</span></span><br><span class="line"><span class="comment">//    class Functor &#123;</span></span><br><span class="line"><span class="comment">//    private:</span></span><br><span class="line"><span class="comment">//        int id;</span></span><br><span class="line"><span class="comment">//    public:</span></span><br><span class="line"><span class="comment">//        void operator() &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            ++id;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line"><span class="comment">//    Functor f;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 加不加mutable没影响,且传引用只要后面id1被修改了,就会使用修改后的值进行操作</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = [&amp;id1]() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        ++id1;</span><br><span class="line">    &#125;;</span><br><span class="line">    id1 = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">f1</span>();    <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">f1</span>();    <span class="comment">// 43</span></span><br><span class="line">    <span class="built_in">f1</span>();    <span class="comment">// 44</span></span><br><span class="line">    cout &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传参与返回</span></span><br><span class="line">    <span class="type">int</span> id2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;id2](<span class="type">int</span> &amp;param) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        ++id2;</span><br><span class="line">        ++param;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> id2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> param = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f2</span>(param);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [=] =表示默认以by value传递外部所有变量</span></span><br><span class="line">    <span class="comment">// [&amp;] &amp;表示默认以by reference传递外部所有变量</span></span><br><span class="line">    <span class="keyword">auto</span> f3 = [&amp;]() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一部分传引用,其余传值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f4 = [=, &amp;id]() &#123;       <span class="comment">// =不可以放在&amp;id后面</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        id++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一部分传值,其余传引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f5 = [&amp;, id]() &#123;       <span class="comment">// &amp;不可以放在id后面</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f5</span>();</span><br><span class="line">    <span class="comment">// this 指针</span></span><br><span class="line">    <span class="function">X <span class="title">x_</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x_.f()=&quot;</span> &lt;&lt; x_.<span class="built_in">f</span>() &lt;&lt; endl;   <span class="comment">// 1+2=3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x_.ff()=&quot;</span> &lt;&lt; x_.<span class="built_in">ff</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面lambda函数等价于上述的UnNamedLocalFunction</span></span><br><span class="line">    <span class="type">int</span> tobefound = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [tobefound](<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">return</span> val == tobefound;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">bool</span> b1 = <span class="built_in">lambda1</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function">UnNamedLocalFunction <span class="title">lambda2</span><span class="params">(tobefound)</span></span>;</span><br><span class="line">    <span class="type">bool</span> b2 = <span class="built_in">lambda2</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; b1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ll1 = [](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// lambda 匿名函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span> x)&gt; ll = [](<span class="type">int</span> x) -&gt; <span class="type">float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">10.0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">ll</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decltype+lambda</span></span><br><span class="line">    <span class="comment">// 比大小</span></span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">const</span> Person&amp;p1,<span class="type">const</span> Person&amp;p2)&gt; cmp = [](<span class="type">const</span> Person &amp;p1, <span class="type">const</span> Person &amp;p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.lastname &lt; p2.lastname;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于lambda,我们往往只有object,很少有人能够写出它的类型，而有时就需要知道它的类型,要获得其type,就要借助其decltype</span></span><br><span class="line">    <span class="function">set&lt;Person, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">col</span><span class="params">(cmp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要申明lambda对象的类型，可以使用template或者auto进行自动推导。</span></span><br><span class="line">    <span class="comment">// 如果需要知道类型，可以使用decltype，比如，让lambda函数作为关联容器或者无序容器的排序函数或者哈希函数。</span></span><br><span class="line">    <span class="comment">// 上面代码给出了事例（decltype的第三种用法中的事例），定义了一个lambda函数用cmp表示，用来比较Person对象的大小，传入到Set容器中去，</span></span><br><span class="line">    <span class="comment">// 但根据右边的set容器的定义，我们传入的不仅是cmp（构造函数），还要传入模板的cmp类型（Set内部需要声明cmp类型），</span></span><br><span class="line">    <span class="comment">// 所以必须使用decltype来推导出类型。</span></span><br><span class="line">    <span class="comment">// （如果没有向构造函数传入cmp，调用的是默认的构造函数，也就是set() : t(Compare()), 这里会报错, 现在不会出问题了!</span></span><br><span class="line">    <span class="comment">// 因为Compare()指的是调用默认的lambda构造函数，而lambda函数没有默认构造函数和赋值函数）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">5</span>, <span class="number">28</span>, <span class="number">50</span>, <span class="number">83</span>, <span class="number">70</span>, <span class="number">590</span>, <span class="number">245</span>, <span class="number">59</span>, <span class="number">24</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">30</span>, y = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 函数对象是很强大的，封装代码和数据来自定义标准库的行为，但需要写出函数对象需要写出整个class，这是不方便的，而且是非本地的，</span></span><br><span class="line">    <span class="comment">// 用起来也麻烦，需要去看怎样使用，另外编译出错的信息也不友好，而且它们不是inline的，效率会低一些（算法效率还是最重要的）。</span></span><br><span class="line"><span class="comment">//    vec.erase(remove_if(vec.begin(), vec.end(), LambdaFunctor(x, y)), vec.end());</span></span><br><span class="line"><span class="comment">//    for(auto i:vec) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// 而lambda函数的提出解决了这个问题，简短有效清晰，上面的事例很好的说明了这个问题，用lambda要简短许多，功能一样，很直观。</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [x, y](<span class="type">int</span> n) &#123; <span class="keyword">return</span> x &lt; n &amp;&amp; n &lt; y; &#125;), vec.<span class="built_in">end</span>());</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ Lambda表达式的基本使用: <a href="https://blog.csdn.net/gongjianbo1992/article/details/105128849">https://blog.csdn.net/gongjianbo1992/article/details/105128849</a></p>
<p>[2]	python中的lambda函数用法: <a href="https://zhuanlan.zhihu.com/p/58579207">https://zhuanlan.zhihu.com/p/58579207</a></p>
<p>[3]	C++ 那些事: <a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>C++左值与右值</title>
    <url>/archives/8502303e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="左值、右值">左值、右值</h2>
<p>C++ 11对C++ 98中的右值进行了扩充。在<strong>C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）</strong>。</p>
<p>左值是指可以出现在赋值操作符（=）的左边的表达式，它们具有持久的内存地址。左值可以被取地址（&amp;）操作符获取其内存地址，可以被修改，也可以作为参数传递给函数。</p>
<p>纯右值是指生成临时对象或字面量的表达式，它们通常是即将被使用的临时值。纯右值没有持久的内存地址，不能被取地址（&amp;）操作符获取其内存地址。例如，<code>int result = 2 + 3;</code> 中的 <code>2 + 3</code> 就是一个纯右值。</p>
<span id="more"></span>
<p>将亡值是指具有资源所有权的表达式，它们可以被移动（move）而不是复制（copy）。将亡值是一种特殊的右值引用，可以延长右值的生命周期，用于实现移动语义。通过将资源所有权转移给新对象，可以避免不必要的复制操作，提高了效率。例如，<code>std::vector&lt;int&gt; v1; std::vector&lt;int&gt; v2 = std::move(v1);</code> 中的 <code>std::move(v1)</code> 就是一个将亡值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;          <span class="comment">// a 是左值</span></span><br><span class="line">    <span class="type">int</span>&amp; b = a;          <span class="comment">// b 是左值引用</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; c = std::<span class="built_in">move</span>(a); <span class="comment">// c 是右值引用，将亡值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(a);              <span class="comment">// 调用 foo(int&amp; x)，因为 a 是左值</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>);             <span class="comment">// 调用 foo(int&amp;&amp; x)，因为 42 是纯右值</span></span><br><span class="line">    <span class="built_in">foo</span>(std::<span class="built_in">move</span>(a));   <span class="comment">// 调用 foo(int&amp;&amp; x)，因为 std::move(a) 是将亡值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bar</span>(a);              <span class="comment">// 完美转发，调用 foo(int&amp; x)</span></span><br><span class="line">    <span class="built_in">bar</span>(<span class="number">42</span>);             <span class="comment">// 完美转发，调用 foo(int&amp;&amp; x)</span></span><br><span class="line">    <span class="built_in">bar</span>(std::<span class="built_in">move</span>(a));   <span class="comment">// 完美转发，调用 foo(int&amp;&amp; x)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左值引用、右值引用">左值引用、右值引用</h2>
<p>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，<strong>由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在</strong>。</p>
<p><strong>右值引用和左值引用都是属于引用类型，并且都是左值</strong>。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p>
<p>左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = <span class="number">2</span>;       # 左值引用绑定到右值，编译失败</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;        # 非常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="number">2</span>;  # 常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b =<span class="number">2</span>;  # 常量左值引用绑定到右值，编程通过</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line"><span class="type">int</span> &amp;&amp;r2 = std::<span class="built_in">move</span>(a);  # 编译通过</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。<br>
<img src="https://img-blog.csdnimg.cn/d0517035f9af48be86bd99df75b5669e.png" alt=""></p>
<h2 id="std-move">std::move()</h2>
<p><strong>move作用是可以将一个左值转换成右值引用</strong>，从而可以调用C++11的拷贝构造函数。</p>
<h3 id="std-move-的实现">std::move()的实现</h3>
<p>std::move的实现主要依赖于static_cast&lt;T&amp;&amp; &gt;，但同时也会做一些参数推导（traits）的工作。其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>对于t为右值的情况，有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">move</span>(<span class="built_in">string</span>(<span class="string">&quot;dengwen&quot;</span>));</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>首先模板类型推导确定T的类型为string，得remove_reference::type为string，故返回值和static的模板参数类型都为string &amp;&amp;，而move的参数就是string &amp;&amp;,于是不需要进行类型转换直接返回。</p>
<p>对于t为左值的情况，引入一条规则：<strong>当将一个左值传递给一个参数是右值引用的函数，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断模板参数类型为实参的左值引用</strong>。有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;dengwen&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">move</span>(str);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>此时明显str是一个左值，首先模板类型推导确定T的类型为string &amp;，得remove_reference::type为string。故返回值和static的模板参数类型都为string &amp;&amp;，而move的参数类型为string&amp; &amp;&amp;，折叠后为sting &amp;。</p>
<p>所以结果就为将string &amp;通过static_cast转为string &amp;&amp;。返回string &amp;&amp;。</p>
<h2 id="引用折叠">引用折叠</h2>
<p>1.所有右值引用折叠到右值引用上仍然是一个右值引用。（<code>A&amp;&amp; &amp;&amp;</code> 变成 <code>A&amp;&amp;</code>）<br>
2.所有的其他引用类型之间的折叠都将变成左值引用。 （<code>A&amp; &amp;</code> 变成 <code>A&amp;</code>; <code>A&amp; &amp;&amp;</code> 变成 <code>A&amp;</code>; <code>A&amp;&amp; &amp;</code> 变成 <code>A&amp;</code>）</p>
<h2 id="完美转发">完美转发</h2>
<p>考虑下面例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">relay</span>(<span class="built_in">Test</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>在这个例子当中，我们的期待是，我们在main当中调用relay，Test的临时对象作为一个右值传入relay，在relay当中又被转发给了func，那这时候转发给func的参数t也应当是一个右值。也就是说，我们希望：<strong>当relay的参数是右值的时候，func的参数也是右值；当relay的参数是左值的时候，func的参数也是左值</strong>。</p>
<p>那么现在我们来运行一下这个程序，我们会看到，结果与我们预想的似乎并不相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>我们看到，在relay当中转发的时候，调用了复制构造函数，也就是说<strong>编译器认为这个参数t并不是一个右值，而是左值，因为它有一个名字</strong>。那么如果我们想要实现我们所说的，如果传进来的参数是一个左值，则将它作为左值转发给下一个函数；如果它是右值，则将其作为右值转发给下一个函数，我们应该怎么做呢？</p>
<p>这时，我们需要<code>std::forward&lt;T&gt;()</code>。<strong>与std::move()相区别的是，move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左右值类型</strong>。所以我们的代码应该是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">relay</span>(<span class="built_in">Test</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>现在运行的结果就成为了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">in relay</span><br><span class="line">move constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>而如果我们的调用方法变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">relay</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>那么输出就会变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>完美地实现了我们所要的转发效果。</p>
<h2 id="forward-的实现">forward()的实现</h2>
<p>std::forward()提供两个重载版本， 一个针对左值， 一个针对右值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line"><span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>根据以下实例进行分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; fparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::forward&lt;T&gt;(fparam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">foo</span>(i);</span><br><span class="line"><span class="built_in">foo</span>(<span class="number">47</span>);</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>在foo(i)， 如果传入的是一个左值， 那么foo中T的类型将是int&amp;, fparam类型是int&amp; &amp;&amp;, 经过折叠为int&amp;. 因此在std::forward模板函数中，推断出T的类型为int&amp;,因此，std::remove_reference用int&amp; 进行实例化。std::remove_reference的type成员是int。forward返回类型为int&amp; &amp;&amp;, 折叠为int&amp;。forward的参数类型__t为int&amp;。static_cast&lt;int &amp; &amp;&amp;&gt; 折叠为static_cast&lt;int &amp;&gt;。</p>
<p>因此std::forward最终被实例化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;<span class="type">__t</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&gt;(<span class="type">__t</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>可以发现，函数什么都不用做， 最终的传入forward的左值引用被保留了。</p>
<p>在foo(47)中， 传入的是一个右值，那么foo中T的类型将是int, fparam类型是T&amp;&amp;, 因此，在std::forward模板函数中推断出T的类型为int。因此， std::remove_reference用int 进行实例化。std::remove_reference的type成员是int。forward返回类型为int&amp;&amp;。forward的参数类型__t为int&amp;&amp;。static_cast&lt;int &amp;&amp; &amp;&amp;&gt; 折叠为static_cast&lt;int &amp;&amp;&gt;<br>
因此std::forward最终被实例化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;&amp;<span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;<span class="type">__t</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(<span class="type">__t</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>可以发现，函数什么都不用做， 最终的传入forward的右值引用被保留了。</p>
<p>通过以上分析， 实际上无论传递左值还是右值， forward都可以完美转发， 并且函数内部什么都不用做。</p>
<h2 id="函数返回值是左值还是右值">函数返回值是左值还是右值</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果函数返回值是引用类型，则为左值。</p>
</li>
<li class="lvl-2">
<p>如果函数返回值是值类型，则为右值。</p>
</li>
</ul>
<h2 id="如何判断一个值是左值还是右值">如何判断一个值是左值还是右值</h2>
<p>右值是能够赋值给左值，但是左值不能赋值给右值。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 左值和右值: <a href="https://blog.csdn.net/TABE_/article/details/122609775">https://blog.csdn.net/TABE_/article/details/122609775</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>左值与右值</tag>
      </tags>
  </entry>
  <entry>
    <title>RE（正则表达式）</title>
    <url>/archives/c7331187.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h1>RE（正则表达式）</h1>
<p>正则表达式（Regular Expression，简称为 “regex”）是一种用于处理字符串的强大工具，可以用来匹配、查找、替换和分割文本。在编程中，正则表达式广泛应用于文本处理和数据提取等场景。</p>
<p>通过在线工具（如 <a href="https://regex101.com/">regex101 ↗</a>）可以方便地测试和调试正则表达式。</p>
<span id="more"></span>
<h2 id="1-基本匹配">1. 基本匹配</h2>
<p>正则表达式是由字符和元字符组成的模式，用于描述字符串的一部分。字符就是普通的文本字符，例如 <code>a</code>、<code>b</code>、<code>1</code> 等；元字符具有特殊含义，用于表示某种模式。</p>
<h3 id="1-1-字符匹配">1.1 字符匹配</h3>
<p>在正则表达式中，大多数字符都与自身相匹配。例如，正则表达式 <code>abc</code> 匹配字符串 <code>&quot;abc&quot;</code>。</p>
<h3 id="1-2-元字符">1.2 元字符</h3>
<p>以下字符具有特殊含义，被称为元字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. ^ $ * + ? &#123; &#125; [ ] \ | ( )</span><br></pre></td></tr></table></figure>
<p>要在正则表达式中匹配这些字符本身，需要在它们前面加上反斜线 <code>\</code>。</p>
<h2 id="2-字符类">2. 字符类</h2>
<p>字符类允许我们匹配一组字符中的任意一个。它由一对方括号 <code>[</code> 和 <code>]</code> 包围，其中包含要匹配的字符。</p>
<p>例如，正则表达式 <code>[abc]</code> 匹配字符 <code>a</code>、<code>b</code> 或 <code>c</code>。</p>
<h3 id="2-1-范围">2.1 范围</h3>
<p>在字符类中，可以使用短横线 <code>-</code> 表示字符范围。例如，<code>[a-z]</code> 匹配任意小写字母；<code>[0-9]</code> 匹配任意数字。</p>
<h3 id="2-2-预定义字符类">2.2 预定义字符类</h3>
<p>正则表达式提供了一些预定义的字符类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>\d</code>：等价于 <code>[0-9]</code>，匹配任意数字。</p>
</li>
<li class="lvl-2">
<p><code>\D</code>：等价于 <code>[^0-9]</code>，匹配任意非数字字符。</p>
</li>
<li class="lvl-2">
<p><code>\w</code>：等价于 <code>[a-zA-Z0-9_]</code>，匹配任意字母、数字或下划线。</p>
</li>
<li class="lvl-2">
<p><code>\W</code>：等价于 <code>[^a-zA-Z0-9_]</code>，匹配任意非字母、数字或下划线的字符。</p>
</li>
<li class="lvl-2">
<p><code>\s</code>：匹配任意空白字符，如空格、制表符和换行符。</p>
</li>
<li class="lvl-2">
<p><code>\S</code>：匹配任意非空白字符。</p>
</li>
</ul>
<h2 id="3-量词">3. 量词</h2>
<p>量词指定一个模式出现的次数。常用的量词有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>*</code>：匹配前面的模式 0 次或多次。</p>
</li>
<li class="lvl-2">
<p><code>+</code>：匹配前面的模式 1 次或多次。</p>
</li>
<li class="lvl-2">
<p><code>?</code>：匹配前面的模式 0 次或 1 次。</p>
</li>
<li class="lvl-2">
<p><code>&#123;n&#125;</code>：匹配前面的模式正好 n 次。</p>
</li>
<li class="lvl-2">
<p><code>&#123;n,&#125;</code>：匹配前面的模式至少 n 次。</p>
</li>
<li class="lvl-2">
<p><code>&#123;n,m&#125;</code>：匹配前面的模式至少 n 次，最多 m 次。</p>
</li>
</ul>
<h2 id="4-分组和捕获">4. 分组和捕获</h2>
<p>使用圆括号 <code>(</code> 和 <code>)</code> 可以将多个字符组合成一个分组。例如，正则表达式 <code>(ab)+</code> 匹配字符串 <code>&quot;ab&quot;</code> 重复出现的部分，如 <code>&quot;ab&quot;</code>、<code>&quot;abab&quot;</code> 等。</p>
<p>分组还具有捕获功能，可以在匹配成功后提取分组中的内容。捕获的顺序是从左到右，按照左括号的顺序编号。</p>
<h2 id="5-断言">5. 断言</h2>
<p>断言用于判断字符串的当前位置是否满足某个条件，但不消耗字符。常用的断言有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>^</code>：匹配字符串的开始位置。</p>
</li>
<li class="lvl-2">
<p><code>$</code>：匹配字符串的结束位置。</p>
</li>
<li class="lvl-2">
<p><code>\b</code>：匹配单词的边界（即单词与空白字符之间的位置）。</p>
</li>
<li class="lvl-2">
<p><code>\B</code>：匹配非单词边界的位置。</p>
</li>
<li class="lvl-2">
<p><code>(?=...)</code>：正向先行断言，要求接下来的字符满足指定的模式，但不消耗字符。</p>
</li>
<li class="lvl-2">
<p><code>(?!...)</code>：负向先行断言，要求接下来的字符不满足指定的模式，但不消耗字符。</p>
</li>
</ul>
<h2 id="6-使用正则表达式的语言功能">6. 使用正则表达式的语言功能</h2>
<p>大多数编程语言都内置了对正则表达式的支持。以下是一些常见编程语言中使用正则表达式的示例：</p>
<h3 id="6-1-C">6.1 C++</h3>
<p>在 C++ 中，可以使用 <code>&lt;regex&gt;</code> 头文件中的正则表达式库来处理正则表达式。以下是一些常见的正则表达式库函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>std::regex_search(str, pattern)</code>：在字符串中查找指定模式的第一个匹配项。</p>
</li>
<li class="lvl-2">
<p><code>std::regex_match(str, pattern)</code>：检查字符串是否与指定模式完全匹配。</p>
</li>
<li class="lvl-2">
<p><code>std::regex_replace(str, pattern, newStr)</code>：将字符串中与指定模式匹配的项替换为指定的字符串。</p>
</li>
<li class="lvl-2">
<p><code>std::regex_iterator</code>：用于迭代查找字符串中所有与指定模式匹配的项。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\d+&quot;</span>)</span></span>; <span class="comment">// 创建一个匹配数字的正则表达式模式</span></span><br><span class="line">  std::string str = <span class="string">&quot;Found 42 items, each costs $15&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找第一个匹配项</span></span><br><span class="line">  std::smatch match;</span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(str, match, pattern)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First match: &quot;</span> &lt;&lt; match[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否完全匹配</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(str, pattern)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matched completely\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找所有匹配项</span></span><br><span class="line">  <span class="function">std::sregex_iterator <span class="title">it</span><span class="params">(str.begin(), str.end(), pattern)</span></span>;</span><br><span class="line">  std::sregex_iterator end;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;All matches: &quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (it != end) &#123;</span><br><span class="line">    std::cout &lt;&lt; (*it)[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++it;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换匹配项</span></span><br><span class="line">  std::string newStr = std::<span class="built_in">regex_replace</span>(str, pattern, <span class="string">&quot;NUMBER&quot;</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;New string: &quot;</span> &lt;&lt; newStr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-Python">6.2 Python</h3>
<p>在 Python 中，可以使用 <code>re</code> 模块处理正则表达式。以下是一些常见的 <code>re</code> 模块函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>re.search(pattern, string)</code>：在字符串中查找指定模式的第一个匹配项。</p>
</li>
<li class="lvl-2">
<p><code>re.findall(pattern, string)</code>：返回字符串中所有与指定模式匹配的项的列表。</p>
</li>
<li class="lvl-2">
<p><code>re.sub(pattern, repl, string, count=0)</code>：将字符串中与指定模式匹配的项替换为指定的字符串，可限制替换次数。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&#x27;\d+&#x27;</span></span><br><span class="line">string = <span class="string">&#x27;Found 42 items, each costs $15&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找第一个匹配项</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出：42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找所有匹配项</span></span><br><span class="line">numbers = re.findall(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># 输出：[&#x27;42&#x27;, &#x27;15&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换匹配项</span></span><br><span class="line">new_string = re.sub(pattern, <span class="string">&#x27;NUMBER&#x27;</span>, string)</span><br><span class="line"><span class="built_in">print</span>(new_string)  <span class="comment"># 输出：Found NUMBER items, each costs $NUMBER</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-JavaScript">6.3 JavaScript</h3>
<p>在 JavaScript 中，正则表达式可以使用 <code>RegExp</code> 对象表示。以下是一些常见的正则表达式方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>regex.test(string)</code>：测试字符串是否包含与正则表达式匹配的部分。</p>
</li>
<li class="lvl-2">
<p><code>regex.exec(string)</code>：在字符串中查找与正则表达式匹配的部分，返回一个匹配对象或 <code>null</code>。</p>
</li>
<li class="lvl-2">
<p><code>string.match(regex)</code>：返回一个数组，其中包含字符串中与正则表达式匹配的所有部分。</p>
</li>
<li class="lvl-2">
<p><code>string.replace(regex, replacement)</code>：将字符串中与正则表达式匹配的部分替换为指定的字符串。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/\d+/</span>;</span><br><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;Found 42 items, each costs $15&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试是否匹配</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">test</span>(string));  <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找第一个匹配项</span></span><br><span class="line"><span class="keyword">const</span> match = pattern.<span class="title function_">exec</span>(string);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>]);  <span class="comment">// 输出：42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找所有匹配项</span></span><br><span class="line"><span class="keyword">const</span> numbers = string.<span class="title function_">match</span>(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers);  <span class="comment">// 输出：[ &#x27;42&#x27;, &#x27;15&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换匹配项</span></span><br><span class="line"><span class="keyword">const</span> newString = string.<span class="title function_">replace</span>(pattern, <span class="string">&#x27;NUMBER&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newString);  <span class="comment">// 输出：Found NUMBER items, each costs $15</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>正则表达式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客</title>
    <url>/archives/ec7d7221.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="安装">安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>配置安装 <a href="https://liuaoao.top/archives/938d5a31.html">Git及NodeJS</a></p>
</li>
<li class="lvl-2">
<p>创建GitHub仓库（<strong>注意仓库的取名格式：<a href="http://xn--eqr924avxo.github.io">用户名.github.io</a>（这将是以后的访问域名）</strong>)</p>
</li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">
<p>安装Hexo</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Hexo</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init hexo</span><br><span class="line">cd hexo</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br><span class="line"><span class="section"># Next theme</span></span><br><span class="line">cd hexo</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div class="note info">
            <p>转移至新设备：</p><ol><li class="lvl-3">打包Blog文件夹到新设备</li><li class="lvl-3">配置 <a href="https://liuaoao.top/archives/938d5a31.html">Git及NodeJS</a></li><li class="lvl-3"><code>npm install hexo-cli -g</code></li></ol>
          </div>
<h2 id="Next主题博客个性化">Next主题博客个性化</h2>
<p><strong><code>主题配置文件</code><strong>和</strong><code>站点配置文件</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/hexo/_config.yml</span><br><span class="line">/hexo/themes/next/_config.yml</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p><code>hexo\source</code>新建 <code>\_data</code>文件夹</p>
</li>
<li class="lvl-3">
<p>复制<code>\hexo\themes\next\_config.yml</code> 到<code>\_data</code>文件夹并重命名为 <code>next.yml</code></p>
</li>
<li class="lvl-3">
<p>个性化配置+域名设置文件开箱即用：</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1FS_w7nfsuilyRjwAFKV2WA">https://pan.baidu.com/s/1FS_w7nfsuilyRjwAFKV2WA</a><br>
提取码：gy9r</p>
</blockquote>
</li>
</ol>
<h2 id="文章分类层级">文章分类层级</h2>
<ol>
<li class="lvl-3">
<p>分类一般用法</p>
<p>Hexo 中分类和标签有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>父子分类</p>
<p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">- Life</span><br></pre></td></tr></table></figure>
<p>会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p>
</li>
<li class="lvl-3">
<p>并列+子分类</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>
<p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。## hexo提示块</p>
</li>
</ol>
<h2 id="标签大小写">标签大小写</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br><span class="line">tags: [123, 456]</span><br></pre></td></tr></table></figure>
<p>实现上述分类，需要把<code>git config</code>忽略大小写关闭</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># E:\Work\Hexo-hexo\.deploy<span class="emphasis">_git\.git</span></span></span><br><span class="line"><span class="emphasis"><span class="section">[core]</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	repositoryformatversion = 0</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	filemode = false</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	bare = false</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	logallrefupdates = true</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	symlinks = false</span></span></span><br><span class="line"><span class="emphasis"><span class="section">-   ignorecase = true</span></span></span><br><span class="line"><span class="emphasis"><span class="section">+   ignorecase = false</span></span></span><br></pre></td></tr></table></figure>
<h2 id="提示块">提示块</h2>
<div class="note default">
            <p>default 提示块标签</p>
          </div>
<div class="note primary">
            <p>primary 提示块标签</p>
          </div>
<div class="note success">
            <p>success 提示块标签</p>
          </div>
<div class="note info">
            <p>info 提示块标签</p>
          </div>
<div class="note warning">
            <p>warning 提示块标签</p>
          </div>
<div class="note danger">
            <p>danger 提示块标签</p>
          </div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>使用方法</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选项卡">选项卡</h3>
<div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">tab 1</a></li><li class="tab"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 1</strong></p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 3</strong></p></div></div></div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>使用方法</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 1** </span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 2**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab A --&gt;</span><br><span class="line">**选项卡 3** 名字为A</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="升级Hexo及全部插件">升级Hexo及全部插件</h2>
<p>先安装 <code>npm-check</code> 和 <code>npm-upgrade</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check npm-upgrade</span><br></pre></td></tr></table></figure>
<p>安装完后，执行 <code>npm-check</code> 即可检查本地各插件版本情况。</p>
<p>执行 <code>npm-upgrade</code> 可根据当前版本和最新版本比较，让用户确认和选择是否升级。若用户确认升级，则会自动把 <code>package-lock.json</code> 和 <code>package.json</code> 文件内容进行更新后保存，然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update -g --save </span><br></pre></td></tr></table></figure>
<p>上述命令执行完毕，则所有通过 <code>npm-upgrade</code> 确认的插件全部都升级到最新（包括 Hexo）。</p>
<h2 id="Markdown语法注意">Markdown语法注意</h2>
<ul class="lvl-0">
<li class="lvl-2">


  Hexo 使用 Nunjucks 来解析文章（旧版本使用 Swig，两者语法类似），内容若包含 {{ }} 或 {% %} 可能导致解析错误，您可以用 raw 标签包裹来避免潜在问题发生。详情见[官方文档问答部分](https://hexo.io/docs/troubleshooting.html#Escape-Contents)。代码如下：

  
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">Hello &#123;% trans %&#125;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>== ** 等左侧开始侧加空格</p>
</li>
<li class="lvl-2">
<p>\转义（网址不要带最好/）</p>
</li>
<li class="lvl-2">
<p>图片不显示名称，删掉[]里的值</p>
</li>
</ul>
<h2 id="Reference">Reference</h2>
<p>[1]	超详细Hexo+Github博客搭建小白教程: <a href="https://zhuanlan.zhihu.com/p/35668237">https://zhuanlan.zhihu.com/p/35668237</a></p>
<p>[2]	hexo theme next7.8 主题美化: <a href="https://blog.csdn.net/tuckEnough/article/details/107383201">https://blog.csdn.net/tuckEnough/article/details/107383201</a></p>
<p>[3]	Github+Hexo搭建个人博客(图文详解): <a href="https://blog.csdn.net/weixin_45377770/article/details/105228938?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_45377770/article/details/105228938?spm=1001.2014.3001.5506</a></p>
<p>[4]	在hexo-NexT中插入note提示块: <a href="https://jinnsjj.github.io/uncategorized/hexo-next-note/">https://jinnsjj.github.io/uncategorized/hexo-next-note/</a></p>
]]></content>
      <categories>
        <category>Web</category>
        <category>Website</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类构造函数 &amp; 析构函数</title>
    <url>/archives/7b6761ef.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="类的构造函数">类的构造函数</h2>
<p>类的 <strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>(<span class="type">double</span> len);  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="type">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取默认设置的长度</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl;</span><br><span class="line">   <span class="comment">// 再次设置长度</span></span><br><span class="line">   line.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">Object is being created, length = 10</span></span><br><span class="line"><span class="comment">Length of line : 10</span></span><br><span class="line"><span class="comment">Length of line : 6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="使用初始化列表来初始化字段">使用初始化列表来初始化字段</h3>
<p>使用初始化列表来初始化字段：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len): <span class="built_in">length</span>(len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的语法等同于如下语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的析构函数">类的析构函数</h2>
<p>类的 <strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="type">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Line line;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置长度</span></span><br><span class="line">   line.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">Object is being created</span></span><br><span class="line"><span class="comment">Length of line : 6</span></span><br><span class="line"><span class="comment">Object is being deleted</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="调用顺序">调用顺序</h2>
<p>1、<strong>构造函数</strong>的调用顺序</p>
<p>基类构造函数、对象成员构造函数、派生类本身的构造函数</p>
<p>2、<strong>析构函数</strong>的调用顺序</p>
<p>派生类本身的析构函数、对象成员析构函数、基类析构函数（与构造顺序正好 <mark>相反</mark>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//    static B b;</span></span><br><span class="line">     B b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;D::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;D::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* pd = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    <span class="keyword">delete</span> pd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">-----&gt;B b</span></span><br><span class="line"><span class="comment">A::constructor</span></span><br><span class="line"><span class="comment">B::constructor</span></span><br><span class="line"><span class="comment">C::constructor</span></span><br><span class="line"><span class="comment">D::constructor</span></span><br><span class="line"><span class="comment">C::deconstructor</span></span><br><span class="line"><span class="comment">B::deconstructor</span></span><br><span class="line"><span class="comment">A::deconstructor</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----&gt;static B b</span></span><br><span class="line"><span class="comment">A::constructor</span></span><br><span class="line"><span class="comment">C::constructor</span></span><br><span class="line"><span class="comment">D::constructor</span></span><br><span class="line"><span class="comment">C::deconstructor</span></span><br><span class="line"><span class="comment">A::deconstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>static B b</code>：<code>B</code>类的构造函数没有被调用的原因是因为 <code>B</code> 类对象 <code>b</code> 被声明为静态成员变量。静态成员变量在类的定义中只是声明，需要在类外部进行定义和初始化。</p>
</blockquote>
<h2 id="拷贝构造函数-赋值构造函数">拷贝构造函数 &amp; 赋值构造函数</h2>
<p>拷贝构造函数和赋值构造函数都是C++中的特殊成员函数，用于在对象之间进行数据的拷贝操作。它们的定义和功能有所不同。</p>
<ol>
<li class="lvl-3">
<p>拷贝构造函数：拷贝构造函数用于创建一个新对象，该对象与另一个已存在的同类对象具有相同的值和属性。它的定义形式为：<code> 类名(const 类名&amp; 对象名)</code>。拷贝构造函数通常用于以下情况：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过赋值或参数传递方式将一个对象的值复制给另一个对象。</p>
</li>
<li class="lvl-2">
<p>当函数返回一个对象时，会调用拷贝构造函数来生成一个临时副本。</p>
</li>
<li class="lvl-2">
<p>当对象作为参数传递给函数时，会调用拷贝构造函数来生成参数对象的副本。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        <span class="comment">// 拷贝对象的数据</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    <span class="comment">// 使用拷贝构造函数创建一个新对象obj2，它与obj1具有相同的值</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>赋值构造函数：赋值构造函数用于将一个已存在的对象的值赋给另一个已存在的对象。它的定义形式为：<code>类名&amp; operator=(const 类名&amp; 对象名)</code>。赋值构造函数通常用于以下情况：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>在一个对象已经存在的情况下，将其赋值给另一个对象。</p>
</li>
<li class="lvl-2">
<p>对象在创建后需要动态地改变其值。</p>
</li>
<li class="lvl-2">
<p>赋值构造函数实际上是对对象的状态进行了复制,它们仍然是两个独立的对象，在内存中具有不同的地址。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 赋值构造函数</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        <span class="comment">// 将对象的数据赋值给当前对象</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line">    <span class="comment">// 将obj1的值赋给obj2，调用赋值构造函数</span></span><br><span class="line">    obj2 = obj1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>拷贝构造函数用于创建一个新对象，并将另一个对象的值复制给该新对象。</p>
</li>
<li class="lvl-2">
<p>赋值构造函数用于将一个已存在的对象的值赋给另一个已存在的对象。</p>
</li>
<li class="lvl-2">
<p>拷贝构造函数在对象创建、返回和参数传递时调用，赋值构造函数在对象赋值时调用。</p>
</li>
</ul>
<h2 id="Reference">Reference</h2>
<p>[1] 	C++ 类构造函数 &amp; 析构函数: <a href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">https://www.runoob.com/cplusplus/cpp-constructor-destructor.html</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>构造函数</tag>
        <tag>析构函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程</title>
    <url>/archives/9f089854.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="介绍">介绍</h2>
<blockquote>
<p><code>C++</code>多线程是指在<code>C++</code>程序中使用多个线程来实现并发执行的功能。多线程可以提高程序的性能和响应速度，同时也可以简化程序的设计和实现。</p>
<p>在<code>C++</code>中，可以使用标准库中的<code>thread</code>类来创建和管理线程。<code>thread</code>类提供了多个构造函数和成员函数，可以用于创建新线程、等待线程结束、获取线程<code>ID</code>等操作</p>
</blockquote>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;chrono&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std::chrono;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">using ull = unsigned long long;</span><br><span class="line">ull OddSum = <span class="number">0</span>;</span><br><span class="line">ull EvenSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">void findEven(ull start, ull end) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ull i = start; i &lt;= end; ++i)</span><br><span class="line">    <span class="comment">#  i 的二进制表示中最低位与 1 的按位与</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            EvenSum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void findOdd(ull start, ull end) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ull i = start; i &lt;= end; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            OddSum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    ull start = <span class="number">0</span>, end = <span class="number">1900000000</span>;</span><br><span class="line"></span><br><span class="line">    auto startTime = high_resolution_clock::now();</span><br><span class="line">    findOdd(start, end);</span><br><span class="line">    findEven(start, end);</span><br><span class="line">    auto stopTime = high_resolution_clock::now();</span><br><span class="line">    auto duration = duration_cast&lt;microseconds&gt;(stopTime - startTime);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;OddSum : &quot;</span> &lt;&lt; OddSum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;EvenSum: &quot;</span> &lt;&lt; EvenSum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sec: &quot;</span> &lt;&lt; duration.count() / <span class="number">1000000</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建线程的五种类型">创建线程的五种类型</h2>
<ol>
<li class="lvl-3">
<p><strong>function_pointer</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// <span class="number">1.</span>函数指针</span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(<span class="built_in">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意：如果我们创建多线程 并不会保证哪一个先开始</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    std::thread t1(fun, <span class="number">10</span>);</span><br><span class="line">//    std::thread t2(fun, <span class="number">10</span>);</span><br><span class="line">    t1.join();</span><br><span class="line">//    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++ 中，函数名可以被视为指向函数代码的指针。在这里，<code>fun</code> 函数被用作线程的入口函数，它会在新的线程中被执行。在创建线程时，我们将 <code>fun</code> 函数的地址作为参数传递给了 <code>std::thread</code> 构造函数。</p>
</blockquote>
<ol start="2">
<li class="lvl-3">
<p><strong>lambda_function</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.函数指针</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 注意：如果我们创建多线程 并不会保证哪一个先开始</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 2.Lambda函数</span><br><span class="line">    auto fun = [](int x) &#123;</span><br><span class="line">        while (x-- &gt; 0) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">//    std::1.thread t1(fun, 10);</span><br><span class="line">    // 也可以写成下面：</span><br><span class="line">    std::thread t1_1([](int x) &#123;</span><br><span class="line">        while (x-- &gt; 0) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 11);</span><br><span class="line">//    std::1.thread t2(fun, 10);</span><br><span class="line">//    t1.join();</span><br><span class="line">    t1_1.join();</span><br><span class="line">//    t2.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p><strong>functor</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// <span class="number">3.</span>functor (Funciton Object)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    void operator()(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t(Base(), <span class="number">10</span>);</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p><strong>no_static_member_function</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// <span class="number">4.</span>Non-static member function</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    void fun(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    Base b;</span><br><span class="line">    thread t(&amp;Base::fun,&amp;b, <span class="number">10</span>);</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>函数名与函数指针的相关解释</p><p>第一种：函数名与<code>FunP</code>函数指针都是函数指针。<code>fun</code>是一个函数指针常量，<code>funP</code>是一个函数数指针变量。</p><p>虽然通过常量与变量来解释函数名无法赋值可以帮助理解，但是我们发现对<code>fun</code>赋值时编译器给的错误提示并不是说对常量进行赋值，而是告诉我们<code>=</code>号两端格式不匹配。对此，第二种理解更合理。</p><p>第二种：函数名和数组名实际上都不是指针，但是，在使用时可以退化成指针，即编译器可以帮助我们实现自动的转换。</p><p>这也可以解释为什么当我们在<code>=</code>号右侧使用函数名时，无论是取值还是取地址都没有问题，因为编译替我们做了相当于强制类型转换的工作，而在当函数名在<code>=</code>号左侧时，右侧的函数指针并没有这个功能，毕竟他们俩不是同一种结构。</p>
          </div>
<ol start="5">
<li class="lvl-3">
<p><strong>static_member_function</strong></p>
</li>
</ol>
<blockquote>
<p>非静态成员函数只能通过类的对象进行调用，因为它们需要访问对象的状态。这与静态成员函数不同，后者可以直接通过类名进行调用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// <span class="number">4.</span>static member function</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    static void fun(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t(&amp;Base::fun, <span class="number">10</span>);</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Join-与-Detachs">Join 与 Detachs</h2>
<ol>
<li class="lvl-3">
<p><strong>join</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>一旦线程开始，我们要想等待线程完成，需要在该对象上调用<code>join()</code>双重<code>join</code>将导致程序终止</p>
<blockquote>
<p>调用 <code>join()</code> 后会进入“已加入状态”，即该线程对象已经完成其任务并已经被系统回收。如果再次调用该线程对象的 join()，会导致程序崩溃。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>在join之前我们应该检查显示是否可以被<code>join</code>,通过使用<code>joinable()</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;chrono&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void run(<span class="built_in">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t1(run, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">if</span> (t1.joinable()) &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() after&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p><strong>detach</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-3">
<p>这用于从父线程分离新创建的线程</p>
</li>
<li class="lvl-3">
<p>在分离线程之前，请务必检查它是否可以<code>joinable</code>，否则可能会导致两次分离，并且双重<code>detach()</code>将导致程序终止</p>
</li>
<li class="lvl-3">
<p>如果我们有分离的线程并且main函数正在返回，那么分离的线程执行将被挂起</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;chrono&gt;</span></span><br><span class="line"><span class="comment">#include &lt;mutex&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void run(<span class="built_in">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t1(run, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    t1.detach();</span><br><span class="line">    <span class="keyword">if</span>(t1.joinable())</span><br><span class="line">        t1.detach();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() after&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mutex-in-C-Threading">mutex in C++ Threading</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>critical_section</strong></p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>这段代码创建了两个线程<code>t1</code>和<code>t2</code>，它们都会执行<code>countgold()</code>函数，用于计算一个共享变量<code>sum</code>的值。<code>countgold()</code>函数使用了一个互斥锁来保护共享变量<code>sum</code>的访问。</p>
</li>
<li class="lvl-3">
<p><code>main()</code>函数启动了两个线程，并等待它们完成。一旦两个线程都完成了计算，程序就会输出sum的最终值。由于使用了互斥锁，程序可以保证每次只有一个线程能够修改sum变量，因此最终结果是可预测的。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;mutex&gt;</span></span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>; //shared</span><br><span class="line"></span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line">void *countgold() &#123;</span><br><span class="line">    <span class="built_in">int</span> i; //local to each thread</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        m.lock();</span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">1</span>;</span><br><span class="line">        m.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t1(countgold);</span><br><span class="line">    thread t2(countgold);</span><br><span class="line"></span><br><span class="line">    //Wait <span class="keyword">for</span> both threads to finish</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; <span class="built_in">sum</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>mutex</code>提供了两个主要的操作：<code>lock()</code>和<code>unlock()</code>。在访问共享资源之前，线程需要调用<code>lock()</code>函数来获取互斥锁；在访问完成之后，线程需要调用<code>unlock()</code>函数来释放互斥锁。当一个线程已经获取了互斥锁时，其他线程将无法获取该锁，直到该线程释放了锁。这样可以保证在任何时候只有一个线程能够访问共享资源，从而避免了竞态条件的发生。</p>
</blockquote>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 那些事: <a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python优化提速</title>
    <url>/archives/d933fa60.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="前言">前言</h2>
<p><code>Python</code> 相对于其他编程语言被认为较慢，主要有以下几个原因：</p>
<ol>
<li class="lvl-3">
<p>解释型语言：<code>Python</code>是一种解释型语言，而不是编译型语言。在程序执行时，<code>Python</code>解释器会逐行解释和执行代码，这会引入一定的开销。相比之下，编译型语言如<code>C++</code>在运行之前会将代码编译成机器码，因此执行速度更快。</p>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li class="lvl-3">
<p>动态类型和动态内存管理：<code>Python</code>是一种动态类型语言，变量的类型可以在运行时动态改变。这导致在运行时需要进行类型检查和转换，增加了运行时的开销。此外，<code>Python</code>还使用了自动的内存管理机制，即垃圾回收机制，用于自动分配和释放内存。垃圾回收的开销也会影响<code>Python</code>的性能。</p>
</li>
<li class="lvl-3">
<p>全局解释锁（<code>GIL</code>）：<code>Python</code>的标准解释器（<code>CPython</code>）中存在一个全局解释锁（<code>GIL</code>），它限制了同一时间只能有一个线程执行<code>Python</code>字节码。这意味着在多线程的情况下，<code>Python</code>无法有效地利用多核处理器的优势，导致在处理计算密集型任务时性能受限。但是，值得注意的是，在<code>I/O</code>密集型任务中，由于<code>GIL</code>会在<code>I/O</code>操作时释放，因此多线程可以提高性能。</p>
</li>
<li class="lvl-3">
<p>部分库的实现方式：<code>Python</code>的一些常用库和模块使用了底层用<code>C</code>或<code>C++</code>编写的扩展模块，这些模块的性能比纯<code>Python</code>代码高。然而，并非所有的库都使用这种方式，一些纯<code>Python</code>实现的库性能可能较低。</p>
</li>
</ol>
<h2 id="常规小技巧">常规小技巧</h2>
<ol>
<li class="lvl-3">
<p><strong>列表推导（List Comprehension）</strong>：使用列表推导可以将<code>for</code>循环转化为更高效的单行表达式。它可以通过在一个列表中使用<code>for</code>循环来创建另一个列表。列表推导通常比显式的<code>for</code>循环更快，因为它利用了底层的优化机制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> numbers]</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>map()</strong> 函数：使用<code>map()</code>函数可以将一个函数应用到一个可迭代对象的所有元素上，并返回一个新的可迭代对象。这种方式可以比显式的<code>for</code>循环更快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers))</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用<code>numpy</code>库：如果你在处理大量的数值数据，使用<code>numpy</code>库可以显著加快<code>for</code>循环的运算。<code>numpy</code>是一个高性能的科学计算库，提供了多维数组和向量化操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">numbers = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">squared = numbers**<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>并行计算</strong>：如果你需要对一个较大的数据集进行计算，并且这些计算是相互独立的，你可以考虑使用并行计算来加速<code>for</code>循环。<code>Python</code>中有一些库，如<code>multiprocessing</code>和<code>concurrent.futures</code>，可以方便地实现并行计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Pool() <span class="keyword">as</span> pool:</span><br><span class="line">    squared = pool.<span class="built_in">map</span>(square, numbers)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Pandas加速循环">Pandas加速循环</h2>
<ol>
<li class="lvl-4">
<p><code>Iterrows()</code>为每一行返回一个<code> Series</code>，因此它以索引对的形式遍历<code>DataFrame</code>，以<code>Series</code>的形式遍历目标列，这使得它比标准循环更快。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建示例DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用iterrows()遍历DataFrame</span></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    <span class="comment"># 访问每一行的数值</span></span><br><span class="line">    a_value = row[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">    b_value = row[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行操作</span></span><br><span class="line">    result = a_value + b_value</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-4">
<p><code>apply</code>本身并不快，但与<code>DataFrame</code>结合使用时，它具有很大的优势。这取决于<code>apply</code>表达式的内容。 如果它可以在<code>Cython</code>中执行，那么<code>apply</code>要快得多。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建示例DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用apply()遍历DataFrame的每一行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_values</span>(<span class="params">row</span>):</span><br><span class="line">    <span class="comment"># 访问每一行的数值</span></span><br><span class="line">    a_value = row[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">    b_value = row[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行操作</span></span><br><span class="line">    <span class="keyword">return</span> a_value + b_value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用apply()进行循环操作</span></span><br><span class="line">result = df.apply(add_values, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>利用向量化<code>Pandas Vectorization</code>的优势来创建真正高效的代码</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">80</span>, <span class="number">90</span>, np.inf]</span><br><span class="line">labels = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;grade&#x27;</span>] = pd.cut(df[<span class="string">&#x27;score&#x27;</span>], bins=bins, labels=labels)</span><br></pre></td></tr></table></figure>
<p>以上示例中，通过直接对整个<code>DataFrame</code>或<code>Series</code>进行操作，避免了显式的循环，并且利用了底层的C实现来提高运算效率。向量化操作通常比迭代方式更高效，并且能够简化代码，提高可读性。</p>
<h2 id="itertools加速循环">itertools加速循环</h2>
<p><code>itertools</code> 是一个强大的 <code>Python</code> 模块，提供了许多用于迭代和组合的工具函数。虽然 <code>itertools</code> 本身并不会直接加速循环，但可以通过它提供的函数来优化循环的效率。</p>
<p>下面是一些使用 <code>itertools</code> 加速循环的示例：</p>
<ol>
<li class="lvl-4">
<p><code>itertools.chain()</code>: 如果你有多个可迭代对象，可以使用 <code>itertools.chain()</code> 将它们连接起来，从而避免多次嵌套循环。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i, j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 itertools.chain()</span></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">10</span>), <span class="built_in">range</span>(<span class="number">5</span>)):</span><br><span class="line">    <span class="built_in">print</span>(i, j)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-4">
<p><code>itertools.islice()</code>: 当你只需要迭代可迭代对象的一部分时，可以使用 <code>itertools.islice()</code> 来切片迭代。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list[<span class="number">3</span>:<span class="number">7</span>]:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 itertools.islice()</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> itertools.islice(my_list, <span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-4">
<p><code>itertools.compress()</code>: 如果你想根据某个条件过滤迭代对象，可以使用 <code>itertools.compress()</code> 来实现。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">my_condition = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item, condition <span class="keyword">in</span> <span class="built_in">zip</span>(my_list, my_condition):</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 itertools.compress()</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> itertools.compress(my_list, my_condition):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<p>这只是一些使用 <code>itertools</code> 加速循环的示例。根据具体的需求，你还可以探索其他 <code>itertools</code> 函数，如 <code>itertools.filterfalse()</code>、<code>itertools.groupby()</code> 等。</p>
<h2 id="Numba-makes-Python-code-fast">Numba makes Python code fast</h2>
<p><code>Numba</code>是一个适用于使用<code>NumPy</code>数组、函数和循环的<code>Python</code>即时编译器。使用<code>Numba</code>的常见方式是通过应用修饰符来编译函数。当调用使用<code>Numba</code>修饰的函数时，它会被即时编译为机器码，从而使代码的全部或部分以本地机器码速度运行。</p>
<h3 id="安装">安装</h3>
<p><code>Numba</code> 可用作<a href="https://www.anaconda.com/">Anaconda Python 发行版的</a><a href="https://conda.io/docs/">conda</a>包 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ conda install numba</span><br></pre></td></tr></table></figure>
<p><code>Numba</code> 也有可用的pip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install numba</span><br></pre></td></tr></table></figure>
<h3 id="装饰器-jit来尝试和加速一些功能">装饰器<code>@jit</code>来尝试和加速一些功能</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>) </span><span class="comment"># Set &quot;nopython&quot; mode for best performance, equivalent to @njit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go_fast</span>(<span class="params">a</span>): <span class="comment"># Function is compiled to machine code when called the first time</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a.shape[<span class="number">0</span>]):   <span class="comment"># Numba likes loops</span></span><br><span class="line">        trace += np.tanh(a[i, i]) <span class="comment"># Numba likes NumPy functions</span></span><br><span class="line">    <span class="keyword">return</span> a + trace              <span class="comment"># Numba likes NumPy broadcasting</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(go_fast(x))</span><br></pre></td></tr></table></figure>
<h3 id="其他感兴趣的事情：">其他感兴趣的事情：</h3>
<p><code>Numba</code> 有很多装饰器，我们已经看到了<code>@jit</code>，但也有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>@njit</code>- 这是一个别名，因为<code>@jit(nopython=True)</code>它很常用！</p>
</li>
<li class="lvl-2">
<p><code>@vectorize</code>- 生成 <code>NumPy</code> <code>ufunc</code>（支持所有方法<code>ufunc</code>）。<a href="https://numba.readthedocs.io/en/stable/user/vectorize.html#vectorize">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@guvectorize</code>- 生成 <code>NumPy</code> 广义<code>ufunc</code>s。 <a href="https://numba.readthedocs.io/en/stable/user/vectorize.html#guvectorize">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@stencil</code>- 声明一个函数作为类似模板操作的内核。 <a href="https://numba.readthedocs.io/en/stable/user/stencil.html#numba-stencil">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@jitclass</code>- 对于 jit 感知类。<a href="https://numba.readthedocs.io/en/stable/user/jitclass.html#jitclass">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@cfunc</code>- 声明一个用作本机回调的函数（从 <code>C/C++ </code>等调用）。<a href="https://numba.readthedocs.io/en/stable/user/cfunc.html#cfunc">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@overload</code>- 注册您自己的函数实现以在 nopython 模式下使用，例如<code>@overload(scipy.special.j0)</code>. <a href="https://numba.readthedocs.io/en/stable/extending/high-level.html#high-level-extending">文档在这里</a>。</p>
</li>
</ul>
<p>一些装饰器中可用的额外选项：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>parallel = True</code>-<a href="https://numba.readthedocs.io/en/stable/reference/jit-compilation.html#jit-decorator-parallel">启用</a>函数的自动 <a href="https://numba.readthedocs.io/en/stable/user/parallel.html#numba-parallel">并行化。</a></p>
</li>
<li class="lvl-2">
<p><code>fastmath = True</code>- 为函数启用<a href="https://numba.readthedocs.io/en/stable/reference/jit-compilation.html#jit-decorator-fastmath">快速数学行为。</a></p>
</li>
</ul>
<p><code>ctypes/cffi/cython </code>互操作性：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>cffi</code>- 模式支持<a href="https://numba.readthedocs.io/en/stable/reference/pysupported.html#cffi-support">CFFI</a>函数的调用<code>nopython</code>。</p>
</li>
<li class="lvl-2">
<p><code>ctypes</code>-模式支持调用<a href="https://numba.readthedocs.io/en/stable/reference/pysupported.html#ctypes-support">ctypes</a><code>nopython</code>包装函数。</p>
</li>
<li class="lvl-2">
<p><code>Cython</code> 导出的函数<a href="https://numba.readthedocs.io/en/stable/extending/high-level.html#cython-support">是可调用的</a>。</p>
</li>
</ul>
<h3 id="GPU-目标：">GPU 目标：</h3>
<p><code>Numba</code> 可以针对<a href="https://developer.nvidia.com/cuda-zone">Nvidia CUDA</a> GPU。您可以用纯 Python 编写内核并让 Numba 处理计算和数据移动（或明确地执行此操作）。单击以获取有关 <a href="https://numba.readthedocs.io/en/stable/cuda/index.html#cuda-index">CUDA</a>的 Numba 文档。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git及NodeJS安装配置</title>
    <url>/archives/938d5a31.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Git安装">Git安装</h2>
<p>在 Windows 上安装：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://git-scm.com/download/win">Git for Windows</a> 是运行在Windows系统上的Git版本，它提供了与其他版本相同的功能和命令，以便Windows用户能够使用Git来开发和管理项目。同时，Git for Windows还提供了额外的工具和选项，如Bash命令行工具和ssh客户端。</p>
</li>
<li class="lvl-3">
<p><a href="https://desktop.github.com/">GitHub Desktop</a>是一个可视化的GitHub客户端程序，它帮助用户简化了使用Git控制代码版本的复杂性。通过GitHub Desktop，用户可以方便地克隆、更新、提交和推送代码，管理分支和合并请求，以及与他人协作开发代码。它适用于Windows和macOS操作系统，并且是免费提供下载和使用的。</p>
</li>
</ul>
<span id="more"></span>
<h3 id="Git-for-Windows-2-39-2">Git for Windows(2.39.2)</h3>
<ol>
<li class="lvl-3">
<p>修改安装路径</p>
</li>
<li class="lvl-3">
<p>选择安装组件，选择如下</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/13/Zt7JU2mjPwq9DNu.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>选择<code>Git</code>默认编辑器，默认<code>Vim</code></p>
</li>
<li class="lvl-3">
<p>调整新存储库中的初始分支的名称，默认<code>Let Git decide</code></p>
</li>
<li class="lvl-3">
<p>调整<code>PATH</code>环境，默认即可</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/13/n3yBG1Rx6K8viTY.png" alt=""></p>
<ol start="6">
<li class="lvl-3">
<p>选择<code>SSH</code>可执行文件，默认<code>Use bundled OpenSSH</code></p>
</li>
<li class="lvl-3">
<p>选择<code>HTTPS</code>后端传输，默认<code>Use the OpenSSL library</code></p>
</li>
<li class="lvl-3">
<p>配置行结束转换，默认<code>Checkout Windows-style, commit Unix-style line endings</code></p>
</li>
<li class="lvl-3">
<p>配置终端模拟器以与<code>Git Bash</code>一起使用，默认<code>Use MinTTY(the default terminal of MSYS2)</code></p>
</li>
<li class="lvl-4">
<p>选择<code>git pull</code>的默认行为，默认<code>Default (fast-forward or merge)</code></p>
</li>
<li class="lvl-4">
<p>选择凭据助手，默认<code>Git Credential Manager</code></p>
</li>
<li class="lvl-4">
<p>配置额外选项，默认<code>Enable file system caching</code></p>
</li>
<li class="lvl-4">
<p>配置实验选项，默认即可</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/13/g9QYUONCXtD2aTS.png" alt=""></p>
<ol start="14">
<li class="lvl-4">
<p>测试</p>
</li>
</ol>
<p>安装完成，可以在开始菜单中看到<code>Git</code>的三个启动图标<code>（Git Bash、Git CMD、Git GUI）</code>,推荐使用<code>Git Bash</code></p>
<p><img src="https://s2.loli.net/2023/05/13/NtR31WeHUvMrC8u.png" alt=""></p>
<h4 id="配置SSH">配置SSH</h4>
<ol>
<li class="lvl-3">
<p><code>Git Bash</code>:</p>
</li>
</ol>
<p><code>Git Bash</code>中<code>Ctrl+ins</code> 复制 <code>Shift+ins</code>粘贴</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;Humble-LiuAo&quot;</span></span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;1743185682@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;1743185682@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>新建SSH</p>
</li>
</ol>
<p>登录 <a href="https://link.zhihu.com/?target=http%3A//github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code></p>
<ol start="3">
<li class="lvl-3">
<p><code>git bash</code>:</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>将输出的内容复制到 <code>github SSH</code>,点击确定保存</p>
<ol start="4">
<li class="lvl-3">
<p>验证</p>
</li>
</ol>
<p>输入<code>ssh -T git@github.com</code>，显示如下信息，配置成功</p>
<p><img src="https://s2.loli.net/2023/05/13/q4oE6MkztX9amBi.png" alt=""></p>
<h2 id="NodeJS安装">NodeJS安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>下载安装：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p>
</li>
<li class="lvl-2">
<p>修改全局包保存路径（非必须）</p>
</li>
</ul>
<p>下载全局包时，默认保存在C盘下，可通过 <code>npm root -g</code> 命令查看当前路径，有时候想把全局包放在其他目录下，以免占用C盘空间。</p>
<p>在安装目录下创建两个文件夹，<code>node_global </code>全局包存放，<code>node_cache</code> node缓存。</p>
<p><img src="https://s2.loli.net/2023/05/13/hzdHwlSCp3RujUr.png" alt=""></p>
<ol>
<li class="lvl-3">
<p>在cmd命令行中执行如下两条命令</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config set prefix <span class="string">&quot;D:\Software\nodejs\node_global&quot;</span></span><br><span class="line">npm config set cache <span class="string">&quot;D:\Software\nodejs\node_cache&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>修改环境变量</p>
</li>
</ol>
<p>上面步骤里更改了<code>npm</code>全局模块的存放路径和<code>cache</code>路径，但是系统还不知道，所以需要修改环境变量。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改用户变量 <code>path</code>，添加 <code>node_global</code> 的路径</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/13/IyAcesFCoTz3Xwa.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加系统变量 <code>NODE_PATH</code></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/13/TtWgGUVuB92YQA7.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	Git 详细安装教程（详解 Git 安装过程的每一个步骤）: <a href="https://blog.csdn.net/mukes/article/details/115693833">https://blog.csdn.net/mukes/article/details/115693833</a></p>
<p>[2]	NodeJS安装及配置(Windows): <a href="https://blog.csdn.net/yaorongke/article/details/119084295">https://blog.csdn.net/yaorongke/article/details/119084295</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>代理与内网穿透</title>
    <url>/archives/b512fc98.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="代理">代理</h2>
<h3 id="什么是反向代理？">什么是反向代理？</h3>
<p>反向代理是位于 Web 服务器前面的服务器，其将客户端（例如 Web 浏览器）请求转发到这些 Web 服务器。反向代理通常用于帮助提高<a href="https://www.cloudflare.com/learning/security/what-is-web-application-security/">安全性</a>、<a href="https://www.cloudflare.com/learning/performance/why-site-speed-matters/">性能</a>和可靠性。为了更好地理解反向代理的工作原理以及它可以提供的好处，我们来首先定义什么是代理服务器。</p>
<span id="more"></span>
<h3 id="什么是代理服务器？">什么是代理服务器？</h3>
<p>转发代理，通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机之前的服务器。当这些计算机向 Internet 上的站点和服务发出请求时，代理服务器将拦截这些请求，然后代表客户端与 Web 服务器进行通信，起到中间设备的作用。</p>
<p>例如，典型的转发代理通信中涉及 3 台计算机：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>A：这是用户的家用计算机</p>
</li>
<li class="lvl-2">
<p>B：这是一个转发代理服务器</p>
</li>
<li class="lvl-2">
<p>C：这是网站的源站（用于存储网站数据）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/jNpMBu3SwHXDsdF.png" alt="正向代理流：流量从用户的设备 (A) 到正向代理 (B) 到互联网到源服务器 (C)"></p>
<p>在标准的互联网通信中，计算机 A 将直接与计算机 C 保持联系，客户端将请求发送到<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源服务器</a>，并且源服务器将响应客户端。当存在转发代理时，A 将请求发送到 B，B 随后将请求转发给 C。C 将向 B 发送响应，而 B 则将响应转发给 A。</p>
<p>为什么要将这个多余的中间设备添加到 Internet 活动中？使用转发代理可能有几个原因：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>为避免州或机构的浏览限制</strong>——一些政府、学校和其他组织使用防火墙来使用户访问受限版本的互联网。转发代理可用于绕过这些限制，因为它们使用户可以连接到代理，而不是直接连接到他们正在访问的站点。</p>
</li>
<li class="lvl-2">
<p><strong>阻止访问某些内容</strong>——相对的，也可以设置代理以阻止特定用户群访问某些站点。例如，学校网络可能配置为通过启用内容筛选规则的代理连接到 Web，以拒绝转发来自 Facebook 和其他社交媒体网站的响应。</p>
</li>
<li class="lvl-2">
<p><strong>保护自己的在线身份</strong>——在某些情况下，常规互联网用户希望增加在线匿名性，但在其他情况下，互联网用户居住在政府可能对政治异议者施加严重后果的地方。在网络论坛或社交媒体上批评政府可能会导致这些用户受到罚款或监禁。如果持不同政见者使用转发代理连接到他们发布政治敏感评论的网站，则用于发表评论的 <a href="https://www.cloudflare.com/learning/dns/glossary/what-is-my-ip-address/">IP 地址</a>将更难追溯到持不同政见者。仅代理服务器的 IP 地址将对他人可见。</p>
</li>
</ul>
<h3 id="反向代理有何不同？">反向代理有何不同？</h3>
<p>反向代理是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求。这与转发代理不同 - 在转发代理中，代理位于客户端的前面。使用反向代理，当客户端将请求发送到网站的源服务器时，反向代理服务器会在<a href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/">网络边缘</a>拦截这些请求。然后，反向代理服务器将向源服务器发送请求并从源服务器接收响应。</p>
<p>转发代理和反向代理之间的区别非常细微，但非常重要。简单概括而言，转发代理位于客户端的前面，确保没有源站直接与该特定客户端通信；而反向代理服务器位于源站前面，确保没有客户端直接与该源站通信。</p>
<p>这一次，所涉及的计算机包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>D：任意数量的用户家用计算机</p>
</li>
<li class="lvl-2">
<p>E：这是反向代理服务器</p>
</li>
<li class="lvl-2">
<p>F：一台或多台源站</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/IoGSXLkaHTrl7PU.png" alt="反向代理流：流量从用户的设备 (D) 到互联网到反向代理 (E) 到源服务器 (F)"></p>
<p>通常，来自 D 的所有请求都将直接发送到 F，而 F 会直接将响应发送到 D。使用反向代理，来自 D 的所有请求都将直接发送给 E，而 E 会将其请求发送到 F 并从 F 接收响应，然后将适当响应传递给 D。</p>
<p>下面是反向代理的一些好处：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><a href="https://www.cloudflare.com/learning/cdn/cdn-load-balance-reliability/">负载均衡</a></strong> - 一个每天吸引数百万用户的热门网站可能无法使用单个源服务器处理所有传入站点流量。但该站点可以分布在不同服务器的池中，让所有服务器都处理同一站点的请求。在这种情况下，反向代理可以提供一种负载均衡解决方案，在不同服务器之间平均分配传入流量，以防止单个服务器过载。如果某台服务器完全无法运转，则其他服务器可以代为处理流量。</p>
</li>
<li class="lvl-2">
<p><strong>防范攻击</strong> - 配备反向代理后，网站或服务无需透露其源服务器的 IP 地址。这使得攻击者更难利用针对性攻击，例如 <a href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/">DDoS 攻击</a>。这时候，攻击者只能针对反向代理，例如 Cloudflare 的 <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/">CDN</a>，而后者拥有具有更严格的安全性，拥有更多资源来抵御网络攻击。</p>
</li>
<li class="lvl-2">
<p><strong><a href="https://www.cloudflare.com/learning/cdn/glossary/global-server-load-balancing-gslb/">全局服务器负载平衡</a> (GSLB)</strong> - 在这种负载均衡形式中，一个网站可以分布在全球各地的多个服务器上，反向代理会将客户端发送到地理位置上最接近它们的服务器。这样可以减少请求和响应传播的距离，从而最大程度地减少加载时间。</p>
</li>
<li class="lvl-2">
<p><strong>缓存</strong> - 反向代理还可以<a href="https://www.cloudflare.com/learning/cdn/what-is-caching/">缓存</a>内容，从而提高速度。例如，如果巴黎的用户访问使用反向代理而 Web 服务器位于洛杉矶的网站，则该用户实际上可能连接到巴黎本地的反向代理服务器，然后该本地反向代理服务器必须与洛杉矶的源服务器进行通信。之后，代理服务器可以缓存（或临时保存）响应数据。随后浏览该站点的巴黎用户将从巴黎反向代理服务器处获取本地缓存的响应，从而享受到更快的性能。</p>
</li>
<li class="lvl-2">
<p><strong>SSL 加密</strong> - <a href="https://www.cloudflare.com/learning/ssl/what-is-encryption/">加密</a>和解密每个客户端的 <a href="https://www.cloudflare.com/learning/security/glossary/what-is-ssl/">SSL</a>（或 <a href="https://www.cloudflare.com/learning/security/glossary/transport-layer-security-tls/">TLS</a>）通信对于源服务器可能需要耗费大量计算资源。可以配置由反向代理解密所有传入请求并加密所有传出响应，腾出源服务器上的宝贵资源。</p>
</li>
</ul>
<h3 id="如何实施反向代理">如何实施反向代理</h3>
<p>一些公司构建自己的反向代理，但这需要大量的软件和硬件工程资源，以及对硬件的大量投资。享受反向代理的所有好处的最简单、最具成本效益的方法之一就是注册 CDN 服务。例如，<a href="https://www.cloudflare.com/cdn/">Cloudflare CDN</a> 提供上面列出的所有性能和安全功能，以及许多其他功能。</p>
<h2 id="内网穿透">内网穿透</h2>
<h3 id="1-什么是内网穿透">1. 什么是内网穿透?</h3>
<p>在了解内网穿透原理之前，我们先说什么是内网穿透。内网，就是在公司或者家庭内部，建立的局域网络或者是办公网络，可以实现多台电脑之间的资源共享，包括设备、资料、数据等。而外网则是通过一个网关与其它的网络系统连接，相对于内网而言，这种网络系统称之为外部网络，常见的就是我们日常使用的互联网。</p>
<p>一般而言，在没有固定公网IP的情况下，外网设备无法直接访问内网设备。而内网穿透技术，顾名思义就是能让外网的设备找到处于内网的设备，从而实现数据通信。</p>
<h3 id="2-内网穿透的原理">2. 内网穿透的原理</h3>
<p>内网穿透，又称为NAT穿透。NAT背后的设备，它们的主要特点是 ，可以访问外网，但不能被外网设备有效访问。基于这一特点，NAT穿透技术是让NAT背后的设备，先访问指定的外网服务器，由指定的外网服务器搭建桥梁，打通内、外网设备的访问通道，实现外网设备访问到内网设备。</p>
<p>该技术除了可以访问隐藏在NAT后的设备，同样可以穿透防火墙。这是因为防火墙一般只拦截了入站没有拦截出站，所以也可以让防火墙内的设备对外提供服务。</p>
<p>由于内网设备并不是与外网设备直接相连，所以在安全性上是毋庸置疑的，内网穿透可以说是安全与效率兼得。 <img src="https://s2.loli.net/2023/05/11/RE1iaN8nV6dDMWg.png" alt="img"></p>
<h3 id="3-如何实现内网穿透">3. 如何实现内网穿透</h3>
<p>我们可以安装<a href="https://hsk.oray.com/">花生壳</a>内网穿透软件，在软件上添加<a href="https://hsk.oray.com/">映射</a>时，配置被访问内网设备的相关信息 ，以及选择用作外网访问该映射的<a href="https://domain.oray.com/">域名</a>。当映射诊断信息提示连接成功时，即可实现内网穿透。</p>
<p>利用花生壳的内网穿透技术，外网的设备通过访问固定域名，连接花生壳服务器所搭建的通道，顺畅地与内网设备进行数据通信。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	什么是反向代理？|代理服务器介绍: <a href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/">https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/</a></p>
<p>[2]	内网穿透原理解析: <a href="https://service.oray.com/question/5571.html">https://service.oray.com/question/5571.html</a></p>
]]></content>
      <categories>
        <category>Web</category>
        <category>概念</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置C++</title>
    <url>/archives/1a24c243.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>使用系统：Ubuntu</p>
<p>使用IDE：Clion（目前用的免费教育许可证：<a href="https://www.jetbrains.com/zh-cn/community/education/#students%EF%BC%89">https://www.jetbrains.com/zh-cn/community/education/#students）</a></p>
</blockquote>
<span id="more"></span>
<h2 id="环境配置">环境配置</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 终端安装</span><br><span class="line">apt-get install gcc</span><br><span class="line">apt-get install g++</span><br><span class="line">或指定版本：8</span><br><span class="line">sudo apt-get install gcc-8</span><br><span class="line">sudo apt-get install g++-8</span><br><span class="line"># 查看版本</span><br><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line"># 查看该命令的所有操作</span><br><span class="line">g++ --h</span><br><span class="line">gcc --h</span><br></pre></td></tr></table></figure>
<h2 id="终端运行示例">终端运行示例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+T 打开终端</span><br><span class="line">mkdir ~/Projects/cppdemo &amp;&amp; cd ~/Projects/cppdemo # 创建项目目录cppdemo</span><br><span class="line">vi hello.cpp # vi打开文件hello.cp</span><br></pre></td></tr></table></figure>
<p>输入代码（<code>vi</code>操作）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>g++</code>编辑器编译，生成可执行文件 hello，<code>-o</code> 后面的hello是生成的存储输出内容的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>执行可执行文件（即打开hello）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure>
<h2 id="vim常用命令">vim常用命令</h2>
<p><strong>Vim(Vi IMproved)</strong> 是一种功能强大的文本编辑器，常用于Unix和Linux系统中。下面是一些常见的 Vim 操作：</p>
<ol>
<li class="lvl-3">
<p>打开文件：</p>
<ul class="lvl-2">
<li class="lvl-5">在终端中输入<code>vim</code>命令，后跟文件路径和名称，例如：<code>vim myfile.txt</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p>模式切换：</p>
<ul class="lvl-2">
<li class="lvl-5">按下<code>i</code>进入插入模式，可以输入和编辑文本。</li>
<li class="lvl-5">按下<code>Esc</code>键回到普通模式，可以执行命令。</li>
</ul>
</li>
<li class="lvl-3">
<p>保存和退出：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>:w</code>保存文件。</li>
<li class="lvl-5">输入<code>:q</code>退出 Vim。</li>
<li class="lvl-5">输入<code>:wq</code>保存并退出。</li>
</ul>
</li>
<li class="lvl-3">
<p>导航和编辑文本：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，使用箭头键或<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>进行光标导航。</li>
<li class="lvl-5">使用<code>x</code>删除当前光标所在位置的字符。</li>
<li class="lvl-5">使用<code>dd</code>删除当前行。</li>
<li class="lvl-5">使用<code>yy</code>复制当前行。</li>
<li class="lvl-5">使用<code>p</code>粘贴剪贴板中的内容。</li>
</ul>
</li>
<li class="lvl-3">
<p>撤销和重做：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>u</code>撤销最近的操作。</li>
<li class="lvl-5">输入<code>Ctrl + r</code>重做撤销的操作。</li>
</ul>
</li>
<li class="lvl-3">
<p>查找和替换：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>/</code>，后跟要查找的内容，按下回车键开始查找。</li>
<li class="lvl-5">输入<code>n</code>查找下一个匹配项。</li>
<li class="lvl-5">输入<code>:%s/old/new/g</code>全局替换文档中的所有匹配项。</li>
</ul>
</li>
</ol>
<h2 id="Reference">Reference</h2>
<p>[1]	Linux下的C/C++编译环境配置: <a href="https://blog.csdn.net/qq_27607539/article/details/73721946">https://blog.csdn.net/qq_27607539/article/details/73721946</a></p>
<p>[2]	如何在Ubuntu终端运行C++程序: <a href="https://blog.csdn.net/W1995S/article/details/117876875">https://blog.csdn.net/W1995S/article/details/117876875</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Vim</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware安装配置Ubuntu</title>
    <url>/archives/4da17f55.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="开启虚拟化">开启虚拟化</h2>
<p><strong>进入BIOS模式</strong>：联想拯救者：重启出现图标时按 <strong><u>Fn+F2</u></strong></p>
<ol>
<li class="lvl-3">
<p>选择 Configuration，再选择 Intel Virtualization Technology，此时该选项应该是 Disabled（关闭）；</p>
</li>
<li class="lvl-3">
<p>将 Disabled（关闭）改为 Enabled（开启）；</p>
</li>
</ol>
<span id="more"></span>  　　　　
<ol start="3">
<li class="lvl-3">
<p>点击Fn+F10，保存后退出，重启即可。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504172953354.png" alt=""></p>
<h2 id="安装ubuntu">安装ubuntu</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>参考 <mark>软件管家</mark> 公众号，或点击：<a href="https://mp.weixin.qq.com/s/OWUfIJ9Iwd-nwYhbTWXjuA">https://mp.weixin.qq.com/s/OWUfIJ9Iwd-nwYhbTWXjuA</a></p>
</li>
<li class="lvl-2">
<p><strong>硬盘、内存</strong>等参数可根据电脑配置修改</p>
</li>
</ul>
<h2 id="禁止更新">禁止更新</h2>
<ol>
<li class="lvl-3">
<p>系统设置–&gt;软件和更新–&gt;更新</p>
</li>
</ol>
<p>将“自动检查更新”和“有新版本时通知我”设置为“从不“，关闭对话框完成设置。</p>
<p><img src="https://s2.loli.net/2023/05/11/WqTUCsxc2kt7vRa.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>修改配置文件</p>
</li>
</ol>
<p>修改配置文件<code>/etc/apt/apt.conf.d/10periodic</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxx:~$cat /etc/apt/apt.conf.d/10periodic</span><br><span class="line">APT : :Periodic: : Update-Package-Lists &quot;1&quot;;</span><br><span class="line">APT : :Periodic: : Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line">APT : :Periodic: :AutocleanInterval &quot;0&quot;;</span><br><span class="line">APT : :Periodic: :Unattended-Upgrade &quot;0&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>linux系统下修改只读【read-only】文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod a+w /etc/apt/apt.conf.d/10periodic</span><br></pre></td></tr></table></figure>
<h2 id="输入法">输入法</h2>
<ol>
<li class="lvl-3">
<p>安装<code>fcitx</code>输入法框架</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx  # 安装fcitx输入法框架</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>配置<code>Fcitx</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">im-config  # 终端运行命令</span><br></pre></td></tr></table></figure>
<p>在弹出窗口选择<code>fcitx</code>，确认关闭窗口，并重启电脑让配置生效</p>
<p><img src="https://s2.loli.net/2023/05/11/iJMhA9I6Ny3zQXl.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>安装谷歌输入法</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx-googlepinyin -y # 安装谷歌输入法</span><br><span class="line">fcitx-config-gtk3   # 配置谷歌输入法</span><br></pre></td></tr></table></figure>
<p>在弹出对话框中取消勾选 “仅显示当前语言”，然后搜索选中“google”，点击确认。</p>
<p><img src="https://s2.loli.net/2023/05/11/jwv1inJr9ldCU4N.png" alt=""></p>
<p>点击桌面右上角，打开<code>configure</code>可以修改快捷键</p>
<p><img src="https://s2.loli.net/2023/05/11/AucRjCPOnmzFS8v.png" alt=""></p>
<p><strong>解决Jetbarins Clion Ubuntu Fcitx 中文输入法光标跟随问题</strong></p>
<ol>
<li class="lvl-3">
<p>下载根据补丁修复过的<code>jre</code>：<a href="https://github.com/RikudouPatrickstar/JetBrainsRuntime-for-Linux-x64/">https://github.com/RikudouPatrickstar/JetBrainsRuntime-for-Linux-x64/</a></p>
</li>
<li class="lvl-3">
<p>替换Clion的<code>jre</code></p>
<ul class="lvl-2">
<li class="lvl-5">选择特定<strong>路径</strong>解压</li>
<li class="lvl-5">Ctrl+shift+A，搜索: <code>Choose Boot Java Runtime for the IDE的Action</code>，并点击进入</li>
<li class="lvl-5">选择 <strong>New</strong> --&gt; <strong>Add Custom Runtime…</strong></li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/25oLvcydS8Jz1VW.png" alt="image-20230511201625729"></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Add JDK…</strong></p>
</li>
<li class="lvl-5">
<p>选择你解压的 <strong>路径</strong> ，点击OK，重启即可</p>
</li>
</ul>
</li>
</ol>
<h2 id="必备软件">必备软件</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Vim、Firefox（浏览器）、Variety（桌面壁纸）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/HsgGFj1eu3I6LmM.png" alt=""></p>
<h2 id="设置代理">设置代理</h2>
<ol>
<li class="lvl-3">
<p>安装clash for windows</p>
</li>
</ol>
<p>下载链接：<a href="https://github.com/Fndroid/clash_for_windows_pkg">https://github.com/Fndroid/clash_for_windows_pkg</a></p>
<p>选择<code>linux</code>版本的压缩包</p>
<p><img src="https://s2.loli.net/2023/05/11/p3aCmfMAWLU9Hni.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>运行clash</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd download #切换到下载目录</span><br><span class="line">sudo tar -zx Clash.for.Windows-0.17.1-x64-linux.tar.gz -C /opt #解压</span><br><span class="line">cd /opt</span><br><span class="line">sudo mv &#x27;Clash for Windows-0.17.1-x64-linux&#x27; clash  # 重命名</span><br><span class="line">cd clash</span><br><span class="line">./cfw  # run</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>配置clash</p>
</li>
</ol>
<p>clash导入订阅链接–&gt;开启代理（建议打开开机自启）</p>
<p><img src="https://s2.loli.net/2023/05/11/1QnjTCq4LlwOeyx.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>设置代理</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>终端添加环境变量</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 666 /etc/environment</span><br><span class="line">vi /etc/environment</span><br><span class="line"># 填入内容</span><br><span class="line">http_proxy=http://127.0.0.1:7890/</span><br><span class="line">https_proxy=http://127.0.0.1:7890/</span><br><span class="line">ftp_proxy=http://127.0.0.1:7890/</span><br><span class="line">HTTP_PROXY=http://127.0.0.1:7890/</span><br><span class="line">HTTPS_PROXY=http://127.0.0.1:7890/</span><br><span class="line">FTP_PROXY=http://127.0.0.1:7890/</span><br><span class="line"># 恢复原始状态</span><br><span class="line">sudo chmod 444 /etc/environment</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>或者：设置–&gt;网络–&gt;手动设置代理</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/XNFpfvIk95E3ire.png" alt=""></p>
<h2 id="克隆">克隆</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>右键点击虚拟机–&gt;管理–&gt;克隆</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/KDLpXHFaYlCncSm.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改克隆文件名</p>
</li>
</ul>
<p>修改如下克隆配置文件名字</p>
<p><img src="https://s2.loli.net/2023/05/11/rJDClkcfet8vRVZ.png" alt=""></p>
<p>打开<code>.vmx</code>文件，修改相应的值即可</p>
<p><img src="https://s2.loli.net/2023/05/11/WMFa1jY7kQ3dVue.png" alt=""></p>
<h2 id="优化">优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改导航栏位置</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/n8hEAt1fxYr2veP.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	ubuntu 禁止/取消系统自动更新的方法: <a href="https://blog.csdn.net/dacming/article/details/125164420">https://blog.csdn.net/dacming/article/details/125164420</a></p>
<p>[2] 	linux系统下修改只读【read-only】文件: <a href="https://blog.csdn.net/weixin_45677951/article/details/108746753">https://blog.csdn.net/weixin_45677951/article/details/108746753</a></p>
<p>[3]	ubuntu20.04 LTS安装谷歌拼音输入法: <a href="https://blog.csdn.net/kan2016/article/details/105735645">https://blog.csdn.net/kan2016/article/details/105735645</a></p>
<p>[4]	linux下使用clash(GUI): <a href="https://www.jianshu.com/p/02e3e8ccfe80">https://www.jianshu.com/p/02e3e8ccfe80</a></p>
<p>[5]	ubuntu启动栏导航栏放置到桌面底部、左侧: <a href="https://blog.csdn.net/lzp_k2/article/details/100089800">https://blog.csdn.net/lzp_k2/article/details/100089800</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter安装配置</title>
    <url>/archives/72216da9.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="安装">安装</h2>
<ol>
<li class="lvl-3">
<p><strong>conda安装</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Prompt</code>，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install jupyter notebook</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol start="2">
<li class="lvl-3">
<p><strong>navigator安装</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Navigator</code>，点击<code>Jupyter</code>下的 <code>Insatll</code></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509223656406.png" alt=""></p>
<h2 id="修改默认打开路径">修改默认打开路径</h2>
<ol>
<li class="lvl-3">
<p><strong>生成配置文件</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Prompt</code>，输入<code>jupyter notebook --generate-config</code></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/a6b56b88c868a12438d03169baed880.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p><strong>修改配置文件</strong></p>
<p>根据显示的路径，打开配置文件<code>jupyter_notebook_config.py</code>，全文搜索 <code>notebook_dir</code>，找到后填入自己的工作路径并保存。（注意：工作路径不能出现中文，否则无法打开<code>Jupyter Notebook</code>）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509223042167.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p><strong>修改JupyterNotebook快捷方式的目标属性</strong></p>
</li>
</ol>
<p>右击<code>JupyterNotebook</code>快捷方式，选择【属性】，删除【目标】属性中的【%USERPROFILE%】，点击【应用】–【确定】</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/7e5c619809d4324a7bfd40810834af3.png" alt=""></p>
<h2 id="优化">优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>主题切换</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># install jupyterthemes</span><br><span class="line">conda install -c conda-forge jupyterthemes</span><br><span class="line"># update to latest version</span><br><span class="line">conda update jupyterthemes</span><br><span class="line"></span><br><span class="line">jt -l # 加载可用主题列表</span><br><span class="line"># selecting a particular theme</span><br><span class="line">jt -t &lt;name of the theme&gt;</span><br><span class="line"># reverting to original Theme</span><br><span class="line">jt -r</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509225426973.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>插件安装</strong></p>
</li>
</ul>
<p>打开<code>Anaconda Prompt</code>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure>
<p>安装完点击<code>extensions</code>，勾选相应的功能即可</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509230915195.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	jupyter-contrib-nbextensions: <a href="https://pypi.org/project/jupyter-contrib-nbextensions/">https://pypi.org/project/jupyter-contrib-nbextensions/</a></p>
<p>[2]	jupyter-themes: <a href="https://github.com/dunovank/jupyter-themes">https://github.com/dunovank/jupyter-themes</a></p>
<p>[3]	Installing Jupyter: <a href="https://jupyter.org/install">https://jupyter.org/install</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>You-Get下载视频</title>
    <url>/archives/96ba4918.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><code>You-Get</code>是一款功能强大的开源命令行工具，可支持从多种网站下载视频、音频等媒体内容，包括流行的YouTube、Bilibili、优酷、爱奇艺等平台。不仅如此，它还能够下载各种在线流媒体、HLS、DASH、M3U8等格式的视频和音频。该工具简单易用，支持多种操作系统，如Windows、macOS和Linux等平台。使用者只需在终端输入指令，即可轻松将感兴趣的媒体下载到本地。<code>You-Get</code>还支持批量下载、断点续传等实用功能，非常适合在需要下载大量媒体内容的情况下使用。</p>
</blockquote>
<span id="more"></span>
<h2 id="配置">配置</h2>
<p><strong>安装 you-get</strong>（<em>装有python环境</em>：参考<a href="https://liuaoao.top/archives/eabeff19.html">Anaconda-Python环境安装</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install you-get  </span><br></pre></td></tr></table></figure>
<p><strong>安装 ffmpeg</strong>（合并音画必须）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>python: <code>pip install ffmpeg</code></p>
</li>
<li class="lvl-2">
<p>或者官网下载：<a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></p>
<ul class="lvl-2">
<li class="lvl-4">将<code>ffmpeg.exe</code>的上一层路径 <code>xxx\bin</code>填入环境变量（用户+系统的Path，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</li>
</ul>
</li>
<li class="lvl-2">
<p>检验是否安装成功<code>ffmpeg -version</code></p>
</li>
</ul>
<h2 id="下载命令">下载命令</h2>
<p><strong>视频信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get -i URL #提示如何下载不同比例不同格式文件</span><br><span class="line">- format:        dash-flv</span><br><span class="line">  container:     mp4</span><br><span class="line">  quality:       高清 1080P</span><br><span class="line">  size:          222.8 MiB (233636151 bytes)</span><br><span class="line"># download-with: you-get --format=dash-flv [URL]</span><br></pre></td></tr></table></figure>
<p><strong>单个视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get [URL]              #通过网址下载文件</span><br><span class="line">you-get -o 本地路径  [URL]   #更改本地下载目录，默认下载位置为当前powershell打开目录</span><br><span class="line">cd C:\                         #更改powershell目录</span><br></pre></td></tr></table></figure>
<p><strong>批量下载</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>playlist</code>可以使其按列表下载（批量下载的关键）</p>
</li>
<li class="lvl-2">
<p><code>format=dash-flv720</code>指定下载720P的flv视频</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看批量视频信息</span><br><span class="line">you-get --playlist -i https://www.bilibili.com/video/BV13t411G7oh</span><br><span class="line"># 下载</span><br><span class="line">you-get --playlist --format=dash-flv720 -o D:\SX https://www.bilibili.com/video/BV13t411G7oh</span><br></pre></td></tr></table></figure>
<h2 id="使用技巧">使用技巧</h2>
<ol>
<li class="lvl-3">
<p>使用代理加速（参考：<a href="https://liuaoao.top/archives/7b6d4a85.html">Windows代理设置</a>）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一次性关闭命令行需重新设置</span><br><span class="line">set http_proxy=http://127.0.0.1:1080</span><br><span class="line">set https_proxy=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>cookies请求</p>
</li>
</ol>
<p>一些视频可能需要会员才能下载，此时我们需要带cookies请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get --cookies=C:\Users\91425\Desktop\cookies.txt --format=dash-flv -o D:\SX https://www.bilibili.com/video/BV19h411s7oq </span><br><span class="line"># --cookies=C:\Users\91425\Desktop\cookies.txt 部分就是指定cookies的部分</span><br></pre></td></tr></table></figure>
<p><code>you-get</code>支持<code>Mozilla cookies.sqlite</code>和<code>Netscape</code>两种格式的<code>cookies</code>。前者可以使用火狐浏览器直接导出。后者在<code>Chromium</code>内核的浏览器上可以使用<code>Get cookies.txt</code>插件获取。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	记录一个you-get批量下载B站视频的方法: <a href="https://zhuanlan.zhihu.com/p/442019718">https://zhuanlan.zhihu.com/p/442019718</a></p>
<p>[2]	You-get在Windows系统下的安装+会员视频下载的cookie配置: <a href="https://blog.csdn.net/cwj1412/article/details/107775004">https://blog.csdn.net/cwj1412/article/details/107775004</a></p>
<p>[3]	you-get不自动合并音频和视频的解决办法: <a href="https://zhuanlan.zhihu.com/p/386392241">https://zhuanlan.zhihu.com/p/386392241</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-axis</title>
    <url>/archives/e3a284ef.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>在Python中，<code>axis</code>参数在许多库如NumPy、Pandas中是一个重要概念，它表示数据沿着哪个轴或维度进行操作。</p>
</blockquote>
<h2 id="NumPy">NumPy</h2>
<h3 id="np-array">np.array()</h3>
<p>对于一个二维数组（矩阵），<code>axis=0</code>表示操作沿着行（垂直方向），<code>axis=1</code>表示操作沿着列（水平方向）</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 3x3 的数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着 axis=0（行方向）求和</span></span><br><span class="line">sum_axis0 = np.<span class="built_in">sum</span>(arr, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 输出: array([12, 15, 18])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着 axis=1（列方向）求和</span></span><br><span class="line">sum_axis1 = np.<span class="built_in">sum</span>(arr, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输出: array([ 6, 15, 24])</span></span><br></pre></td></tr></table></figure>
<h3 id="np-concatenate-a1-a2-axis-0">np.concatenate(a1,a2 axis=0)</h3>
<p><code>np.concatenate</code>主要用于在指定轴上对多个数组进行拼接，拼接的轴的长度必须相同，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]) </span><br><span class="line"></span><br><span class="line">c = np.concatenate((a, b), axis=<span class="number">0</span>)</span><br><span class="line">d = np.concatenate((a, b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#[[1 2]</span></span><br><span class="line"><span class="comment"># [3 4]</span></span><br><span class="line"><span class="comment"># [5 6]</span></span><br><span class="line"><span class="comment"># [7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2 5 6]</span></span><br><span class="line"><span class="comment"># [3 4 7 8]]</span></span><br></pre></td></tr></table></figure>
<h3 id="np-append-arr-values-axis-None">np.append(arr, values, axis=None)</h3>
<p><code>np.append</code>是在数组的末尾添加元素，其使用方法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.append(arr, values, axis=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中，arr为原数组，values为需要添加的值，axis为需要添加的轴（如果不指定axis，则会将数组先展开成1D数组，再进行添加）。如果添加的值是一个数组，则会将数组在指定的轴上与原数组进行拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">c = np.append(a, b)  <span class="comment"># 在1D数组上进行拼接</span></span><br><span class="line">d = np.append(a, b, axis=<span class="number">0</span>)  <span class="comment"># 在行上进行拼接</span></span><br><span class="line">e = np.append(a, b, axis=<span class="number">1</span>)  <span class="comment"># 在列上进行拼接</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment">#[1 2 3 4 5 6 7 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2]</span></span><br><span class="line"><span class="comment"># [3 4]</span></span><br><span class="line"><span class="comment"># [5 6]</span></span><br><span class="line"><span class="comment"># [7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2 5 6]</span></span><br><span class="line"><span class="comment"># [3 4 7 8]]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>np.append</code>返回的是新的数组，不会改变原数组。在原始数据集比较大时，推荐使用<code>np.concatenate()</code>函数进行数组拼接。</p>
<h3 id="np-stack-array-axis-0">np.stack(array, axis=0)</h3>
<p>沿着新轴连接数组的序列，<mark>此方法与拼接不同</mark>。</p>
<p><em>axis</em> 参数指定新轴在结果尺寸中的索引。例如，如果<code>axis=0</code>，它将是第一个维度，如果<code>axis=-1</code>，它将是最后一个维度。</p>
<h4 id="一维数组">一维数组</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个一维数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴0方向连接这两个数组</span></span><br><span class="line">c = np.stack((a, b), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(c.shape)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (2,3)</span></span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴1方向连接这两个数组</span></span><br><span class="line">d = np.stack((a, b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(d.shape)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (3,2)</span></span><br><span class="line"><span class="comment"># [[1 4]</span></span><br><span class="line"><span class="comment">#  [2 5]</span></span><br><span class="line"><span class="comment">#  [3 6]]</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2"></label><code>(2,3)</code>和<code>(3,2)</code>中的<code>2</code>是怎么来的：因为有<code>a</code>和<code>b</code>两个<code>array</code>。</p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">可以理解</label><code>axis</code>指定了要增加的维度：例如<code>axis=0</code>表示在第一维度上增加，因此<code>(2,3)</code>中的<code>2</code>位于第一维度。而<code>axis=1</code>表示在第二维度上增加，因此<code>(3,2)</code>中的<code>2</code>位于第二维度。</p>
</li>
</ul>
<h4 id="二维数组">二维数组</h4>
<p>两个要素：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>stack堆叠的 <strong>方向</strong></p>
</li>
<li class="lvl-2">
<p>stack堆叠后增加的 <strong>维度</strong></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个2行3列的二维数组</span></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个2行3列的二维数组</span></span><br><span class="line">arr2 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴0方向连接这两个数组</span></span><br><span class="line">arr3 = np.stack((arr1, arr2), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr3 shape:<span class="subst">&#123;arr3.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># Arr3 shape:(2, 2, 3)</span></span><br><span class="line"><span class="comment"># [[[ 1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 4  5  6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 7  8  9]</span></span><br><span class="line"><span class="comment">#   [10 11 12]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴1方向连接这两个数组</span></span><br><span class="line">arr4 = np.stack((arr1, arr2), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr4 shape:<span class="subst">&#123;arr4.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr4)</span><br><span class="line"><span class="comment"># Arr4 shape:(2, 2, 3)</span></span><br><span class="line"><span class="comment"># [[[ 1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 7  8  9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 4  5  6]</span></span><br><span class="line"><span class="comment">#   [10 11 12]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴2方向连接这两个数组</span></span><br><span class="line">arr5 = np.stack((arr1, arr2), axis=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr5 shape:<span class="subst">&#123;arr5.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr5)</span><br><span class="line"><span class="comment"># Arr5 shape:(2, 3, 2)</span></span><br><span class="line"><span class="comment"># [[[ 1  7]</span></span><br><span class="line"><span class="comment">#   [ 2  8]</span></span><br><span class="line"><span class="comment">#   [ 3  9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 4 10]</span></span><br><span class="line"><span class="comment">#   [ 5 11]</span></span><br><span class="line"><span class="comment">#   [ 6 12]]]</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>2</code>就是指的<code>a</code>和<code>b</code>，而<code>2</code>放在什么位置是根据<code>axis</code>来确定的</p>
<h2 id="Pandas">Pandas</h2>
<p>在Pandas中，<code>axis</code>参数用于在<code>DataFrame</code>（类似于二维表格的数据结构）上执行操作，如汇总、排序和删除列或行等。与<code>NumPy</code>类似，<code>axis=0</code>表示操作沿着行（垂直方向），<code>axis=1</code>表示操作沿着列（水平方向）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="string">&#x27;C&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    A  B  C</span></span><br><span class="line"><span class="comment"># 0  1  4  7</span></span><br><span class="line"><span class="comment"># 1  2  5  8</span></span><br><span class="line"><span class="comment"># 2  3  6  9</span></span><br><span class="line"><span class="comment"># 删除名为 &#x27;A&#x27; 的列，沿着 axis=1（列方向）</span></span><br><span class="line">df = df.drop(<span class="string">&#x27;A&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    B  C</span></span><br><span class="line"><span class="comment"># 0  4  7</span></span><br><span class="line"><span class="comment"># 1  5  8</span></span><br><span class="line"><span class="comment"># 2  6  9</span></span><br><span class="line"><span class="comment"># 计算每一行的和，沿着 axis=1（列方向）</span></span><br><span class="line">row_sum = df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(row_sum)</span><br><span class="line"><span class="comment"># 0    11</span></span><br><span class="line"><span class="comment"># 1    13</span></span><br><span class="line"><span class="comment"># 2    15</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	numpy.stack最通俗的理解: <a href="https://blog.csdn.net/qq_17550379/article/details/78934529">https://blog.csdn.net/qq_17550379/article/details/78934529</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/archives/e8e79e61.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><code>C++</code>并发编程是指在<code>C++</code>程序中使用多线程和同步机制来实现并发执行的功能。并发编程可以提高程序的性能和响应速度，同时也可以简化程序的设计和实现。</p>
<p>在<code>C++</code>中，可以使用多个线程来并发执行不同的任务。为了避免竞态条件和数据不一致等问题，需要使用同步机制来协调多个线程之间的操作。常用的同步机制包括互斥锁、条件变量、原子操作等。</p>
</blockquote>
<h2 id="hello-world开始">hello world开始</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>join()</mark> 函数：阻塞当前线程，直到关联的线程执行完毕。</p>
</li>
<li class="lvl-2">
<p><mark>detach()</mark> 函数：让一个线程在后台独立运行，不受主线程的控制，从而允许主线程提前退出而不必等待后台线程完成。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();       <span class="comment">// must add this line otherwise will failed!</span></span><br><span class="line">    <span class="comment">// 需要注意的是线程对象执行了join后就不再joinable了，所以只能调用join一次。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="Basic">Basic</h2>
<h3 id="悬空引用">悬空引用</h3>
<p>当 <strong>i</strong> 的生命周期结束时，<strong>func</strong> 对象中的引用 <strong>i</strong> 就变成了悬空引用，其指向的内存可能被其他程序占用或被释放，从而导致不可预测的错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="type">int</span> &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp;i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">do_something</span>(i);           <span class="comment">// 1. 潜在访问隐患：悬空引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="简洁机制">简洁机制</h4>
<p>保线程在函数结束之前安全退出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特殊情况下的等待</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//        do_something_in_current_thread();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try catch 只能捕获轻量级错误,所以如需确保线程在函数之前结束——查看是否因为线程函数使用了局部变量的引用，</span></span><br><span class="line"><span class="comment">// 以及其他原因——而后再确定一下程序可能会退出的途径，无论正常与否，可以提供一个简洁的机制，来做解决这个问题。</span></span><br></pre></td></tr></table></figure>
<h4 id="RAII">RAII</h4>
<p>一种方式是使用“资源获取即初始化方式 <strong>(RAII，Resource Acquisition Is Initialization)</strong>，并且提供一个类，在析构函数中使用join()，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::thread支持移动的好处是可以创建thread_guard类的实例，并且拥有其线程的所有权。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span> &#123;</span><br><span class="line">    std::thread &amp;t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread &amp;t_)</span> :</span></span><br><span class="line"><span class="function">            t(t_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">thread_guard</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) <span class="comment">// 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();      <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;   <span class="comment">// 3</span></span><br><span class="line">    thread_guard &amp;<span class="keyword">operator</span>=(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line"><span class="comment">//    do_something_in_current_thread();</span></span><br><span class="line">&#125;    <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 线程所关联的局部对象（即 my_func 的参数）的生命周期将在 thread_guard 对象之后结束，而不是在线程结束之后。当线程执行到4处时，局部对象就要被逆序销毁了。因此，thread_guard对象g是第一个被销毁的，</span></span><br><span class="line"><span class="comment">// 这时线程在析构函数中被加入2到原始线程中。</span></span><br><span class="line"><span class="comment">// 即使do_something_in_current_thread抛出一个异常，这个销毁依旧会发生。</span></span><br></pre></td></tr></table></figure>
<p>由于线程的管理得到了线程保护对象的管理，线程在程序结束时一定会被正确的处理，并且不会产生悬空的线程引用，保证了线程的安全退出.</p>
<h3 id="Most-Vexing-Parse">Most Vexing Parse</h3>
<p><strong>Most Vexing Parse</strong>：声明的对象被解析为一个函数声明而不是对象定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function">thread <span class="title">my_thread1</span><span class="params">(background_task())</span></span></span><br></pre></td></tr></table></figure>
<p>解决如下：</p>
<ol>
<li class="lvl-3">
<p>使用多组括号：这种方法可以告诉编译器我们正在声明一个对象，而不是一个函数。</p>
</li>
<li class="lvl-3">
<p>使用新的初始化语法：C<ins>11引入了C</ins>的新初始化语法，即使用花括号{}来初始化对象。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">thread <span class="title">my_thread1</span><span class="params">((background_task()))</span></span>; <span class="comment">// 使用多组括号</span></span><br><span class="line">my_thread1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">thread my_thread2&#123;<span class="built_in">background_task</span>()&#125;;   <span class="comment">// 使用新的初始化语法</span></span><br><span class="line">my_thread2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<h2 id="transfer">transfer</h2>
<p>这段代码演示了如何使用<code>std::thread</code>来创建新线程，并将类成员函数作为线程函数传递，同时也演示了如何使用<code>std::unique_ptr</code>来管理资源，并将这个资源传递给一个新线程。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>std::move(p)</code>: 左值转化为右值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_length_work</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_big_object</span><span class="params">(std::unique_ptr&lt;X&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X my_x;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(&amp;X::do_length_work, &amp;my_x)</span></span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;X&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> X)</span></span>;</span><br><span class="line">    p-&gt;<span class="built_in">do_length_work</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">tt</span><span class="params">(process_big_object,std::move(p))</span></span>;</span><br><span class="line">    <span class="comment">//std::thread实例的可移动且不可复制性。不可复制保性证了在同一时间点，</span></span><br><span class="line">    <span class="comment">// 一个std::thread实例只能关联一个执行线程；可移动性使得程序员可以自己决定，哪个实例拥有实际执行线程的所有权。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ownership">ownership</h2>
<h3 id="线程的创建、移动和管理">线程的创建、移动和管理</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; <span class="comment">// 构造一个thread对象t1</span></span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1); <span class="comment">// 把t1 move给另外一个thread对象t2，t1不再管理之前的线程了。</span></span><br><span class="line"><span class="comment">// 这句不需要std::move()，从临时变量进行移动是自动和隐式的。调用的是operator=(std::thread&amp;&amp;)</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function);</span><br><span class="line">std::thread t3;</span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2); <span class="comment">// 把t2 move给t3</span></span><br><span class="line"><span class="comment">// 把t3 move给t1，非法。因为`t1`已经有了一个相关的线程，会调用`std::terminate()`来终止程序。</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3);</span><br></pre></td></tr></table></figure>
<h3 id="一组线程">一组线程</h3>
<p>这段代码使用了<code>std::vector</code>和<code>std::thread</code>，它展示了如何使用C++11标准库来创建一组线程并等待它们完成工作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(<span class="type">unsigned</span> id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(do_work, i)); <span class="comment">// 产生线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(),</span><br><span class="line">                  std::<span class="built_in">mem_fn</span>(&amp;std::thread::join)); <span class="comment">// 对每个线程调用join()</span></span><br><span class="line">    <span class="comment">// &amp;std::thread::join获取的是std::thread::join成员函数的地址，将地址传递给std::mem_fn进行包装，从而将这个函数变成一个可调用对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RAII类scoped-thread">RAII类<code>scoped_thread</code></h3>
<p>这是一个RAII类<code>scoped_thread</code>的定义，它使用C++11标准库中的<code>std::thread</code>类来封装线程对象。具体来说，<code>scoped_thread</code>类通过重载构造函数和析构函数来控制线程的生命周期，从而确保线程在适当的时候被销毁。</p>
<p>在这个类的定义中，几个关键的实现细节：</p>
<ol>
<li class="lvl-3">
<p>使用<code>explicit</code>防止隐式类型转换。</p>
</li>
<li class="lvl-3">
<p>使用<code>std::logic_error</code>来抛出异常，以表示线程没有被启动的错误情况。</p>
</li>
<li class="lvl-3">
<p>在析构函数中调用<code>join()</code>函数，以确保线程在<code>scoped_thread</code>对象被销毁时能够正常结束。</p>
</li>
</ol>
<p>除此之外，由于线程对象的复制和复制赋值操作不可重载，因此需要通过<code>delete</code>关键字来禁止这些操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line">    std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span> :                 // <span class="number">1</span></span></span><br><span class="line"><span class="function">            t(std::move(t_)) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!t.<span class="built_in">joinable</span>())                                     <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;No thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">scoped_thread</span>() &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();                                            <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scoped_thread</span>(scoped_thread <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    scoped_thread &amp;<span class="keyword">operator</span>=(scoped_thread <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="runtime">runtime</h2>
<p>简单的线程池：将迭代器范围分割成多个子范围，每个子范围由一个线程进行处理，最后合并所有子范围的累加结果，从而实现了并行的累加操作。</p>
<p>在实现上，函数首先根据范围长度和硬件线程数，计算出要使用的线程数和任务块的大小。然后，函数将序列分块，并为每个块创建一个线程来执行累加操作。最后，使用<code>std::accumulate</code>将所有结果相加以得到最终结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使得每个线程具有最小数目的元素以避免过多的线程开销</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T &amp;result)</span> </span>&#123;</span><br><span class="line">        result = std::<span class="built_in">accumulate</span>(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumlate</span><span class="params">(Iterator first, Iterator last, T init)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">    cout&lt;&lt;max_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    cout&lt;&lt;hardware_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads = std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    cout&lt;&lt;num_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;</span><br><span class="line">    cout&lt;&lt;block_size&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(), block_start, block_end, std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">        <span class="comment">// std::ref用于将一个对象转化为一个引用</span></span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(block_start, last, results[num_threads - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// block_start到last无法划分为一个完整的块时，需要单独对这个子范围执行累加操作</span></span><br><span class="line">    std::for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), std::<span class="built_in">mem_fn</span>(&amp;std::thread::join));</span><br><span class="line">    <span class="comment">// std::mem_fn将一个成员函数指针转换为一个函数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">parallel_accumlate</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="id">id</h2>
<p>代码定义了两个函数<code>do_master_thread_work</code>和<code>do_common_work</code>，分别用于处理主线程和其他线程（即非主线程）的工作。在<code>some_core_part_of_algorithm</code>函数中，代码首先判断当前线程是否为主线程，如果是，则调用<code>do_master_thread_work</code>函数，否则调用<code>do_common_work</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的通用标识符</span></span><br><span class="line">std::thread::id master_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_master_thread_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;master&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_common_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;common&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::this_thread::<span class="built_in">get_id</span>() == master_thread) &#123;</span><br><span class="line">        <span class="built_in">do_master_thread_work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">do_common_work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    master_thread = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;master_thread: &quot;</span> &lt;&lt; master_thread &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;master_thread 中运行:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">some_core_part_of_algorithm</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread 中运行:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(some_core_part_of_algorithm)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 那些事: <a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Pr2020基础总结</title>
    <url>/archives/7eda6880.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><strong>安装</strong>：参考 <mark>软件管家</mark> 公众号(<a href="https://mp.weixin.qq.com/s/TC44SwDnZI2k1XsdCEBoyA">https://mp.weixin.qq.com/s/TC44SwDnZI2k1XsdCEBoyA</a>)，推荐2020及以上版本</p>
<p><u>注意GPU渲染出现预览黑屏，掉帧，导出渲染失败，cpu拉满独显不工作等问题，需更新驱动或Pr版本</u></p>
<ol>
<li class="lvl-3">
<p><strong>更新驱动</strong>为最新版本（参考：<a href="https://liuaoao.top/archives/2888cf0.html">Ps2019总结</a>）</p>
</li>
<li class="lvl-3">
<p>更新驱动未解决，<strong>更新Pr</strong>为2020或更高</p>
</li>
</ol>
</blockquote>
<span id="more"></span>
<h2 id="项目">项目</h2>
<p>新建：Ctrl+Alt+N</p>
<p>打开：Ctrl+O</p>
<h2 id="基本操作">基本操作</h2>
<h3 id="资源管理">资源管理</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">放大资源</td>
</tr>
<tr>
<td style="text-align:center">J、K、L</td>
<td style="text-align:center">前进、暂停、后退</td>
</tr>
<tr>
<td style="text-align:center">I、O</td>
<td style="text-align:center">入点、出点</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">标记</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+M</td>
<td style="text-align:center">删除标记</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+Alt+M</td>
<td style="text-align:center">删除所有标记</td>
</tr>
<tr>
<td style="text-align:center">Shift</td>
<td style="text-align:center">多选</td>
</tr>
<tr>
<td style="text-align:center">Ctrl</td>
<td style="text-align:center">点选</td>
</tr>
</tbody>
</table>
<p>工具栏快捷键: <mark>Alt + 相应字母</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>红色：一般模式</p>
</li>
<li class="lvl-2">
<p>黄色：吸附模式</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">按住Ctrl</td>
<td style="text-align:center">切换边缘编辑模式</td>
</tr>
<tr>
<td style="text-align:center">按住Shfit</td>
<td style="text-align:center">标尺吸附到边缘</td>
</tr>
<tr>
<td style="text-align:center">按住Alt+滑轮</td>
<td style="text-align:center">放大缩小</td>
</tr>
<tr>
<td style="text-align:center">双击边缘</td>
<td style="text-align:center">精确修剪</td>
</tr>
<tr>
<td style="text-align:center">J、K、L</td>
<td style="text-align:center">前进、暂停、后退</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">波纹编辑</td>
</tr>
<tr>
<td style="text-align:center">N</td>
<td style="text-align:center">滚动编辑</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">向前选择轨道</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">移动</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">剃刀</td>
</tr>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">外滑</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">钢笔</td>
</tr>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">手形</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">文字</td>
</tr>
<tr>
<td style="text-align:center">Shfit+剃刀</td>
<td style="text-align:center">整个</td>
</tr>
<tr>
<td style="text-align:center">Shfit+选择轨道</td>
<td style="text-align:center">单个</td>
</tr>
<tr>
<td style="text-align:center">Shift+Delete</td>
<td style="text-align:center">贴合删除</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+K</td>
<td style="text-align:center">截断</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+D</td>
<td style="text-align:center">视频过度</td>
</tr>
<tr>
<td style="text-align:center">Q</td>
<td style="text-align:center">波纹修剪上一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">波纹修剪下一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+Q</td>
<td style="text-align:center">修剪上一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+W</td>
<td style="text-align:center">修剪下一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="音轨">音轨</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>标准 -</strong> 标准音轨替代了旧版本的立体声音轨类型。它可以同时容纳单声道和立体声音频剪辑。</p>
</li>
<li class="lvl-2">
<p><strong>单声道 -</strong> 单声道轨道包含一个音频通道。单声道轨道会复制该通道，以便左声道和右声道播放相同的录音，或仅通过左声道或右声道中的一个通道播放录音。如果立体声剪辑添加到单声道轨道，立体声剪辑声道将由单声道轨道汇总为单声道。</p>
</li>
<li class="lvl-2">
<p><strong>立体声轨道 -</strong> 立体声轨道为双声道音频。立体声轨道是以两个声道（一左一右）录制的音频。</p>
</li>
<li class="lvl-2">
<p><strong>自适应轨道 -</strong> 自适应轨道可以包含单声道、立体声和自适应剪辑。对于自适应音轨，可通过对工作流程效果最佳的方式将源音频映射至输出音频声道。处理可录制多个音轨的摄像机录制的音频时，这种音轨类型非常有用。处理合并后的剪辑或多机位序列时，也可使用自适应音轨。</p>
</li>
<li class="lvl-2">
<p><strong>5.1 -</strong> 包含以下声道：</p>
<ul class="lvl-2">
<li class="lvl-4">三条前置音频声道（左声道、中置声道、右声道）</li>
<li class="lvl-4">两条后置或环绕音频声道（左声道和右声道）</li>
<li class="lvl-4">通向低音炮扬声器的低频效果 (LFE) 音频声道。</li>
</ul>
<p>5.1 音轨只能包含 5.1 剪辑。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Pr</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode安装配置</title>
    <url>/archives/fe901771.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>安装：官网下载即可（<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>），安装时一般 <strong>把path添加到环境变量</strong></p>
<p><u>因为VSCode可以同步设置，重点写一下无法同步的的设置</u></p>
</blockquote>
<h2 id="主题、字体、插件">主题、字体、插件</h2>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504200256615.png" alt=""></p>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504200520492.png" alt=""></p>
<h2 id="配置C-1">配置C++<sup>[1]</sup></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>安装 C++ 插件</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/e1311c50b41c19263e0b72ca0e79cf2.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>安装编译调试环境</strong></p>
</li>
</ul>
<p>Windows 系统 按照下面步骤配置</p>
<ol>
<li class="lvl-3">
<p>下载安装 mingw-w64：<a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a></p>
</li>
<li class="lvl-3">
<p>直接将 mingw-w64 解压到一个合适的目录（例如C:\Program Files下）</p>
</li>
<li class="lvl-3">
<p>添加上****mingw-w64\bin**个文件夹的路径（用户+系统，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/e66b9612b8c5eaba62dae5366029335.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>打开powershell/cmd， 输入 <strong>gcc -v</strong> , 看到版本说明环境变量配置成功</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>配置VS Code调试环境</strong></p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>新建 <strong>CPP\ .vscode</strong> 文件夹</p>
</li>
<li class="lvl-3">
<p>在 .vscode 文件夹中，依次新建文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c_cpp_properties.<span class="property">json</span></span><br><span class="line">launch.<span class="property">json</span></span><br><span class="line">tasks.<span class="property">json</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>复制内容到 json文件</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>launch.json</mark>中：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>“miDebuggerPath”: 后面修改为你的 mingw64 路径</strong></li>
<li class="lvl-4">“preLaunchTask”: “task g++”** 和 <strong>tasks.json</strong> 中的 <strong>“label”: “task g++”</strong> 引号中的名字要一致，本代码中为 <strong>task g++</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// launch.json 配置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line"><span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line"><span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,<span class="comment">//配置类型，只能为cppdbg</span></span><br><span class="line"><span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,<span class="comment">//请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="comment">//调试程序的路径名称</span></span><br><span class="line"><span class="string">&quot;args&quot;</span>: [],<span class="comment">//调试传递参数</span></span><br><span class="line"><span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//true显示外置的控制台窗口，false显示内置终端</span></span><br><span class="line"><span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line"><span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\mingw64\\bin\\gdb.exe&quot;</span>, </span><br><span class="line"><span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line"><span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line"><span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;task g++&quot;</span>,<span class="comment">//调试前执行的任务，就是之前配置的tasks.json中的label字段</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tasks.json 配置文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class="line"><span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line"><span class="string">&quot;label&quot;</span>: <span class="string">&quot;task g++&quot;</span>,<span class="comment">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class="line"><span class="string">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>,</span><br><span class="line"><span class="string">&quot;args&quot;</span>: [<span class="comment">//编译时候的参数</span></span><br><span class="line"><span class="string">&quot;-g&quot;</span>,<span class="comment">//添加gdb调试选项</span></span><br><span class="line"><span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,<span class="comment">//指定生成可执行文件的名称</span></span><br><span class="line"><span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;owner&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line"><span class="string">&quot;fileLocation&quot;</span>: [</span><br><span class="line"><span class="string">&quot;relative&quot;</span>,</span><br><span class="line"><span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;pattern&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;regexp&quot;</span>: <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span>,</span><br><span class="line"><span class="string">&quot;file&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">&quot;column&quot;</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">&quot;severity&quot;</span>: <span class="number">4</span>,</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line"><span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span><span class="comment">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c_cpp_properties.json 配置文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;Win32&quot;</span>,</span><br><span class="line"><span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line"><span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;defines&quot;</span>: [</span><br><span class="line"><span class="string">&quot;_DEBUG&quot;</span>,</span><br><span class="line"><span class="string">&quot;UNICODE&quot;</span>,</span><br><span class="line"><span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;C:/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line"><span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c11&quot;</span>,</span><br><span class="line"><span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-4">
<p>配置完上面，vscode就可以正常调试了</p>
</li>
</ol>
<h2 id="优化配置">优化配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序文件路径不要有 <strong>中文</strong>，否则会导致 <strong>调试失败</strong></p>
</li>
<li class="lvl-2">
<p>Vscode设置保留在单文件夹中，如果要更换文件夹，请把 <strong>.vscode</strong> 文件夹也复制到你要更改的文件夹中</p>
</li>
<li class="lvl-2">
<p>中文显示乱码问题 VScode 编码设置/文件乱码</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">点击文件-&gt;首选项-&gt;设置，然后在右边用户设置输入：<strong>“files.autoGuessEncoding”: true</strong></li>
<li class="lvl-4">插入这一行内用并保存。</li>
<li class="lvl-4">或者如下图打钩：</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/165f67da7eb2ba912d58cd6d6e712fa.png" alt=""></p>
<p>加入这个设置后，VSCode会在打开文件时尝试猜测字符集编码。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>VsCode内部终端运行代码</p>
</li>
</ul>
<p>设置在终端运行 : 首选项 -&gt; 设置 -&gt; 扩展 -&gt; Run Code ，勾选 <strong>Run In Terminal</strong> 和 <strong>Save File Before Run</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/f35d61b71af8ed28acf99d20e644c2e.png" alt=""></p>
<p>后记：投降了，Linux我用Clion，看<a href="https://liuaoao.top/archives/1a24c243.html">Linux配置C++</a></p>
<h2 id="Reference">Reference</h2>
<p>[1]	VSCode配置C++开发环境（MinGW-w64）: <a href="https://juejin.cn/post/7170216201849667621">https://juejin.cn/post/7170216201849667621</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm安装配置</title>
    <url>/archives/c545af56.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>PyCharm专业版是功能最丰富的，与社区版相比，PyCharm 业版增加了Web开发、Python We框架、Python分析器、远程开发、支持数据库与SQL等更多高级功能。</p>
<p>PyCharm的社区版中没有Web开发、Python We框架、Python分析器、远程开发、支持数据库与SQL等这些功能。</p>
<p>PyCharm教育版的功能虽然比专业版会少一些，但与社区版相比，更加支持学校的教学工作。</p>
</blockquote>
<span id="more"></span>
<h2 id="PyCharm专业版安装">PyCharm专业版安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>参考 <mark>软件管家</mark>公众号，或点击：<a href="https://mp.weixin.qq.com/s/V2Ls-lcnymD9_ZullCh_fg">https://mp.weixin.qq.com/s/V2Ls-lcnymD9_ZullCh_fg</a></p>
</li>
</ul>
<h2 id="主题字体配置">主题字体配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>外观（先安装主题插件Material theme）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504191917951.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>代码字体</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504191946833.png" alt=""></p>
<h2 id="插件配置">插件配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CodeGlance</strong>: 代码缩略图</p>
</li>
<li class="lvl-2">
<p><strong>IdeaVim</strong>: 在IDE中使用Vim编辑器的功能</p>
</li>
<li class="lvl-2">
<p><strong>Key Promoter X</strong>: 自动提示快捷键</p>
</li>
<li class="lvl-2">
<p><strong>Material Theme</strong>: 修改主题</p>
</li>
<li class="lvl-2">
<p><strong>RestfulToolkitX</strong>： 供了一组用于构建 RESTful API 的工具和方法</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504192054149.png" alt=""></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX安装</title>
    <url>/archives/88b90715.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>LaTeX是一种专业的排版系统和标记语言，用于创建高质量的文档，尤其适合包含数学公式、技术内容和复杂结构的文档，如学术论文、书籍、报告、简历等。TeX Live是一款跨平台的LaTeX发行版，它包含了LaTeX编译器、宏包、字体和各种工具，适用于多种操作系统，如Windows、Linux和macOS。TeXstudio是一款免费开源的LaTeX编辑器。</p>
<p>WIindows推荐： <mark>Texlive 2023 + TeX studio</mark></p>
</blockquote>
<span id="more"></span>
<h2 id="Texlive-2023">Texlive 2023</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>ISO 映像下载：<a href="https://www.tug.org/texlive/acquire-iso.html">https://www.tug.org/texlive/acquire-iso.html</a></p>
</li>
</ul>
<p><strong>打开下载后的.ISO文件，以管理员身份运行install-tl-windows.bat文件。</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/explorer_vgFd0Lbe70.png" alt=""></p>
<p><strong>修改安装位置</strong></p>
<p><strong>选择安装语言</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>高级选项里 <mark>Advanced</mark> $\rightarrow$点击 <mark>Customize</mark> $\rightarrow$选择 <mark>中文和英文</mark></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/20230502111347.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/wish_PhEbgdUYiI.png" alt=""></p>
<p><strong>确定安装，等待安装完成后关闭窗口</strong></p>
<hr>
<h3 id="Texlive添加环境变量">Texlive添加环境变量</h3>
<p>添加Texlive环境变量，以在命令行中执行tex的命令</p>
<ol>
<li class="lvl-3">
<p>win+R 然后输入**sysdm.cpl **在高级中选择<em>环境变量</em></p>
</li>
<li class="lvl-3">
<p>编辑的Path变量（建议<u>用户和系统</u>的Path都添加），添加txtlive中的<mark>bin/windows</mark>路径（如：D:\Software\texlive\2023\bin\windows）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/SystemPropertiesAdvanced_iXSckGIh1W.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>查看验证安装版本（出现 <mark>版本号</mark> 则成功）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tex -v</span><br><span class="line">latex -v</span><br><span class="line">xelatex -v</span><br><span class="line">pdflatex -v</span><br></pre></td></tr></table></figure>
<h2 id="TeXstudio的安装">TeXstudio的安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>官网下载：<a href="https://texstudio.sourceforge.net/">https://texstudio.sourceforge.net/</a></p>
</li>
</ul>
<p><strong>双击安装$\rightarrow$修改安装位置即可</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/texstudio-4.5.2-win-qt6_5StfAN4gxi.png" alt=""></p>
<p><strong>使用注意</strong>：<em>如果撰写中文论文，将默认编译器改为<code>Xelatex</code>。如果撰写英文论文，将默认编译器改为<code>Pdflatex</code></em></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/texstudio_xkx0Bq0fS9.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	LaTeX的安装教程：<a href="https://blog.csdn.net/weixin_43872190/article/details/113736283">https://blog.csdn.net/weixin_43872190/article/details/113736283</a><br>
[2]	Latex（一）安装和环境变量的设置：<a href="https://blog.csdn.net/explorer9607/article/details/103506387">https://blog.csdn.net/explorer9607/article/details/103506387</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Ps2019基础总结</title>
    <url>/archives/2888cf0.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><strong>安装</strong>：参考 <mark>软件管家</mark> 公众号(<a href="https://mp.weixin.qq.com/s/jUEyqVY8RrU2RB_mlPlKDQ">https://mp.weixin.qq.com/s/jUEyqVY8RrU2RB_mlPlKDQ</a>)，推荐2019及以上版本</p>
<p><u>注意：电脑出现蓝屏自动重启情况，是显卡驱动问题，需更新到最新版</u></p>
<p>推荐使用<strong>GeForce Experience</strong>更新<strong>Studio</strong>（3D工作流畅）最新驱动</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504091325087.png" alt=""></p>
</blockquote>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<p><strong>色相、饱和度和亮度</strong> 是 <mark>颜色</mark> 的三个基本属性，通常缩写为HSL。它们是用于描述颜色的一种常见方式，特别是在计算机图形学和设计中。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>色相（Hue）：指颜色的基本色调，如红色、绿色、蓝色等。色相可以用一个0到360度的角度值来表示，其中0度表示红色，120度表示绿色，240度表示蓝色。</p>
</li>
<li class="lvl-2">
<p>饱和度（Saturation）：指颜色的纯度或强度，即颜色中灰色成分的比例。饱和度越高，颜色越鲜艳，越接近于纯色。饱和度可以用一个0到100%的值来表示，其中0%表示灰色，100%表示纯色。</p>
</li>
<li class="lvl-2">
<p>亮度（Lightness）：指颜色的明暗程度，即颜色中黑色成分的比例。亮度可以用一个0到100%的值来表示，其中0%表示黑色，100%表示白色。</p>
</li>
</ul>
<p><mark>图像</mark> 中最基本的概念除 <strong>颜色</strong> 之外,还包括:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对比度:指图像中明暗度的差异,对比度大意味着同一图像中的亮度差异较大,对比度小则差异较小。对比度直接影响图像的清晰度和层次感。</p>
</li>
<li class="lvl-2">
<p>纹理:指图像中像素在空间方向的变化模式。纹理为图像提供了粗糙或平滑的视觉感觉,丰富了图像的内容。</p>
</li>
<li class="lvl-2">
<p>空间频率:指图像中视觉模式的重复频率,它控制了图像中的细节程度。高频图像具有更多细节,低频图像则较为平滑。</p>
</li>
</ul>
<h2 id="新建文档">新建文档</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>Ctrl + N</mark></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">像素</th>
<th>分辨率</th>
<th>颜色模式</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">打印</td>
<td>300</td>
<td>CMYK</td>
<td>cm</td>
</tr>
<tr>
<td style="text-align:left">显示</td>
<td>72</td>
<td>RGB</td>
<td>像素</td>
</tr>
</tbody>
</table>
<p><em>背景透明的显示：灰白格子</em></p>
<h3 id="文件打开">文件打开</h3>
<ol>
<li class="lvl-3">
<p><mark>Ctrl+O</mark> 打开文件（<strong>Ctrl</strong>：点选 <strong>Shift</strong>：连选）</p>
</li>
<li class="lvl-3">
<p>资源管理器$\rightarrow$拖拽文件</p>
</li>
</ol>
<h3 id="文件查看">文件查看</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>窗口$\rightarrow$排列</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/Photoshop_cmHe5yK04V.png" alt=""></p>
<h3 id="文件保存">文件保存</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>Ctrl+Shift+S</mark></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">保持背景透明保存为PNG</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">保存为GIF：文件$\rightarrow$导出$\rightarrow$存储为web格式（格式选为GIF）</label></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/%25E5%259B%25BE%25E5%2583%258F%25E6%25A0%25BC%25E5%25BC%258F.jpg" alt=""></p>
<h2 id="基本操作">基本操作</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>工具栏快捷键: <mark>Alt + 相应字母</mark></p>
</li>
<li class="lvl-2">
<p>右键点击工具$\rightarrow$工具切换</p>
</li>
<li class="lvl-2">
<p>打开滚轮缩放（编辑$\rightarrow$首选项$\rightarrow$工具$\rightarrow$滚轮缩放）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">移动</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">画笔</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">旋转</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td style="text-align:center">缩放</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">选框</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">裁剪</td>
</tr>
<tr>
<td style="text-align:center">Alt</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">Shift + 相应字母</td>
<td style="text-align:center">同类型工具切换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + <code>+-</code></td>
<td style="text-align:center">缩放</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Z</td>
<td style="text-align:center">撤回</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift+ Z</td>
<td style="text-align:center">前进</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + J</td>
<td style="text-align:center">复制图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift+ N</td>
<td style="text-align:center">新建图层</td>
</tr>
<tr>
<td style="text-align:center">Delete</td>
<td style="text-align:center">删除图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + E</td>
<td style="text-align:center">合并图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  E</td>
<td style="text-align:center">合并可见图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + [</td>
<td style="text-align:center">图层下移</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + ]</td>
<td style="text-align:center">图层上移</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  [</td>
<td style="text-align:center">下移最底</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  ]</td>
<td style="text-align:center">上移最顶</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + G</td>
<td style="text-align:center">新建组</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + T</td>
<td style="text-align:center">自由变换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +T</td>
<td style="text-align:center">再次变换</td>
</tr>
<tr>
<td style="text-align:center">Alt + Delete</td>
<td style="text-align:center">填充前景色</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Delete</td>
<td style="text-align:center">填充背景色</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Ps</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown进阶</title>
    <url>/archives/97cdff40.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>Markdown是一种轻量级标记语言，旨在提供一个易于学习和使用的文本到HTML转换工具。它提供了标题、列表、代码块、链接等简单的标记和语法，使文本排版更加简单、清晰和易读。现在，许多平台都支持Markdown，包括GitHub、Stack Overflow和Reddit。掌握Markdown是非常有用的，具体参考<a href="https://liuaoao.top/archives/1ef37645.html">Markdown-For-Typora</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="常用查表">常用查表</h2>
<table>
<thead>
<tr>
<th style="text-align:center">样式名</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">转义</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">加粗</td>
<td style="text-align:center"><code>**文本**</code> 或 <code>__文本__</code></td>
</tr>
<tr>
<td style="text-align:center">斜体</td>
<td style="text-align:center"><code>*文本*</code> 或 <code>_文本_</code></td>
</tr>
<tr>
<td style="text-align:center">删除线</td>
<td style="text-align:center"><code>~~文本~~</code></td>
</tr>
<tr>
<td style="text-align:center">下划线</td>
<td style="text-align:center"><code>&lt;u&gt;文本&lt;/u&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">上标</td>
<td style="text-align:center"><code>文本^上标^</code></td>
</tr>
<tr>
<td style="text-align:center">下标</td>
<td style="text-align:center"><code>文本~下标~</code></td>
</tr>
<tr>
<td style="text-align:center">小号字体</td>
<td style="text-align:center"><code>&lt;small&gt;小号字体&lt;/small&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">大号字体</td>
<td style="text-align:center"><code>&lt;big&gt;大号字体&lt;/big&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">高亮</td>
<td style="text-align:center"><code>==文本==</code></td>
</tr>
<tr>
<td style="text-align:center">代码块</td>
<td style="text-align:center">`代码` 或 ```代码```</td>
</tr>
<tr>
<td style="text-align:center">链接</td>
<td style="text-align:center"><code>[链接文本](链接地址)</code></td>
</tr>
<tr>
<td style="text-align:center">图片</td>
<td style="text-align:center"><code>![图片替代文本](图片链接地址)</code></td>
</tr>
<tr>
<td style="text-align:center">引用</td>
<td style="text-align:center">&gt; 引用内容</td>
</tr>
<tr>
<td style="text-align:center">分割线</td>
<td style="text-align:center">— 或 ***</td>
</tr>
<tr>
<td style="text-align:center">数学公式</td>
<td style="text-align:center"><code>$$LaTex$$</code></td>
</tr>
</tbody>
</table>
<h2 id="箭头">箭头</h2>
<p><strong>基本箭头</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\uparrow$</td>
<td style="text-align:center"><code>$\uparrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\downarrow$</td>
<td style="text-align:center"><code>$\downarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\leftarrow$</td>
<td style="text-align:center"><code>$\leftarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\rightarrow$</td>
<td style="text-align:center"><code>$\rightarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\updownarrow$</td>
<td style="text-align:center"><code>$\updownarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\leftrightarrow$</td>
<td style="text-align:center"><code>$\leftrightarro$</code></td>
</tr>
</tbody>
</table>
<p><strong>双线箭头</strong>：基本箭头<mark>首字母大写</mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">双线箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\Uparrow$</td>
<td style="text-align:center"><code>$\Uparrow$</code></td>
</tr>
</tbody>
</table>
<p><strong>长箭头</strong>：基本箭头前+<mark>long</mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">长箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\longrightarrow$</td>
<td style="text-align:center"><code>$\longrightarrow$</code></td>
</tr>
</tbody>
</table>
<hr>
<p>继续更新ing😄</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows终端代理</title>
    <url>/archives/7b6d4a85.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="CMD">CMD</h2>
<h3 id="临时生效">临时生效</h3>
<p>命令行窗口关闭就失效</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置</span><br><span class="line">set http_proxy=http://127.0.0.1:7890</span><br><span class="line">set https_proxy=http://127.0.0.1:7890</span><br><span class="line"># 如需账户、密码</span><br><span class="line">set http_proxy_user=username</span><br><span class="line">set http_proxy_pass=password</span><br><span class="line"># 查看</span><br><span class="line">set http_proxy</span><br><span class="line">set https_proxy</span><br><span class="line"># 取消</span><br><span class="line">set http_proxy=</span><br><span class="line">set https_proxy=</span><br><span class="line">set http_proxy_user=</span><br><span class="line">set http_proxy_pass=</span><br></pre></td></tr></table></figure>
<h3 id="永久生效">永久生效</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加如下环境变量（右键我的电脑-&gt; 属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">http_proxy</td>
<td style="text-align:center"><code> http://127.0.0.1:7890</code></td>
</tr>
<tr>
<td style="text-align:center">https_proxy</td>
<td style="text-align:center"><code> http://127.0.0.1:7890</code></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/c68f9ab677f3436d8a02a8a847329137.png" alt=""></p>
<h3 id="常用快捷键">常用快捷键</h3>
<p>有的需要右键–&gt;编辑模式–&gt;开启复制粘贴</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + a</td>
<td>将光标移到行首</td>
</tr>
<tr>
<td>Ctrl + e</td>
<td>将光标移到末尾</td>
</tr>
<tr>
<td>Ctrl + u</td>
<td>删除整行</td>
</tr>
<tr>
<td>Ctrl + k</td>
<td>向后删除，从光标开始直至行尾</td>
</tr>
<tr>
<td>Alt + Backspace</td>
<td>光标向前删除一个单词</td>
</tr>
<tr>
<td>Alt + f</td>
<td>将光标移动到后一个单词</td>
</tr>
<tr>
<td>Alt + b</td>
<td>将光标移动到前一个单词</td>
</tr>
<tr>
<td>Ctrl + p</td>
<td>上一条命令</td>
</tr>
<tr>
<td>Ctrl + n</td>
<td>下一条命令</td>
</tr>
</tbody>
</table>
<h2 id="Git（永久生效）">Git（永久生效）</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 设施全局代理</span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line"># 查看代理</span><br><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br><span class="line"># 取消全局代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>重启<code>cmd</code>命令行，使用 <code>curl www.google.com</code> ，如果有内容返回，说明设置成功（不可以是 <code>ping</code> 命令进行测试）</p>
<h2 id="Reference">Reference</h2>
<p>[1]	windows设置和删除代理: <a href="https://liuxingjun.github.io/blog/2018/05/03/windows%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%88%A0%E9%99%A4%E4%BB%A3%E7%90%86">https://liuxingjun.github.io/blog/2018/05/03/windows设置和删除代理</a></p>
<p>[2]	git设置、查看、取消代理: <a href="https://www.cnblogs.com/yongy1030/p/11699086.html">https://www.cnblogs.com/yongy1030/p/11699086.html</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Proxy</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown-For-Typora</title>
    <url>/archives/1ef37645.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Overview">Overview</h2>
<p><strong>Markdown</strong> is created by <a href="http://daringfireball.net/">Daring Fireball</a>; the original guideline is <a href="http://daringfireball.net/projects/markdown/syntax">here</a>. Its syntax, however, varies between different parsers or editors. <strong>Typora</strong> is using <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a>.</p>
<span id="more"></span>
<h2 id="Block-Elements">Block Elements</h2>
<h3 id="Paragraph-and-line-breaks">Paragraph and line breaks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.按一次&quot;return&quot;即可创建新段落</span><br><span class="line">2.按&quot;shift&quot;+&quot;return&quot;以创建单行中断。大多数其他减值解析器将忽略单行中断，因此，为了让其他减值解析器识别您的线路中断，您可以在行的末尾留出两个空格，或插入&quot;<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>&quot;。</span><br></pre></td></tr></table></figure>
<h3 id="Headers">Headers</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">标题在行的开头使用 1-6 个哈希字符（&#x27;#&#x27;），对应于标题级别 1-6。</span><br><span class="line">例如：</span><br><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure>
<h3 id="Blockquotes">Blockquotes</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Markdown 使用电子邮件式&gt;字符进行阻止引用。它们被呈现为:</span><br><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. This is first paragraph.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; This is second pragraph. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote.</span></span><br><span class="line"></span><br><span class="line">在 Typora 中，输入&quot;&gt;&quot;，然后输入您的报价内容将生成报价块。Typora 将为您插入适当的&quot;&gt;&quot;或线路中断。嵌套块报价（另一个区块报价中的块报价），通过添加额外的&quot;&gt;&quot;级别。</span><br></pre></td></tr></table></figure>
<h3 id="Lists">Lists</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">输入&quot;* 列表项目 &quot; 将创建一个未排序的列表 -&quot;<span class="emphasis">*&quot;符号可以替换为&quot;+&quot;或&quot;-&quot;。   输入 &#x27;1.列表项目 &#x27; 将创建一个订单列表 - 其标记源代码如下：</span></span><br><span class="line"><span class="emphasis">## un-ordered list</span></span><br><span class="line"><span class="emphasis">*</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">*</span>   Blue</span><br><span class="line"></span><br><span class="line"><span class="section">## ordered list</span></span><br><span class="line"><span class="bullet">1.</span>  Red</span><br><span class="line"><span class="bullet">2.</span> 	Green</span><br><span class="line"><span class="bullet">3.</span>	Blue</span><br></pre></td></tr></table></figure>
<h3 id="Task-List">Task List</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">任务列表是标有 [] 或 [x] （不完整或已完成） 的项目列表。例如：</span><br><span class="line"><span class="bullet">-</span> [ ] a task list item</span><br><span class="line"><span class="bullet">-</span> [ ] list syntax required</span><br><span class="line"><span class="bullet">-</span> [ ] normal <span class="strong">**formatting**</span>, @mentions, #1234 refs</span><br><span class="line"><span class="bullet">-</span> [ ] incomplete</span><br><span class="line"><span class="bullet">-</span> [x] completed</span><br></pre></td></tr></table></figure>
<h3 id="Fenced-Code-Blocks">(Fenced) Code Blocks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Typora 只支持 fences in GitHub Flavored Markdown。不支持 Markdown 中的原始代码块。   使用 fences 很容易：输入<span class="code">```和按 &#x27;return&#x27;。在```</span>之后添加可选语言标识符，我们将通过语法加亮来运行它：</span><br><span class="line">Here&#x27;s an example:</span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">function test() &#123;</span></span><br><span class="line"><span class="code">  console.log(&quot;notice the blank line before this function?&quot;);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">syntax highlighting:</span><br><span class="line"><span class="code">```ruby</span></span><br><span class="line"><span class="code">require &#x27;redcarpet&#x27;</span></span><br><span class="line"><span class="code">markdown = Redcarpet.new(&quot;Hello World!&quot;)</span></span><br><span class="line"><span class="code">puts markdown.to_html</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>
<h3 id="Math-Blocks">Math Blocks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">您可以使用<span class="strong">**MathJax**</span>来渲染[LaTeX]数学表达式。</span><br><span class="line">要添加数学表达，输入&quot;$$&quot;并按&quot;return&quot;键。这将触发一个接受 <span class="emphasis">*Tex/LaTex*</span> 源的输入字段。例如：</span><br></pre></td></tr></table></figure>
<p>$$<br>
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>
\end{vmatrix}<br>
$$</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">In the markdown source file, the math block is a <span class="emphasis">*LaTeX*</span> expression wrapped by a pair of ‘$$’ marks:</span><br><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;<span class="emphasis">_1 \times \mathbf&#123;V&#125;_</span>2 =  \begin&#123;vmatrix&#125;</span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Tables">Tables</h3>
<p>输入<code>| First Header  | Second Header |</code> &quot;并按<code>&quot;return&quot;</code>键。这将创建一个带有两列的表。   创建表后，将焦点放在该表上将打开表的工具栏，您可以调整表大小、对齐或删除表。您还可以使用上下文菜单复制和添加/删除单个列/行。   表的完整语法如下所述，但无需详细了解完整的语法，因为表的标记源代码由 Typora 自动生成。</p>
<p>在 markdown 源代码中，它们看起来像：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure>
<p>您还可以在表中包含 inline Markdown 标记，如链接、粗体、斜体或删除线（links, bold, italics, or strikethrough）。</p>
<p>最后，通过在头行中包含冒号  (<code>:</code>)，您可以将该列中的文本定义为左对齐、右对齐或中对齐：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure>
<p>最左边的冒号表示左对齐的列；最右边的冒号表示列是右对齐的；两边的冒号表示是中心对齐的列。</p>
<h3 id="Footnotes">Footnotes</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You can create footnotes like this[^footnote].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^footnote</span>]: <span class="link">Here is the *text* of the **footnote**.</span></span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>You can create footnotes like this<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p>
<p>将鼠标悬停在“脚注”上标上，可以查看脚注的内容。</p>
<h3 id="Horizontal-Rules">Horizontal Rules</h3>
<p>在空行输入 <code>***</code> 或 <code>---</code>，并按 <code>return</code> 将画出一条水平线。</p>
<h3 id="YAML-Front-Matter">YAML Front Matter</h3>
<p>Typora 现在支持<a href="http://jekyllrb.com/docs/frontmatter/">YAML Front Matter</a>。在文章的顶部输入<code>---</code>，然后按 <code>Return</code> 引入元数据块。或者，您可以从 Typora 的顶部菜单中插入元数据块。</p>
<h3 id="Table-of-Contents-TOC">Table of Contents(TOC)</h3>
<p>输入<code>[toc]</code>并按<code>Return</code>键。这将创建一个“目录”部分。TOC从文档中提取所有标题，当您添加到文档时，它的内容会自动更新。</p>
<h2 id="Span-Elements">Span Elements</h2>
<p>Span元素将在输入后立即被解析和呈现。将光标移动到这些span元素的中间会将这些元素展开为markdown源。下面是每个span元素的语法解释</p>
<h3 id="Links">Links</h3>
<p>Markdown支持两种样式的链接:内联和引用。</p>
<p>在这两种样式中，链接文本由 [方括号] 分隔。</p>
<p>要创建内联链接，请在链接文本的右方括号后立即使用一组规则括号。在圆括号内，将URL放置在您希望链接指向的位置，并为链接提供一个可选的标题，用引号括起来。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>](<span class="link">http://example.com/ &quot;Title&quot;</span>) inline link.</span><br><span class="line"></span><br><span class="line">[<span class="string">This link</span>](<span class="link">http://example.net/</span>) has no title attribute.</span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>This is <a href="http://example.com/" title="Title">an example</a> inline link. (<code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</code>)</p>
<p><a href="http://example.net/">This link</a> has no title attribute… (<code>&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</code>)</p>
<h4 id="Internal-Links">Internal Links</h4>
<p><strong>您可以将 href 设置为headers</strong>，这将创建一个书签，允许您单击后跳转到该部分。</p>
<p>例如: 命令(在Windows上:Ctrl) +单击此 <a href="#block-elements">This link</a> 将跳转到标题块元素。要查看如何编写，请移动光标或按下⌘键单击该链接以将元素展开为 markdown 源。</p>
<h4 id="Reference-Links">Reference Links</h4>
<p>参考样式的链接使用第二组方括号，在里面你可以选择一个标签来标识链接:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>][<span class="symbol">id</span>] reference-style link.</span><br><span class="line"></span><br><span class="line">Then, anywhere in the document, you define your link label on a line by itself like this:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">id</span>]: <span class="link">http://example.com/  &quot;Optional Title Here&quot;</span></span><br></pre></td></tr></table></figure>
<p>will produce</p>
<p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p>
<p>Then, anywhere in the document, you define your link label on a line by itself like this:</p>
<p>隐式链接名称快捷方式允许您省略链接的名称，在这种情况下链接文本本身将用作名称。只需使用一组空的方括号-例如，链接单词“Google”到 <a href="http://google.com">google.com</a> 网站，你可以简单地写:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol"></span>]</span><br><span class="line">And then define the link:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">Google</span>]: <span class="link">http://google.com/</span></span><br></pre></td></tr></table></figure>
<p><a href="http://google.com/">Google</a><br>
And then define the link:</p>
<h3 id="URLs">URLs</h3>
<p>Typora允许你以链接的形式插入url，用’ &lt; <code>brackets</code> &gt; '包围。</p>
<p><code>&lt;i@typora.io&gt;</code> becomes <a href="mailto:i@typora.io">i@typora.io</a>.</p>
<p>Typora 也会自动链接标准 url。例如: <a href="http://www.google.com">www.google.com</a>。</p>
<h3 id="Images">Images</h3>
<p>图片的语法与链接类似，但它们在链接开始之前需要额外的 <code>!</code> 符号。插入图像的语法是这样的:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg &quot;Optional title&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>您可以使用拖放从图像文件或 web 浏览器插入图像。您可以通过单击图像来修改 markdown 源代码。如果使用拖放方式添加的图像与当前正在编辑的文档位于同一目录或子目录，则使用相对路径。</p>
<p>如果你正在使用 markdown 来构建网站，你可以在 YAML Front Matters 中 使用属性<code>typora-root-url</code>为你的本地计算机上的图像预览指定一个URL前缀。例如，在YAML Front Matters 输入<code>typora-root-url:/User/Abner/Website/typora.io/</code>，然后<code>![alt](/blog/img/test.png)</code>在 Typora 将被视为<code>![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)</code></p>
<p>You can find more details <a href="https://support.typora.io/Images/">here</a>.</p>
<h3 id="Emphasis">Emphasis</h3>
<p>Markdown 将星号 (<code>*</code>) 和下划线(<code> _</code>)作为强调的指示符。用一个 <code>*</code> or <code>_</code> 包装的文本将用一个 HTML <code>&lt;em&gt;</code> tag 包装。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*single asterisks*</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_single underscores_</span></span><br></pre></td></tr></table></figure>
<p>output:</p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p>GFM 会忽略单词中常用的下划线，比如:</p>
<blockquote>
<p>wow_great_stuff</p>
<p>do_this_and_do_that_and_another_thing.</p>
</blockquote>
<p>要在原本用作强调分隔符的位置产生星号或下划线，可以使用反斜杠转义:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="emphasis">*this text is surrounded by literal asterisks\*</span></span><br></pre></td></tr></table></figure>
<p>推荐使用<code>*</code>符号。</p>
<h3 id="Strong">Strong</h3>
<p>双引号<code>*</code>或<code>_</code>将导致其包含的内容被一个HTML ’ <strong> '标签包装，例如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**double asterisks**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__double underscores__</span></span><br></pre></td></tr></table></figure>
<p>output:</p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<p>推荐使用 <code>**</code>符号</p>
<h3 id="Code">Code</h3>
<p>若要指示代码的内联跨度，请用反勾引号(`)将其包装起来。与预格式化的代码块不同，代码跨度表示正常段落中的代码。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Use the <span class="code">`printf()`</span> function.</span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>Use the <code>printf()</code> function.</p>
<p>使用<code>printf()</code>函数</p>
<h3 id="Strikethrough">Strikethrough</h3>
<p>GFM 添加了创建划线文本的语法，这是标准 Markdown 所缺少的。</p>
<p><code>~~Mistaken text.~~</code> becomes <s>Mistaken text.</s></p>
<h3 id="Underlines">Underlines</h3>
<p>Underline 是由原始 HTML 驱动的。</p>
<p><code>&lt;u&gt;Underline&lt;/u&gt;</code> becomes <u>Underline</u>.</p>
<h3 id="Emoji-😄">Emoji 😄</h3>
<p>输入带有语法的表情符号: <code>:smile:</code>。</p>
<p>用户可以按下<code>ESC</code> 键自动完成对表情符号的建议，或者在首选面板上启用后自动触发。此外，直接输入 UTF-8 表情符号也可以通过菜单栏中的 <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>来实现。</p>
<h3 id="Inline-Math">Inline Math</h3>
<p>要使用此功能，请先在 <code>Preference</code> 面板-&gt; <code>Markdown</code> 选项卡中启用它。然后，使用 <code>$</code> 包装 TeX 命令。例如: <code>$\lim_&#123;x \to \infty&#125; \exp(-x) = 0$</code> 将被呈现为 LaTeX 命令。</p>
<p>要触发内联数学的内联预览:输入“$”，然后按“ESC”键，然后输入 TeX 命令。</p>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Subscript">Subscript</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用 <code>~</code> 包装下标内容。例如: <code>H~2~O</code>, <code>X~long\ text~</code>/</p>
<h3 id="Superscript">Superscript</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用  <code>^</code>  包装上标内容。例如: <code>X^2^</code>.</p>
<h3 id="Highlight">Highlight</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用 <code>==</code> 包装高亮内容。例如: <code>==highlight==</code>.</p>
<h2 id="HTML">HTML</h2>
<p>您可以使用 HTML 来样式化纯 Markdown 不支持的内容。例如，使用 <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> 来添加红色文本。</p>
<h3 id="Embed-Contents">Embed Contents</h3>
<p>一些网站提供基于框架的嵌入代码，你也可以将其粘贴到 Typora 中。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">&#x27;265&#x27;</span> <span class="attr">scrolling</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">title</span>=<span class="string">&#x27;Fancy Animated SVG Menu&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#x27;</span> <span class="attr">frameborder</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">allowtransparency</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">allowfullscreen</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;width: 100%;&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Video">Video</h3>
<p>你可以使用<code>&lt;video&gt;</code>HTML标签来嵌入视频。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Other-HTML-Support">Other HTML Support</h3>
<p>You can find more details <a href="https://support.typora.io/HTML/">here</a>.</p>
<h2 id="Reference">Reference</h2>
<p>[1]	Typora的Markdown语法: <a href="https://support.typoraio.cn/zh/Markdown-Reference">https://support.typoraio.cn/zh/Markdown-Reference</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Here is the <em>text</em> of the <strong>footnote</strong>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>浅层语义分析（LSA）</title>
    <url>/archives/d42a069d.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p><strong>前言</strong></p>
<p><mark>浅层语义分析（LSA）</mark> 是一种自然语言处理中用到的方法，其通过“矢量语义空间”来提取文档与词中的“概念”，进而分析文档与词之间的关系。LSA的基本假设是，如果两个词多次出现在同一文档中，则这两个词在语义上具有相似性。LSA使用大量的文本上构建一个矩阵，这个矩阵的一行代表一个词，一列代表一个文档，矩阵元素代表该词在该文档中出现的次数，然后再此矩阵上使用奇异值分解（SVD）来保留列信息的情况下减少矩阵行数，之后每两个词语的相似性则可以通过其行向量的cos值（或者归一化之后使用向量点乘）来进行标示，此值越接近于1则说明两个词语越相似，越接近于0则说明越不相似。</p>
<span id="more"></span>
<p>LSA最早在1988年由 <a href="https://en.wikipedia.org/wiki/Scott_Deerwester">Scott Deerwester</a>, <a href="https://en.wikipedia.org/wiki/Susan_Dumais">Susan Dumais</a>, <a href="https://en.wikipedia.org/wiki/George_Furnas">George Furnas</a>, <a href="https://en.wikipedia.org/wiki/Richard_Harshman">Richard Harshman</a>, <a href="https://en.wikipedia.org/wiki/Thomas_Landauer">Thomas Landauer</a>, <a href="https://en.wikipedia.org/w/index.php?title=Karen_Lochbaum&amp;action=edit&amp;redlink=1">Karen Lochbaum</a> and <a href="https://en.wikipedia.org/w/index.php?title=Lynn_Streeter&amp;action=edit&amp;redlink=1">Lynn Streeter</a>提出，在某些情况下，LSA又被称作潜在语义索引（LSI）。</p>
<p><strong>概述</strong></p>
<p><strong>词-文档矩阵（Occurences Matrix)</strong></p>
<p>LSA 使用词-文档矩阵来描述一个词语是否在一篇文档中。词-文档矩阵式一个稀疏矩阵，其行代表词语，其列代表文档。一般情况下，词-文档矩阵的元素是该词在文档中的出现次数，也可以是是该词语的tf-idf(term frequency–inverse document frequency)。</p>
<p>词-文档矩阵和传统的语义模型相比并没有实质上的区别，只是因为传统的语义模型并不是使用“矩阵”这种数学语言来进行描述。</p>
<p><strong>降维</strong></p>
<p>在构建好词-文档矩阵之后，LSA将对该矩阵进行降维，来找到词-文档矩阵的一个低阶近似。降维的原因有以下几点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>原始的词-文档矩阵太大导致计算机无法处理，从此角度来看，降维后的新矩阵式原有矩阵的一个近似。</p>
</li>
<li class="lvl-2">
<p>原始的词-文档矩阵中有噪音，从此角度来看，降维后的新矩阵式原矩阵的一个去噪矩阵。</p>
</li>
<li class="lvl-2">
<p>原始的词-文档矩阵过于稀疏。原始的词-文档矩阵精确的反映了每个词是否“出现”于某篇文档的情况，然而我们往往对某篇文档“相关”的所有词更感兴趣，因此我们需要发掘一个词的各种同义词的情况。</p>
</li>
</ul>
<p>降维的结果是不同的词或因为其语义的相关性导致合并，如：</p>
<p>{(car), (truck), (flower)} --&gt; {(1.3452 * car + 0.2828 * truck), (flower)}</p>
<p>将维可以解决一部分同义词的问题，也能解决一部分二义性问题。具体来说，原始词-文档矩阵经过降维处理后，原有词向量对应的二义部分会加到和其语义相似的词上，而剩余部分则减少对应的二义分量。</p>
<p><strong>推导</strong></p>
<p>假设X是词-文档矩阵，其元素（i,j）代表词语i在文档j中的出现次数，则X矩阵看上去是如下的样子：</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240431.png" alt=""></p>
<p>可以看到，每一行代表一个词的向量，该向量描述了该词和所有文档的关系。</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240905.png" alt=""></p>
<p>相似的，一列代表一个文档向量，该向量描述了该文档与所有词的关系。</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240123.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242577.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242830.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242875.png" alt=""></p>
<p>**代码：**<a href="https://github.com/Humble-LiuAo/Machine-Learning/tree/main/Data%20Mining/LSA">https://github.com/Humble-LiuAo/Machine-Learning/tree/main/Data Mining/LSA</a></p>
<p><strong>应用</strong></p>
<p>低维的语义空间可以用于以下几个方面:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在低维语义空间可对文档进行比较，进而可用于文档聚类和文档分类。</p>
</li>
<li class="lvl-2">
<p>在翻译好的文档上进行训练，可以发现不同语言的相似文档，可用于跨语言检索。</p>
</li>
<li class="lvl-2">
<p>发现词与词之间的关系，可用于同义词、歧义词检测。.</p>
</li>
<li class="lvl-2">
<p>通过查询映射到语义空间，可进行信息检索。</p>
</li>
<li class="lvl-2">
<p>从语义的角度发现词语的相关性，可用于“选择题回答模型”（multi choice qustions answering model）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
        <category>Data mining</category>
      </categories>
      <tags>
        <tag>Machine learning</tag>
        <tag>语义分析</tag>
        <tag>Data mining</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda-Python环境安装</title>
    <url>/archives/eabeff19.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="查询版本信息">查询版本信息</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>驱动器版本：右键NVIDIA–&gt;系统信息（点击开始菜单，搜索<code>dxdiag</code>）</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应cuda版本：</p>
<p><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a></p>
</li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应tensorflow版本：</p>
<p><a href="https://tensorflow.google.cn/install/source_windows?hl=en#gpu">https://tensorflow.google.cn/install/source_windows?hl=en#gpu</a></p>
</li>
<li class="lvl-2">
<p>对应pytorch版本：</p>
<p><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p>
</li>
</ul>
<h2 id="安装Anaconda">安装Anaconda</h2>
<p>下载网址：<a href="https://repo.anaconda.com/archive/">https://repo.anaconda.com/archive/</a><br>
<strong>安装事项</strong>：</p>
<ol>
<li class="lvl-3">
<p>修改路径</p>
</li>
<li class="lvl-3">
<p>不要勾选“Add Anaconda to the system PATH environment variable”。</p>
</li>
<li class="lvl-3">
<p>添加上：<mark>Anaconda3、Anaconda3/Scripts、Anaconda3/Library/bin</mark>这3个文件夹的路径（用户+系统的Path，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</p>
</li>
</ol>
<h3 id="设置镜像源">设置镜像源</h3>
<p>清华镜像网址：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p>
<p>参考：<a href="https://www.cpci.dev/anaconda-mirrors-configure/">https://www.cpci.dev/anaconda-mirrors-configure/</a></p>
<ol>
<li class="lvl-3">
<p>生成 <mark>.condarc</mark> 文件： <code>conda config --set show_channel_urls yes</code>（C:\users\username\）</p>
</li>
<li class="lvl-3">
<p>清华源复制到 <mark>.condarc</mark> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">ssl_verify: false</span><br><span class="line"># 命令行</span><br><span class="line">conda clean -i</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>不走镜像、代理设置</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line"><span class="bullet">  -</span> defaults</span><br><span class="line">show<span class="emphasis">_channel_</span>urls: true</span><br><span class="line">proxy<span class="emphasis">_servers:</span></span><br><span class="line"><span class="emphasis">  http: 127.0.0.1:7890</span></span><br><span class="line"><span class="emphasis">  https: 127.0.0.1:7890</span></span><br><span class="line"><span class="emphasis">ssl_</span>verify: false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="conda安装tensorflow">conda安装tensorflow</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n tf python=3.6</span><br><span class="line">activate tf</span><br><span class="line">conda install tensorflow-gpu=1.9.0</span><br><span class="line"># 根据python版本默认安装 </span><br><span class="line">conda install tensorflow-gpu</span><br><span class="line"></span><br><span class="line">pip install --upgrade tensorflow</span><br><span class="line">python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span><br></pre></td></tr></table></figure>
<h3 id="高版本安装">高版本安装</h3>
<p>需要 <strong>pip</strong>安装 <strong>tensorflow</strong>：<a href="https://tensorflow.google.cn/install/pip?hl=en#windows-native">https://tensorflow.google.cn/install/pip?hl=en#windows-native</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge cudatoolkit=11.2 cudnn=8.1.0</span><br><span class="line">#如果上面这个执行失败了，多执行几次</span><br><span class="line">#如果自己的显卡支持，安装了上面的两个配置后，再安装下面的tensorflow-gpu 2.7.0版本的话</span><br><span class="line">#就可以直接显示gpu版本的状态为为true</span><br><span class="line">pip install tensorflow-gpu==2.7.0</span><br><span class="line">pip install &quot;tensorflow&lt;2.11&quot;</span><br><span class="line"># 走清华镜像</span><br><span class="line"> -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># 设置timeout</span><br><span class="line">pip --default-timeout=600 install &quot;tensorflow&lt;2.11&quot; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># Verify install:</span><br><span class="line">#python</span><br><span class="line">#impor tensorflow as tf</span><br><span class="line">#print(tf.config.list_physical_devices(&#x27;GPU&#x27;))</span><br></pre></td></tr></table></figure>
<h2 id="conda安装pytorch">conda安装pytorch</h2>
<p>选择版本安装：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n pytorch python=3.8</span><br><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>
<p><strong>CondaSSLError: OpenSSL appears to be unavailable on this machine. OpenSSL is required to download and install packages. <mark>解决的方法</mark></strong></p>
<ol>
<li class="lvl-3">
<p>到你的anaconda的安装目录位置：比如<br>
<img src="https://gitee.com/humble_ao/Image/raw/master/c6c98a6807fd4b559bac2703f3399427.png" alt=""></p>
</li>
<li class="lvl-3">
<p><code>D:\ProgramData\Anaconda3\Library\bin</code>，找到如下两个DLL的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libcrypto-1_1-x64.dll</span><br><span class="line">libssl-1_1-x64.dll</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/humble_ao/Image/raw/master/db37a06081a944b6ad430fad2c9a5336.png" alt=""></p>
</li>
<li class="lvl-3">
<p>复制到 <code>D:\ProgramData\Anaconda3\DLLs</code><br>
<img src="https://gitee.com/humble_ao/Image/raw/master/b76e975a080d48a8bf437c02f17c4178.png" alt=""></p>
</li>
<li class="lvl-3">
<p>重启下shell</p>
</li>
</ol>
<h2 id="测试">测试</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">if</span> tf.test.gpu_device_name():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Default GPU Device: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(tf.test.gpu_device_name()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please install GPU version of TF&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="built_in">print</span>(tf.test.gpu_device_name())</span><br><span class="line"><span class="built_in">print</span>(tf.test.is_gpu_available())</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytorch</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">flag = torch.cuda.is_available()</span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CUDA可使用&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CUDA不可用&quot;</span>)</span><br><span class="line"></span><br><span class="line">ngpu= <span class="number">1</span></span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;驱动为：&quot;</span>,device)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;GPU型号： &quot;</span>,torch.cuda.get_device_name(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h2 id="conda常用命令">conda常用命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version:</span><br><span class="line">conda -V</span><br><span class="line">env:</span><br><span class="line">conda env list</span><br><span class="line">conda create -n env python=3.6 </span><br><span class="line">conda remove -n env --all</span><br><span class="line">conda deactivate</span><br><span class="line">Package:</span><br><span class="line">conda list</span><br><span class="line">conda list -n your_env_name</span><br><span class="line">conda install -n env_name package_name</span><br><span class="line">conda update -n env_name package_name</span><br><span class="line">conda install numpy pandas matplotlib scikit-learn seaborn scikit-image opencv</span><br><span class="line">conda update conda</span><br><span class="line">conda update anaconda-navigator</span><br><span class="line">conda update navigator-updater</span><br><span class="line">conda update --all</span><br><span class="line"></span><br><span class="line">numpy matplotlib scikit-image scikit-learn tqdm pandas global-land-mask netCDF4 gdal</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
</search>
