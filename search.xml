<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代理与内网穿透</title>
    <url>/archives/b512fc98.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="代理">代理</h2>
<h3 id="什么是反向代理？">什么是反向代理？</h3>
<p>反向代理是位于 Web 服务器前面的服务器，其将客户端（例如 Web 浏览器）请求转发到这些 Web 服务器。反向代理通常用于帮助提高<a href="https://www.cloudflare.com/learning/security/what-is-web-application-security/">安全性</a>、<a href="https://www.cloudflare.com/learning/performance/why-site-speed-matters/">性能</a>和可靠性。为了更好地理解反向代理的工作原理以及它可以提供的好处，我们来首先定义什么是代理服务器。</p>
<span id="more"></span>
<h3 id="什么是代理服务器？">什么是代理服务器？</h3>
<p>转发代理，通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机之前的服务器。当这些计算机向 Internet 上的站点和服务发出请求时，代理服务器将拦截这些请求，然后代表客户端与 Web 服务器进行通信，起到中间设备的作用。</p>
<p>例如，典型的转发代理通信中涉及 3 台计算机：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>A：这是用户的家用计算机</p>
</li>
<li class="lvl-2">
<p>B：这是一个转发代理服务器</p>
</li>
<li class="lvl-2">
<p>C：这是网站的源站（用于存储网站数据）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/jNpMBu3SwHXDsdF.png" alt="正向代理流：流量从用户的设备 (A) 到正向代理 (B) 到互联网到源服务器 (C)"></p>
<p>在标准的互联网通信中，计算机 A 将直接与计算机 C 保持联系，客户端将请求发送到<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源服务器</a>，并且源服务器将响应客户端。当存在转发代理时，A 将请求发送到 B，B 随后将请求转发给 C。C 将向 B 发送响应，而 B 则将响应转发给 A。</p>
<p>为什么要将这个多余的中间设备添加到 Internet 活动中？使用转发代理可能有几个原因：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>为避免州或机构的浏览限制</strong>——一些政府、学校和其他组织使用防火墙来使用户访问受限版本的互联网。转发代理可用于绕过这些限制，因为它们使用户可以连接到代理，而不是直接连接到他们正在访问的站点。</p>
</li>
<li class="lvl-2">
<p><strong>阻止访问某些内容</strong>——相对的，也可以设置代理以阻止特定用户群访问某些站点。例如，学校网络可能配置为通过启用内容筛选规则的代理连接到 Web，以拒绝转发来自 Facebook 和其他社交媒体网站的响应。</p>
</li>
<li class="lvl-2">
<p><strong>保护自己的在线身份</strong>——在某些情况下，常规互联网用户希望增加在线匿名性，但在其他情况下，互联网用户居住在政府可能对政治异议者施加严重后果的地方。在网络论坛或社交媒体上批评政府可能会导致这些用户受到罚款或监禁。如果持不同政见者使用转发代理连接到他们发布政治敏感评论的网站，则用于发表评论的 <a href="https://www.cloudflare.com/learning/dns/glossary/what-is-my-ip-address/">IP 地址</a>将更难追溯到持不同政见者。仅代理服务器的 IP 地址将对他人可见。</p>
</li>
</ul>
<h3 id="反向代理有何不同？">反向代理有何不同？</h3>
<p>反向代理是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求。这与转发代理不同 - 在转发代理中，代理位于客户端的前面。使用反向代理，当客户端将请求发送到网站的源服务器时，反向代理服务器会在<a href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/">网络边缘</a>拦截这些请求。然后，反向代理服务器将向源服务器发送请求并从源服务器接收响应。</p>
<p>转发代理和反向代理之间的区别非常细微，但非常重要。简单概括而言，转发代理位于客户端的前面，确保没有源站直接与该特定客户端通信；而反向代理服务器位于源站前面，确保没有客户端直接与该源站通信。</p>
<p>这一次，所涉及的计算机包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>D：任意数量的用户家用计算机</p>
</li>
<li class="lvl-2">
<p>E：这是反向代理服务器</p>
</li>
<li class="lvl-2">
<p>F：一台或多台源站</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/IoGSXLkaHTrl7PU.png" alt="反向代理流：流量从用户的设备 (D) 到互联网到反向代理 (E) 到源服务器 (F)"></p>
<p>通常，来自 D 的所有请求都将直接发送到 F，而 F 会直接将响应发送到 D。使用反向代理，来自 D 的所有请求都将直接发送给 E，而 E 会将其请求发送到 F 并从 F 接收响应，然后将适当响应传递给 D。</p>
<p>下面是反向代理的一些好处：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><a href="https://www.cloudflare.com/learning/cdn/cdn-load-balance-reliability/">负载均衡</a></strong> - 一个每天吸引数百万用户的热门网站可能无法使用单个源服务器处理所有传入站点流量。但该站点可以分布在不同服务器的池中，让所有服务器都处理同一站点的请求。在这种情况下，反向代理可以提供一种负载均衡解决方案，在不同服务器之间平均分配传入流量，以防止单个服务器过载。如果某台服务器完全无法运转，则其他服务器可以代为处理流量。</p>
</li>
<li class="lvl-2">
<p><strong>防范攻击</strong> - 配备反向代理后，网站或服务无需透露其源服务器的 IP 地址。这使得攻击者更难利用针对性攻击，例如 <a href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/">DDoS 攻击</a>。这时候，攻击者只能针对反向代理，例如 Cloudflare 的 <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/">CDN</a>，而后者拥有具有更严格的安全性，拥有更多资源来抵御网络攻击。</p>
</li>
<li class="lvl-2">
<p><strong><a href="https://www.cloudflare.com/learning/cdn/glossary/global-server-load-balancing-gslb/">全局服务器负载平衡</a> (GSLB)</strong> - 在这种负载均衡形式中，一个网站可以分布在全球各地的多个服务器上，反向代理会将客户端发送到地理位置上最接近它们的服务器。这样可以减少请求和响应传播的距离，从而最大程度地减少加载时间。</p>
</li>
<li class="lvl-2">
<p><strong>缓存</strong> - 反向代理还可以<a href="https://www.cloudflare.com/learning/cdn/what-is-caching/">缓存</a>内容，从而提高速度。例如，如果巴黎的用户访问使用反向代理而 Web 服务器位于洛杉矶的网站，则该用户实际上可能连接到巴黎本地的反向代理服务器，然后该本地反向代理服务器必须与洛杉矶的源服务器进行通信。之后，代理服务器可以缓存（或临时保存）响应数据。随后浏览该站点的巴黎用户将从巴黎反向代理服务器处获取本地缓存的响应，从而享受到更快的性能。</p>
</li>
<li class="lvl-2">
<p><strong>SSL 加密</strong> - <a href="https://www.cloudflare.com/learning/ssl/what-is-encryption/">加密</a>和解密每个客户端的 <a href="https://www.cloudflare.com/learning/security/glossary/what-is-ssl/">SSL</a>（或 <a href="https://www.cloudflare.com/learning/security/glossary/transport-layer-security-tls/">TLS</a>）通信对于源服务器可能需要耗费大量计算资源。可以配置由反向代理解密所有传入请求并加密所有传出响应，腾出源服务器上的宝贵资源。</p>
</li>
</ul>
<h3 id="如何实施反向代理">如何实施反向代理</h3>
<p>一些公司构建自己的反向代理，但这需要大量的软件和硬件工程资源，以及对硬件的大量投资。享受反向代理的所有好处的最简单、最具成本效益的方法之一就是注册 CDN 服务。例如，<a href="https://www.cloudflare.com/cdn/">Cloudflare CDN</a> 提供上面列出的所有性能和安全功能，以及许多其他功能。</p>
<h2 id="内网穿透">内网穿透</h2>
<h3 id="1-什么是内网穿透">1. 什么是内网穿透?</h3>
<p>在了解内网穿透原理之前，我们先说什么是内网穿透。内网，就是在公司或者家庭内部，建立的局域网络或者是办公网络，可以实现多台电脑之间的资源共享，包括设备、资料、数据等。而外网则是通过一个网关与其它的网络系统连接，相对于内网而言，这种网络系统称之为外部网络，常见的就是我们日常使用的互联网。</p>
<p>一般而言，在没有固定公网IP的情况下，外网设备无法直接访问内网设备。而内网穿透技术，顾名思义就是能让外网的设备找到处于内网的设备，从而实现数据通信。</p>
<h3 id="2-内网穿透的原理">2. 内网穿透的原理</h3>
<p>内网穿透，又称为NAT穿透。NAT背后的设备，它们的主要特点是 ，可以访问外网，但不能被外网设备有效访问。基于这一特点，NAT穿透技术是让NAT背后的设备，先访问指定的外网服务器，由指定的外网服务器搭建桥梁，打通内、外网设备的访问通道，实现外网设备访问到内网设备。</p>
<p>该技术除了可以访问隐藏在NAT后的设备，同样可以穿透防火墙。这是因为防火墙一般只拦截了入站没有拦截出站，所以也可以让防火墙内的设备对外提供服务。</p>
<p>由于内网设备并不是与外网设备直接相连，所以在安全性上是毋庸置疑的，内网穿透可以说是安全与效率兼得。 <img src="https://s2.loli.net/2023/05/11/RE1iaN8nV6dDMWg.png" alt="img"></p>
<h3 id="3-如何实现内网穿透">3. 如何实现内网穿透</h3>
<p>我们可以安装<a href="https://hsk.oray.com/">花生壳</a>内网穿透软件，在软件上添加<a href="https://hsk.oray.com/">映射</a>时，配置被访问内网设备的相关信息 ，以及选择用作外网访问该映射的<a href="https://domain.oray.com/">域名</a>。当映射诊断信息提示连接成功时，即可实现内网穿透。</p>
<p>利用花生壳的内网穿透技术，外网的设备通过访问固定域名，连接花生壳服务器所搭建的通道，顺畅地与内网设备进行数据通信。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	什么是反向代理？|代理服务器介绍: <a href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/">https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/</a></p>
<p>[2]	内网穿透原理解析: <a href="https://service.oray.com/question/5571.html">https://service.oray.com/question/5571.html</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置C++</title>
    <url>/archives/1a24c243.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>使用系统：Ubuntu</p>
<p>使用IDE：Clion（目前用的免费教育许可证：<a href="https://www.jetbrains.com/zh-cn/community/education/#students%EF%BC%89">https://www.jetbrains.com/zh-cn/community/education/#students）</a></p>
</blockquote>
<span id="more"></span>
<h2 id="环境配置">环境配置</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 终端安装</span><br><span class="line">apt-get install gcc</span><br><span class="line">apt-get install g++</span><br><span class="line">或指定版本：8</span><br><span class="line">sudo apt-get install gcc-8</span><br><span class="line">sudo apt-get install g++-8</span><br><span class="line"># 查看版本</span><br><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line"># 查看该命令的所有操作</span><br><span class="line">g++ --h</span><br><span class="line">gcc --h</span><br></pre></td></tr></table></figure>
<h2 id="终端运行示例">终端运行示例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+T 打开终端</span><br><span class="line">mkdir ~/Projects/cppdemo &amp;&amp; cd ~/Projects/cppdemo # 创建项目目录cppdemo</span><br><span class="line">vi hello.cpp # vi打开文件hello.cp</span><br></pre></td></tr></table></figure>
<p>输入代码（<code>vi</code>操作）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>g++</code>编辑器编译，生成可执行文件 hello，<code>-o</code> 后面的hello是生成的存储输出内容的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>执行可执行文件（即打开hello）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure>
<h2 id="vim常用命令">vim常用命令</h2>
<p><strong>Vim(Vi IMproved)</strong> 是一种功能强大的文本编辑器，常用于Unix和Linux系统中。下面是一些常见的 Vim 操作：</p>
<ol>
<li class="lvl-3">
<p>打开文件：</p>
<ul class="lvl-2">
<li class="lvl-5">在终端中输入<code>vim</code>命令，后跟文件路径和名称，例如：<code>vim myfile.txt</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p>模式切换：</p>
<ul class="lvl-2">
<li class="lvl-5">按下<code>i</code>进入插入模式，可以输入和编辑文本。</li>
<li class="lvl-5">按下<code>Esc</code>键回到普通模式，可以执行命令。</li>
</ul>
</li>
<li class="lvl-3">
<p>保存和退出：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>:w</code>保存文件。</li>
<li class="lvl-5">输入<code>:q</code>退出 Vim。</li>
<li class="lvl-5">输入<code>:wq</code>保存并退出。</li>
</ul>
</li>
<li class="lvl-3">
<p>导航和编辑文本：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，使用箭头键或<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>进行光标导航。</li>
<li class="lvl-5">使用<code>x</code>删除当前光标所在位置的字符。</li>
<li class="lvl-5">使用<code>dd</code>删除当前行。</li>
<li class="lvl-5">使用<code>yy</code>复制当前行。</li>
<li class="lvl-5">使用<code>p</code>粘贴剪贴板中的内容。</li>
</ul>
</li>
<li class="lvl-3">
<p>撤销和重做：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>u</code>撤销最近的操作。</li>
<li class="lvl-5">输入<code>Ctrl + r</code>重做撤销的操作。</li>
</ul>
</li>
<li class="lvl-3">
<p>查找和替换：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>/</code>，后跟要查找的内容，按下回车键开始查找。</li>
<li class="lvl-5">输入<code>n</code>查找下一个匹配项。</li>
<li class="lvl-5">输入<code>:%s/old/new/g</code>全局替换文档中的所有匹配项。</li>
</ul>
</li>
</ol>
<h2 id="Reference">Reference</h2>
<p>[1]	Linux下的C/C++编译环境配置: <a href="https://blog.csdn.net/qq_27607539/article/details/73721946">https://blog.csdn.net/qq_27607539/article/details/73721946</a></p>
<p>[2]	如何在Ubuntu终端运行C++程序: <a href="https://blog.csdn.net/W1995S/article/details/117876875">https://blog.csdn.net/W1995S/article/details/117876875</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Vim</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware安装配置Ubuntu</title>
    <url>/archives/4da17f55.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="开启虚拟化">开启虚拟化</h2>
<p><strong>进入BIOS模式</strong>：联想拯救者：重启出现图标时按 <strong><u>Fn+F2</u></strong></p>
<ol>
<li class="lvl-3">
<p>选择 Configuration，再选择 Intel Virtualization Technology，此时该选项应该是 Disabled（关闭）；</p>
</li>
<li class="lvl-3">
<p>将 Disabled（关闭）改为 Enabled（开启）；</p>
</li>
</ol>
<span id="more"></span>  　　　　
<ol start="3">
<li class="lvl-3">
<p>点击Fn+F10，保存后退出，重启即可。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504172953354.png" alt=""></p>
<h2 id="安装ubuntu">安装ubuntu</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>参考 <mark>软件管家</mark> 公众号，或点击：<a href="https://mp.weixin.qq.com/s/OWUfIJ9Iwd-nwYhbTWXjuA">https://mp.weixin.qq.com/s/OWUfIJ9Iwd-nwYhbTWXjuA</a></p>
</li>
<li class="lvl-2">
<p><strong>硬盘、内存</strong>等参数可根据电脑配置修改</p>
</li>
</ul>
<h2 id="禁止更新">禁止更新</h2>
<ol>
<li class="lvl-3">
<p>系统设置–&gt;软件和更新–&gt;更新</p>
</li>
</ol>
<p>将“自动检查更新”和“有新版本时通知我”设置为“从不“，关闭对话框完成设置。</p>
<p><img src="https://s2.loli.net/2023/05/11/WqTUCsxc2kt7vRa.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>修改配置文件</p>
</li>
</ol>
<p>修改配置文件<code>/etc/apt/apt.conf.d/10periodic</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxx:~$cat /etc/apt/apt.conf.d/10periodic</span><br><span class="line">APT : :Periodic: : Update-Package-Lists &quot;1&quot;;</span><br><span class="line">APT : :Periodic: : Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line">APT : :Periodic: :AutocleanInterval &quot;0&quot;;</span><br><span class="line">APT : :Periodic: :Unattended-Upgrade &quot;0&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>linux系统下修改只读【read-only】文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod a+w /etc/apt/apt.conf.d/10periodic</span><br></pre></td></tr></table></figure>
<h2 id="输入法">输入法</h2>
<ol>
<li class="lvl-3">
<p>安装<code>fcitx</code>输入法框架</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx  # 安装fcitx输入法框架</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>配置<code>Fcitx</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">im-config  # 终端运行命令</span><br></pre></td></tr></table></figure>
<p>在弹出窗口选择<code>fcitx</code>，确认关闭窗口，并重启电脑让配置生效</p>
<p><img src="https://s2.loli.net/2023/05/11/iJMhA9I6Ny3zQXl.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>安装谷歌输入法</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx-googlepinyin -y # 安装谷歌输入法</span><br><span class="line">fcitx-config-gtk3   # 配置谷歌输入法</span><br></pre></td></tr></table></figure>
<p>在弹出对话框中取消勾选 “仅显示当前语言”，然后搜索选中“google”，点击确认。</p>
<p><img src="https://s2.loli.net/2023/05/11/jwv1inJr9ldCU4N.png" alt=""></p>
<p>点击桌面右上角，打开<code>configure</code>可以修改快捷键</p>
<p><img src="https://s2.loli.net/2023/05/11/AucRjCPOnmzFS8v.png" alt=""></p>
<p><strong>解决Jetbarins Clion Ubuntu Fcitx 中文输入法光标跟随问题</strong></p>
<ol>
<li class="lvl-3">
<p>下载根据补丁修复过的<code>jre</code>：<a href="https://github.com/RikudouPatrickstar/JetBrainsRuntime-for-Linux-x64/">https://github.com/RikudouPatrickstar/JetBrainsRuntime-for-Linux-x64/</a></p>
</li>
<li class="lvl-3">
<p>替换Clion的<code>jre</code></p>
<ul class="lvl-2">
<li class="lvl-5">选择特定<strong>路径</strong>解压</li>
<li class="lvl-5">Ctrl+shift+A，搜索: <code>Choose Boot Java Runtime for the IDE的Action</code>，并点击进入</li>
<li class="lvl-5">选择 <strong>New</strong> --&gt; <strong>Add Custom Runtime…</strong></li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/25oLvcydS8Jz1VW.png" alt="image-20230511201625729"></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Add JDK…</strong></p>
</li>
<li class="lvl-5">
<p>选择你解压的 <strong>路径</strong> ，点击OK，重启即可</p>
</li>
</ul>
</li>
</ol>
<h2 id="必备软件">必备软件</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Vim、Firefox（浏览器）、Variety（桌面壁纸）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/HsgGFj1eu3I6LmM.png" alt=""></p>
<h2 id="设置代理">设置代理</h2>
<ol>
<li class="lvl-3">
<p>安装clash for windows</p>
</li>
</ol>
<p>下载链接：<a href="https://github.com/Fndroid/clash_for_windows_pkg">https://github.com/Fndroid/clash_for_windows_pkg</a></p>
<p>选择<code>linux</code>版本的压缩包</p>
<p><img src="https://s2.loli.net/2023/05/11/p3aCmfMAWLU9Hni.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>运行clash</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd download #切换到下载目录</span><br><span class="line">sudo tar -zx Clash.for.Windows-0.17.1-x64-linux.tar.gz -C /opt #解压</span><br><span class="line">cd /opt</span><br><span class="line">sudo mv &#x27;Clash for Windows-0.17.1-x64-linux&#x27; clash  # 重命名</span><br><span class="line">cd clash</span><br><span class="line">./cfw  # run</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>配置clash</p>
</li>
</ol>
<p>clash导入订阅链接–&gt;开启代理（建议打开开机自启）</p>
<p><img src="https://s2.loli.net/2023/05/11/1QnjTCq4LlwOeyx.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>设置代理</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>终端添加环境变量</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 666 /etc/environment</span><br><span class="line">vi /etc/environment</span><br><span class="line"># 填入内容</span><br><span class="line">http_proxy=http://127.0.0.1:7890/</span><br><span class="line">https_proxy=http://127.0.0.1:7890/</span><br><span class="line">ftp_proxy=http://127.0.0.1:7890/</span><br><span class="line">HTTP_PROXY=http://127.0.0.1:7890/</span><br><span class="line">HTTPS_PROXY=http://127.0.0.1:7890/</span><br><span class="line">FTP_PROXY=http://127.0.0.1:7890/</span><br><span class="line"># 恢复原始状态</span><br><span class="line">sudo chmod 444 /etc/environment</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>或者：设置–&gt;网络–&gt;手动设置代理</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/XNFpfvIk95E3ire.png" alt=""></p>
<h2 id="克隆">克隆</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>右键点击虚拟机–&gt;管理–&gt;克隆</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/KDLpXHFaYlCncSm.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改克隆文件名</p>
</li>
</ul>
<p>修改如下克隆配置文件名字</p>
<p><img src="https://s2.loli.net/2023/05/11/rJDClkcfet8vRVZ.png" alt=""></p>
<p>打开<code>.vmx</code>文件，修改相应的值即可</p>
<p><img src="https://s2.loli.net/2023/05/11/WMFa1jY7kQ3dVue.png" alt=""></p>
<h2 id="优化">优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改导航栏位置</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/n8hEAt1fxYr2veP.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	ubuntu 禁止/取消系统自动更新的方法: <a href="https://blog.csdn.net/dacming/article/details/125164420">https://blog.csdn.net/dacming/article/details/125164420</a></p>
<p>[2] 	linux系统下修改只读【read-only】文件: <a href="https://blog.csdn.net/weixin_45677951/article/details/108746753">https://blog.csdn.net/weixin_45677951/article/details/108746753</a></p>
<p>[3]	ubuntu20.04 LTS安装谷歌拼音输入法: <a href="https://blog.csdn.net/kan2016/article/details/105735645">https://blog.csdn.net/kan2016/article/details/105735645</a></p>
<p>[4]	linux下使用clash(GUI): <a href="https://www.jianshu.com/p/02e3e8ccfe80">https://www.jianshu.com/p/02e3e8ccfe80</a></p>
<p>[5]	ubuntu启动栏导航栏放置到桌面底部、左侧: <a href="https://blog.csdn.net/lzp_k2/article/details/100089800">https://blog.csdn.net/lzp_k2/article/details/100089800</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter安装配置</title>
    <url>/archives/72216da9.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="安装">安装</h2>
<ol>
<li class="lvl-3">
<p><strong>conda安装</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Prompt</code>，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install jupyter notebook</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol start="2">
<li class="lvl-3">
<p><strong>navigator安装</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Navigator</code>，点击<code>Jupyter</code>下的 <code>Insatll</code></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509223656406.png" alt=""></p>
<h2 id="修改默认打开路径">修改默认打开路径</h2>
<ol>
<li class="lvl-3">
<p><strong>生成配置文件</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Prompt</code>，输入<code>jupyter notebook --generate-config</code></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/a6b56b88c868a12438d03169baed880.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p><strong>修改配置文件</strong></p>
<p>根据显示的路径，打开配置文件<code>jupyter_notebook_config.py</code>，全文搜索 <code>notebook_dir</code>，找到后填入自己的工作路径并保存。（注意：工作路径不能出现中文，否则无法打开<code>Jupyter Notebook</code>）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509223042167.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p><strong>修改JupyterNotebook快捷方式的目标属性</strong></p>
</li>
</ol>
<p>右击<code>JupyterNotebook</code>快捷方式，选择【属性】，删除【目标】属性中的【%USERPROFILE%】，点击【应用】–【确定】</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/7e5c619809d4324a7bfd40810834af3.png" alt=""></p>
<h2 id="优化">优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>主题切换</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># install jupyterthemes</span><br><span class="line">conda install -c conda-forge jupyterthemes</span><br><span class="line"># update to latest version</span><br><span class="line">conda update jupyterthemes</span><br><span class="line"></span><br><span class="line">jt -l # 加载可用主题列表</span><br><span class="line"># selecting a particular theme</span><br><span class="line">jt -t &lt;name of the theme&gt;</span><br><span class="line"># reverting to original Theme</span><br><span class="line">jt -r</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509225426973.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>插件安装</strong></p>
</li>
</ul>
<p>打开<code>Anaconda Prompt</code>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure>
<p>安装完点击<code>extensions</code>，勾选相应的功能即可</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509230915195.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	jupyter-contrib-nbextensions: <a href="https://pypi.org/project/jupyter-contrib-nbextensions/">https://pypi.org/project/jupyter-contrib-nbextensions/</a></p>
<p>[2]	jupyter-themes: <a href="https://github.com/dunovank/jupyter-themes">https://github.com/dunovank/jupyter-themes</a></p>
<p>[3]	Installing Jupyter: <a href="https://jupyter.org/install">https://jupyter.org/install</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>You-Get下载视频</title>
    <url>/archives/96ba4918.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><code>You-Get</code>是一款功能强大的开源命令行工具，可支持从多种网站下载视频、音频等媒体内容，包括流行的YouTube、Bilibili、优酷、爱奇艺等平台。不仅如此，它还能够下载各种在线流媒体、HLS、DASH、M3U8等格式的视频和音频。该工具简单易用，支持多种操作系统，如Windows、macOS和Linux等平台。使用者只需在终端输入指令，即可轻松将感兴趣的媒体下载到本地。<code>You-Get</code>还支持批量下载、断点续传等实用功能，非常适合在需要下载大量媒体内容的情况下使用。</p>
</blockquote>
<span id="more"></span>
<h2 id="配置">配置</h2>
<p><strong>安装 you-get</strong>（<em>装有python环境</em>：参考<a href="https://liuaoao.top/archives/eabeff19.html">Anaconda-Python环境安装</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install you-get  </span><br></pre></td></tr></table></figure>
<p><strong>安装 ffmpeg</strong>（合并音画必须）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>python: <code>pip install ffmpeg</code></p>
</li>
<li class="lvl-2">
<p>或者官网下载：<a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></p>
<ul class="lvl-2">
<li class="lvl-4">将<code>ffmpeg.exe</code>的上一层路径 <code>xxx\bin</code>填入环境变量（用户+系统的Path，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</li>
</ul>
</li>
<li class="lvl-2">
<p>检验是否安装成功<code>ffmpeg -version</code></p>
</li>
</ul>
<h2 id="下载命令">下载命令</h2>
<p><strong>视频信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get -i URL #提示如何下载不同比例不同格式文件</span><br><span class="line">- format:        dash-flv</span><br><span class="line">  container:     mp4</span><br><span class="line">  quality:       高清 1080P</span><br><span class="line">  size:          222.8 MiB (233636151 bytes)</span><br><span class="line"># download-with: you-get --format=dash-flv [URL]</span><br></pre></td></tr></table></figure>
<p><strong>单个视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get [URL]              #通过网址下载文件</span><br><span class="line">you-get -o 本地路径  [URL]   #更改本地下载目录，默认下载位置为当前powershell打开目录</span><br><span class="line">cd C:\                         #更改powershell目录</span><br></pre></td></tr></table></figure>
<p><strong>批量下载</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>playlist</code>可以使其按列表下载（批量下载的关键）</p>
</li>
<li class="lvl-2">
<p><code>format=dash-flv720</code>指定下载720P的flv视频</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看批量视频信息</span><br><span class="line">you-get --playlist -i https://www.bilibili.com/video/BV13t411G7oh</span><br><span class="line"># 下载</span><br><span class="line">you-get --playlist --format=dash-flv720 -o D:\SX https://www.bilibili.com/video/BV13t411G7oh</span><br></pre></td></tr></table></figure>
<h2 id="使用技巧">使用技巧</h2>
<ol>
<li class="lvl-3">
<p>使用代理加速（参考：<a href="https://liuaoao.top/archives/7b6d4a85.html">Windows代理设置</a>）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一次性关闭命令行需重新设置</span><br><span class="line">set http_proxy=http://127.0.0.1:1080</span><br><span class="line">set https_proxy=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>cookies请求</p>
</li>
</ol>
<p>一些视频可能需要会员才能下载，此时我们需要带cookies请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get --cookies=C:\Users\91425\Desktop\cookies.txt --format=dash-flv -o D:\SX https://www.bilibili.com/video/BV19h411s7oq </span><br><span class="line"># --cookies=C:\Users\91425\Desktop\cookies.txt 部分就是指定cookies的部分</span><br></pre></td></tr></table></figure>
<p><code>you-get</code>支持<code>Mozilla cookies.sqlite</code>和<code>Netscape</code>两种格式的<code>cookies</code>。前者可以使用火狐浏览器直接导出。后者在<code>Chromium</code>内核的浏览器上可以使用<code>Get cookies.txt</code>插件获取。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	记录一个you-get批量下载B站视频的方法: <a href="https://zhuanlan.zhihu.com/p/442019718">https://zhuanlan.zhihu.com/p/442019718</a></p>
<p>[2]	You-get在Windows系统下的安装+会员视频下载的cookie配置: <a href="https://blog.csdn.net/cwj1412/article/details/107775004">https://blog.csdn.net/cwj1412/article/details/107775004</a></p>
<p>[3]	you-get不自动合并音频和视频的解决办法: <a href="https://zhuanlan.zhihu.com/p/386392241">https://zhuanlan.zhihu.com/p/386392241</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-axis</title>
    <url>/archives/e3a284ef.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>在Python中，<code>axis</code>参数在许多库如NumPy、Pandas中是一个重要概念，它表示数据沿着哪个轴或维度进行操作。</p>
</blockquote>
<h2 id="NumPy">NumPy</h2>
<h3 id="np-array">np.array()</h3>
<p>对于一个二维数组（矩阵），<code>axis=0</code>表示操作沿着行（垂直方向），<code>axis=1</code>表示操作沿着列（水平方向）</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 3x3 的数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着 axis=0（行方向）求和</span></span><br><span class="line">sum_axis0 = np.<span class="built_in">sum</span>(arr, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 输出: array([12, 15, 18])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着 axis=1（列方向）求和</span></span><br><span class="line">sum_axis1 = np.<span class="built_in">sum</span>(arr, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输出: array([ 6, 15, 24])</span></span><br></pre></td></tr></table></figure>
<h3 id="np-concatenate-a1-a2-axis-0">np.concatenate(a1,a2 axis=0)</h3>
<p><code>np.concatenate</code>主要用于在指定轴上对多个数组进行拼接，拼接的轴的长度必须相同，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]) </span><br><span class="line"></span><br><span class="line">c = np.concatenate((a, b), axis=<span class="number">0</span>)</span><br><span class="line">d = np.concatenate((a, b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#[[1 2]</span></span><br><span class="line"><span class="comment"># [3 4]</span></span><br><span class="line"><span class="comment"># [5 6]</span></span><br><span class="line"><span class="comment"># [7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2 5 6]</span></span><br><span class="line"><span class="comment"># [3 4 7 8]]</span></span><br></pre></td></tr></table></figure>
<h3 id="np-append-arr-values-axis-None">np.append(arr, values, axis=None)</h3>
<p><code>np.append</code>是在数组的末尾添加元素，其使用方法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.append(arr, values, axis=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中，arr为原数组，values为需要添加的值，axis为需要添加的轴（如果不指定axis，则会将数组先展开成1D数组，再进行添加）。如果添加的值是一个数组，则会将数组在指定的轴上与原数组进行拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">c = np.append(a, b)  <span class="comment"># 在1D数组上进行拼接</span></span><br><span class="line">d = np.append(a, b, axis=<span class="number">0</span>)  <span class="comment"># 在行上进行拼接</span></span><br><span class="line">e = np.append(a, b, axis=<span class="number">1</span>)  <span class="comment"># 在列上进行拼接</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment">#[1 2 3 4 5 6 7 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2]</span></span><br><span class="line"><span class="comment"># [3 4]</span></span><br><span class="line"><span class="comment"># [5 6]</span></span><br><span class="line"><span class="comment"># [7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2 5 6]</span></span><br><span class="line"><span class="comment"># [3 4 7 8]]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>np.append</code>返回的是新的数组，不会改变原数组。在原始数据集比较大时，推荐使用<code>np.concatenate()</code>函数进行数组拼接。</p>
<h3 id="np-stack-array-axis-0">np.stack(array, axis=0)</h3>
<p>沿着新轴连接数组的序列，<mark>此方法与拼接不同</mark>。</p>
<p><em>axis</em> 参数指定新轴在结果尺寸中的索引。例如，如果<code>axis=0</code>，它将是第一个维度，如果<code>axis=-1</code>，它将是最后一个维度。</p>
<h4 id="一维数组">一维数组</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个一维数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴0方向连接这两个数组</span></span><br><span class="line">c = np.stack((a, b), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(c.shape)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (2,3)</span></span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴1方向连接这两个数组</span></span><br><span class="line">d = np.stack((a, b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(d.shape)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (3,2)</span></span><br><span class="line"><span class="comment"># [[1 4]</span></span><br><span class="line"><span class="comment">#  [2 5]</span></span><br><span class="line"><span class="comment">#  [3 6]]</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2"></label><code>(2,3)</code>和<code>(3,2)</code>中的<code>2</code>是怎么来的：因为有<code>a</code>和<code>b</code>两个<code>array</code>。</p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">可以理解</label><code>axis</code>指定了要增加的维度：例如<code>axis=0</code>表示在第一维度上增加，因此<code>(2,3)</code>中的<code>2</code>位于第一维度。而<code>axis=1</code>表示在第二维度上增加，因此<code>(3,2)</code>中的<code>2</code>位于第二维度。</p>
</li>
</ul>
<h4 id="二维数组">二维数组</h4>
<p>两个要素：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>stack堆叠的 <strong>方向</strong></p>
</li>
<li class="lvl-2">
<p>stack堆叠后增加的 <strong>维度</strong></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个2行3列的二维数组</span></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个2行3列的二维数组</span></span><br><span class="line">arr2 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴0方向连接这两个数组</span></span><br><span class="line">arr3 = np.stack((arr1, arr2), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr3 shape:<span class="subst">&#123;arr3.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># Arr3 shape:(2, 2, 3)</span></span><br><span class="line"><span class="comment"># [[[ 1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 4  5  6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 7  8  9]</span></span><br><span class="line"><span class="comment">#   [10 11 12]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴1方向连接这两个数组</span></span><br><span class="line">arr4 = np.stack((arr1, arr2), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr4 shape:<span class="subst">&#123;arr4.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr4)</span><br><span class="line"><span class="comment"># Arr4 shape:(2, 2, 3)</span></span><br><span class="line"><span class="comment"># [[[ 1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 7  8  9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 4  5  6]</span></span><br><span class="line"><span class="comment">#   [10 11 12]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴2方向连接这两个数组</span></span><br><span class="line">arr5 = np.stack((arr1, arr2), axis=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr5 shape:<span class="subst">&#123;arr5.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr5)</span><br><span class="line"><span class="comment"># Arr5 shape:(2, 3, 2)</span></span><br><span class="line"><span class="comment"># [[[ 1  7]</span></span><br><span class="line"><span class="comment">#   [ 2  8]</span></span><br><span class="line"><span class="comment">#   [ 3  9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 4 10]</span></span><br><span class="line"><span class="comment">#   [ 5 11]</span></span><br><span class="line"><span class="comment">#   [ 6 12]]]</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>2</code>就是指的<code>a</code>和<code>b</code>，而<code>2</code>放在什么位置是根据<code>axis</code>来确定的</p>
<h2 id="Pandas">Pandas</h2>
<p>在Pandas中，<code>axis</code>参数用于在<code>DataFrame</code>（类似于二维表格的数据结构）上执行操作，如汇总、排序和删除列或行等。与<code>NumPy</code>类似，<code>axis=0</code>表示操作沿着行（垂直方向），<code>axis=1</code>表示操作沿着列（水平方向）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="string">&#x27;C&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    A  B  C</span></span><br><span class="line"><span class="comment"># 0  1  4  7</span></span><br><span class="line"><span class="comment"># 1  2  5  8</span></span><br><span class="line"><span class="comment"># 2  3  6  9</span></span><br><span class="line"><span class="comment"># 删除名为 &#x27;A&#x27; 的列，沿着 axis=1（列方向）</span></span><br><span class="line">df = df.drop(<span class="string">&#x27;A&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    B  C</span></span><br><span class="line"><span class="comment"># 0  4  7</span></span><br><span class="line"><span class="comment"># 1  5  8</span></span><br><span class="line"><span class="comment"># 2  6  9</span></span><br><span class="line"><span class="comment"># 计算每一行的和，沿着 axis=1（列方向）</span></span><br><span class="line">row_sum = df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(row_sum)</span><br><span class="line"><span class="comment"># 0    11</span></span><br><span class="line"><span class="comment"># 1    13</span></span><br><span class="line"><span class="comment"># 2    15</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	numpy.stack最通俗的理解: <a href="https://blog.csdn.net/qq_17550379/article/details/78934529">https://blog.csdn.net/qq_17550379/article/details/78934529</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/archives/e8e79e61.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="hello-world开始">hello world开始</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>join()</mark> 函数：阻塞当前线程，直到关联的线程执行完毕。</p>
</li>
<li class="lvl-2">
<p><mark>detach()</mark> 函数：让一个线程在后台独立运行，不受主线程的控制，从而允许主线程提前退出而不必等待后台线程完成。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();       <span class="comment">// must add this line otherwise will failed!</span></span><br><span class="line">    <span class="comment">// 需要注意的是线程对象执行了join后就不再joinable了，所以只能调用join一次。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="Basic">Basic</h2>
<h3 id="悬空引用">悬空引用</h3>
<p>当 <strong>i</strong> 的生命周期结束时，<strong>func</strong> 对象中的引用 <strong>i</strong> 就变成了悬空引用，其指向的内存可能被其他程序占用或被释放，从而导致不可预测的错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="type">int</span> &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp;i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">do_something</span>(i);           <span class="comment">// 1. 潜在访问隐患：悬空引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="简洁机制">简洁机制</h4>
<p>保线程在函数结束之前安全退出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特殊情况下的等待</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//        do_something_in_current_thread();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try catch 只能捕获轻量级错误,所以如需确保线程在函数之前结束——查看是否因为线程函数使用了局部变量的引用，</span></span><br><span class="line"><span class="comment">// 以及其他原因——而后再确定一下程序可能会退出的途径，无论正常与否，可以提供一个简洁的机制，来做解决这个问题。</span></span><br></pre></td></tr></table></figure>
<h4 id="RAII">RAII</h4>
<p>一种方式是使用“资源获取即初始化方式 <strong>(RAII，Resource Acquisition Is Initialization)</strong>，并且提供一个类，在析构函数中使用join()，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::thread支持移动的好处是可以创建thread_guard类的实例，并且拥有其线程的所有权。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span> &#123;</span><br><span class="line">    std::thread &amp;t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread &amp;t_)</span> :</span></span><br><span class="line"><span class="function">            t(t_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">thread_guard</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) <span class="comment">// 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();      <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;   <span class="comment">// 3</span></span><br><span class="line">    thread_guard &amp;<span class="keyword">operator</span>=(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line"><span class="comment">//    do_something_in_current_thread();</span></span><br><span class="line">&#125;    <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 线程所关联的局部对象（即 my_func 的参数）的生命周期将在 thread_guard 对象之后结束，而不是在线程结束之后。当线程执行到4处时，局部对象就要被逆序销毁了。因此，thread_guard对象g是第一个被销毁的，</span></span><br><span class="line"><span class="comment">// 这时线程在析构函数中被加入2到原始线程中。</span></span><br><span class="line"><span class="comment">// 即使do_something_in_current_thread抛出一个异常，这个销毁依旧会发生。</span></span><br></pre></td></tr></table></figure>
<p>由于线程的管理得到了线程保护对象的管理，线程在程序结束时一定会被正确的处理，并且不会产生悬空的线程引用，保证了线程的安全退出.</p>
<h3 id="Most-Vexing-Parse">Most Vexing Parse</h3>
<p><strong>Most Vexing Parse</strong>：声明的对象被解析为一个函数声明而不是对象定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function">thread <span class="title">my_thread1</span><span class="params">(background_task())</span></span></span><br></pre></td></tr></table></figure>
<p>解决如下：</p>
<ol>
<li class="lvl-3">
<p>使用多组括号：这种方法可以告诉编译器我们正在声明一个对象，而不是一个函数。</p>
</li>
<li class="lvl-3">
<p>使用新的初始化语法：C<ins>11引入了C</ins>的新初始化语法，即使用花括号{}来初始化对象。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">thread <span class="title">my_thread1</span><span class="params">((background_task()))</span></span>; <span class="comment">// 使用多组括号</span></span><br><span class="line">my_thread1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">thread my_thread2&#123;<span class="built_in">background_task</span>()&#125;;   <span class="comment">// 使用新的初始化语法</span></span><br><span class="line">my_thread2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<h2 id="transfer">transfer</h2>
<p>这段代码演示了如何使用<code>std::thread</code>来创建新线程，并将类成员函数作为线程函数传递，同时也演示了如何使用<code>std::unique_ptr</code>来管理资源，并将这个资源传递给一个新线程。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>std::move(p)</code>: 左值转化为右值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_length_work</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_big_object</span><span class="params">(std::unique_ptr&lt;X&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X my_x;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(&amp;X::do_length_work, &amp;my_x)</span></span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;X&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> X)</span></span>;</span><br><span class="line">    p-&gt;<span class="built_in">do_length_work</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">tt</span><span class="params">(process_big_object,std::move(p))</span></span>;</span><br><span class="line">    <span class="comment">//std::thread实例的可移动且不可复制性。不可复制保性证了在同一时间点，</span></span><br><span class="line">    <span class="comment">// 一个std::thread实例只能关联一个执行线程；可移动性使得程序员可以自己决定，哪个实例拥有实际执行线程的所有权。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ownership">ownership</h2>
<h3 id="线程的创建、移动和管理">线程的创建、移动和管理</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; <span class="comment">// 构造一个thread对象t1</span></span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1); <span class="comment">// 把t1 move给另外一个thread对象t2，t1不再管理之前的线程了。</span></span><br><span class="line"><span class="comment">// 这句不需要std::move()，从临时变量进行移动是自动和隐式的。调用的是operator=(std::thread&amp;&amp;)</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function);</span><br><span class="line">std::thread t3;</span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2); <span class="comment">// 把t2 move给t3</span></span><br><span class="line"><span class="comment">// 把t3 move给t1，非法。因为`t1`已经有了一个相关的线程，会调用`std::terminate()`来终止程序。</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3);</span><br></pre></td></tr></table></figure>
<h3 id="一组线程">一组线程</h3>
<p>这段代码使用了<code>std::vector</code>和<code>std::thread</code>，它展示了如何使用C++11标准库来创建一组线程并等待它们完成工作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(<span class="type">unsigned</span> id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(do_work, i)); <span class="comment">// 产生线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(),</span><br><span class="line">                  std::<span class="built_in">mem_fn</span>(&amp;std::thread::join)); <span class="comment">// 对每个线程调用join()</span></span><br><span class="line">    <span class="comment">// &amp;std::thread::join获取的是std::thread::join成员函数的地址，将地址传递给std::mem_fn进行包装，从而将这个函数变成一个可调用对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RAII类scoped-thread">RAII类<code>scoped_thread</code></h3>
<p>这是一个RAII类<code>scoped_thread</code>的定义，它使用C++11标准库中的<code>std::thread</code>类来封装线程对象。具体来说，<code>scoped_thread</code>类通过重载构造函数和析构函数来控制线程的生命周期，从而确保线程在适当的时候被销毁。</p>
<p>在这个类的定义中，几个关键的实现细节：</p>
<ol>
<li class="lvl-3">
<p>使用<code>explicit</code>防止隐式类型转换。</p>
</li>
<li class="lvl-3">
<p>使用<code>std::logic_error</code>来抛出异常，以表示线程没有被启动的错误情况。</p>
</li>
<li class="lvl-3">
<p>在析构函数中调用<code>join()</code>函数，以确保线程在<code>scoped_thread</code>对象被销毁时能够正常结束。</p>
</li>
</ol>
<p>除此之外，由于线程对象的复制和复制赋值操作不可重载，因此需要通过<code>delete</code>关键字来禁止这些操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line">    std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span> :                 // <span class="number">1</span></span></span><br><span class="line"><span class="function">            t(std::move(t_)) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!t.<span class="built_in">joinable</span>())                                     <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;No thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">scoped_thread</span>() &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();                                            <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scoped_thread</span>(scoped_thread <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    scoped_thread &amp;<span class="keyword">operator</span>=(scoped_thread <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="runtime">runtime</h2>
<p>简单的线程池：将迭代器范围分割成多个子范围，每个子范围由一个线程进行处理，最后合并所有子范围的累加结果，从而实现了并行的累加操作。</p>
<p>在实现上，函数首先根据范围长度和硬件线程数，计算出要使用的线程数和任务块的大小。然后，函数将序列分块，并为每个块创建一个线程来执行累加操作。最后，使用<code>std::accumulate</code>将所有结果相加以得到最终结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使得每个线程具有最小数目的元素以避免过多的线程开销</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T &amp;result)</span> </span>&#123;</span><br><span class="line">        result = std::<span class="built_in">accumulate</span>(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumlate</span><span class="params">(Iterator first, Iterator last, T init)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">    cout&lt;&lt;max_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    cout&lt;&lt;hardware_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads = std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    cout&lt;&lt;num_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;</span><br><span class="line">    cout&lt;&lt;block_size&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(), block_start, block_end, std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">        <span class="comment">// std::ref用于将一个对象转化为一个引用</span></span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(block_start, last, results[num_threads - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// block_start到last无法划分为一个完整的块时，需要单独对这个子范围执行累加操作</span></span><br><span class="line">    std::for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), std::<span class="built_in">mem_fn</span>(&amp;std::thread::join));</span><br><span class="line">    <span class="comment">// std::mem_fn将一个成员函数指针转换为一个函数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">parallel_accumlate</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="id">id</h2>
<p>代码定义了两个函数<code>do_master_thread_work</code>和<code>do_common_work</code>，分别用于处理主线程和其他线程（即非主线程）的工作。在<code>some_core_part_of_algorithm</code>函数中，代码首先判断当前线程是否为主线程，如果是，则调用<code>do_master_thread_work</code>函数，否则调用<code>do_common_work</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的通用标识符</span></span><br><span class="line">std::thread::id master_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_master_thread_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;master&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_common_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;common&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::this_thread::<span class="built_in">get_id</span>() == master_thread) &#123;</span><br><span class="line">        <span class="built_in">do_master_thread_work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">do_common_work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    master_thread = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;master_thread: &quot;</span> &lt;&lt; master_thread &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;master_thread 中运行:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">some_core_part_of_algorithm</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread 中运行:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(some_core_part_of_algorithm)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 那些事: <a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Pr2020基础总结</title>
    <url>/archives/7eda6880.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><strong>安装</strong>：参考 <mark>软件管家</mark> 公众号(<a href="https://mp.weixin.qq.com/s/TC44SwDnZI2k1XsdCEBoyA">https://mp.weixin.qq.com/s/TC44SwDnZI2k1XsdCEBoyA</a>)，推荐2020及以上版本</p>
<p><u>注意GPU渲染出现预览黑屏，掉帧，导出渲染失败，cpu拉满独显不工作等问题，需更新驱动或Pr版本</u></p>
<ol>
<li class="lvl-3">
<p><strong>更新驱动</strong>为最新版本（参考：<a href="https://liuaoao.top/archives/2888cf0.html">Ps2019总结</a>）</p>
</li>
<li class="lvl-3">
<p>更新驱动未解决，<strong>更新Pr</strong>为2020或更高</p>
</li>
</ol>
</blockquote>
<span id="more"></span>
<h3 id="项目">项目</h3>
<p>新建：Ctrl+Alt+N</p>
<p>打开：Ctrl+O</p>
<h2 id="基本操作">基本操作</h2>
<p>工具栏快捷键: <mark>Alt + 相应字母</mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">移动</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Pr</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode安装配置</title>
    <url>/archives/fe901771.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>安装：官网下载即可（<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>），安装时一般 <strong>把path添加到环境变量</strong></p>
<p><u>因为VSCode可以同步设置，重点写一下无法同步的的设置</u></p>
</blockquote>
<h2 id="主题、字体、插件">主题、字体、插件</h2>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504200256615.png" alt=""></p>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504200520492.png" alt=""></p>
<h2 id="配置C-1">配置C++<sup>[1]</sup></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>安装 C++ 插件</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/e1311c50b41c19263e0b72ca0e79cf2.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>安装编译调试环境</strong></p>
</li>
</ul>
<p>Windows 系统 按照下面步骤配置</p>
<ol>
<li class="lvl-3">
<p>下载安装 mingw-w64：<a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a></p>
</li>
<li class="lvl-3">
<p>直接将 mingw-w64 解压到一个合适的目录（例如C:\Program Files下）</p>
</li>
<li class="lvl-3">
<p>添加上****mingw-w64\bin**个文件夹的路径（用户+系统，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/e66b9612b8c5eaba62dae5366029335.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>打开powershell/cmd， 输入 <strong>gcc -v</strong> , 看到版本说明环境变量配置成功</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>配置VS Code调试环境</strong></p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>新建 <strong>CPP\ .vscode</strong> 文件夹</p>
</li>
<li class="lvl-3">
<p>在 .vscode 文件夹中，依次新建文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c_cpp_properties.<span class="property">json</span></span><br><span class="line">launch.<span class="property">json</span></span><br><span class="line">tasks.<span class="property">json</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>复制内容到 json文件</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>launch.json</mark>中：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>“miDebuggerPath”: 后面修改为你的 mingw64 路径</strong></li>
<li class="lvl-4">“preLaunchTask”: “task g++”** 和 <strong>tasks.json</strong> 中的 <strong>“label”: “task g++”</strong> 引号中的名字要一致，本代码中为 <strong>task g++</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// launch.json 配置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line"><span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line"><span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,<span class="comment">//配置类型，只能为cppdbg</span></span><br><span class="line"><span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,<span class="comment">//请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="comment">//调试程序的路径名称</span></span><br><span class="line"><span class="string">&quot;args&quot;</span>: [],<span class="comment">//调试传递参数</span></span><br><span class="line"><span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//true显示外置的控制台窗口，false显示内置终端</span></span><br><span class="line"><span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line"><span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\mingw64\\bin\\gdb.exe&quot;</span>, </span><br><span class="line"><span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line"><span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line"><span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;task g++&quot;</span>,<span class="comment">//调试前执行的任务，就是之前配置的tasks.json中的label字段</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tasks.json 配置文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class="line"><span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line"><span class="string">&quot;label&quot;</span>: <span class="string">&quot;task g++&quot;</span>,<span class="comment">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class="line"><span class="string">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>,</span><br><span class="line"><span class="string">&quot;args&quot;</span>: [<span class="comment">//编译时候的参数</span></span><br><span class="line"><span class="string">&quot;-g&quot;</span>,<span class="comment">//添加gdb调试选项</span></span><br><span class="line"><span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,<span class="comment">//指定生成可执行文件的名称</span></span><br><span class="line"><span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;owner&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line"><span class="string">&quot;fileLocation&quot;</span>: [</span><br><span class="line"><span class="string">&quot;relative&quot;</span>,</span><br><span class="line"><span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;pattern&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;regexp&quot;</span>: <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span>,</span><br><span class="line"><span class="string">&quot;file&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">&quot;column&quot;</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">&quot;severity&quot;</span>: <span class="number">4</span>,</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line"><span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span><span class="comment">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c_cpp_properties.json 配置文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;Win32&quot;</span>,</span><br><span class="line"><span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line"><span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;defines&quot;</span>: [</span><br><span class="line"><span class="string">&quot;_DEBUG&quot;</span>,</span><br><span class="line"><span class="string">&quot;UNICODE&quot;</span>,</span><br><span class="line"><span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;C:/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line"><span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c11&quot;</span>,</span><br><span class="line"><span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-4">
<p>配置完上面，vscode就可以正常调试了</p>
</li>
</ol>
<h2 id="优化配置">优化配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序文件路径不要有 <strong>中文</strong>，否则会导致 <strong>调试失败</strong></p>
</li>
<li class="lvl-2">
<p>Vscode设置保留在单文件夹中，如果要更换文件夹，请把 <strong>.vscode</strong> 文件夹也复制到你要更改的文件夹中</p>
</li>
<li class="lvl-2">
<p>中文显示乱码问题 VScode 编码设置/文件乱码</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">点击文件-&gt;首选项-&gt;设置，然后在右边用户设置输入：<strong>“files.autoGuessEncoding”: true</strong></li>
<li class="lvl-4">插入这一行内用并保存。</li>
<li class="lvl-4">或者如下图打钩：</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/165f67da7eb2ba912d58cd6d6e712fa.png" alt=""></p>
<p>加入这个设置后，VSCode会在打开文件时尝试猜测字符集编码。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>VsCode内部终端运行代码</p>
</li>
</ul>
<p>设置在终端运行 : 首选项 -&gt; 设置 -&gt; 扩展 -&gt; Run Code ，勾选 <strong>Run In Terminal</strong> 和 <strong>Save File Before Run</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/f35d61b71af8ed28acf99d20e644c2e.png" alt=""></p>
<p>后记：投降了，Linux我用Clion，看<a href="">Linux配置C++</a></p>
<h2 id="Reference">Reference</h2>
<p>[1]	VSCode配置C++开发环境（MinGW-w64）: <a href="https://juejin.cn/post/7170216201849667621">https://juejin.cn/post/7170216201849667621</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm安装配置</title>
    <url>/archives/c545af56.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>PyCharm专业版是功能最丰富的，与社区版相比，PyCharm 业版增加了Web开发、Python We框架、Python分析器、远程开发、支持数据库与SQL等更多高级功能。</p>
<p>PyCharm的社区版中没有Web开发、Python We框架、Python分析器、远程开发、支持数据库与SQL等这些功能。</p>
<p>PyCharm教育版的功能虽然比专业版会少一些，但与社区版相比，更加支持学校的教学工作。</p>
</blockquote>
<span id="more"></span>
<h2 id="PyCharm专业版安装">PyCharm专业版安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>参考 <mark>软件管家</mark>公众号，或点击：<a href="https://mp.weixin.qq.com/s/V2Ls-lcnymD9_ZullCh_fg">https://mp.weixin.qq.com/s/V2Ls-lcnymD9_ZullCh_fg</a></p>
</li>
</ul>
<h2 id="主题字体配置">主题字体配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>外观（先安装主题插件Material theme）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504191917951.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>代码字体</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504191946833.png" alt=""></p>
<h2 id="插件配置">插件配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CodeGlance</strong>: 代码缩略图</p>
</li>
<li class="lvl-2">
<p><strong>IdeaVim</strong>: 在IDE中使用Vim编辑器的功能</p>
</li>
<li class="lvl-2">
<p><strong>Key Promoter X</strong>: 自动提示快捷键</p>
</li>
<li class="lvl-2">
<p><strong>Material Theme</strong>: 修改主题</p>
</li>
<li class="lvl-2">
<p><strong>RestfulToolkitX</strong>： 供了一组用于构建 RESTful API 的工具和方法</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504192054149.png" alt=""></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX安装</title>
    <url>/archives/88b90715.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>LaTeX是一种专业的排版系统和标记语言，用于创建高质量的文档，尤其适合包含数学公式、技术内容和复杂结构的文档，如学术论文、书籍、报告、简历等。TeX Live是一款跨平台的LaTeX发行版，它包含了LaTeX编译器、宏包、字体和各种工具，适用于多种操作系统，如Windows、Linux和macOS。TeXstudio是一款免费开源的LaTeX编辑器。</p>
<p>WIindows推荐： <mark>Texlive 2023 + TeX studio</mark></p>
</blockquote>
<span id="more"></span>
<h2 id="Texlive-2023">Texlive 2023</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>ISO 映像下载：<a href="https://www.tug.org/texlive/acquire-iso.html">https://www.tug.org/texlive/acquire-iso.html</a></p>
</li>
</ul>
<p><strong>打开下载后的.ISO文件，以管理员身份运行install-tl-windows.bat文件。</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/explorer_vgFd0Lbe70.png" alt=""></p>
<p><strong>修改安装位置</strong></p>
<p><strong>选择安装语言</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>高级选项里 <mark>Advanced</mark> $\rightarrow$点击 <mark>Customize</mark> $\rightarrow$选择 <mark>中文和英文</mark></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/20230502111347.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/wish_PhEbgdUYiI.png" alt=""></p>
<p><strong>确定安装，等待安装完成后关闭窗口</strong></p>
<hr>
<h3 id="Texlive添加环境变量">Texlive添加环境变量</h3>
<p>添加Texlive环境变量，以在命令行中执行tex的命令</p>
<ol>
<li class="lvl-3">
<p>win+R 然后输入**sysdm.cpl **在高级中选择<em>环境变量</em></p>
</li>
<li class="lvl-3">
<p>编辑的Path变量（建议<u>用户和系统</u>的Path都添加），添加txtlive中的<mark>bin/windows</mark>路径（如：D:\Software\texlive\2023\bin\windows）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/SystemPropertiesAdvanced_iXSckGIh1W.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>查看验证安装版本（出现 <mark>版本号</mark> 则成功）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tex -v</span><br><span class="line">latex -v</span><br><span class="line">xelatex -v</span><br><span class="line">pdflatex -v</span><br></pre></td></tr></table></figure>
<h2 id="TeXstudio的安装">TeXstudio的安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>官网下载：<a href="https://texstudio.sourceforge.net/">https://texstudio.sourceforge.net/</a></p>
</li>
</ul>
<p><strong>双击安装$\rightarrow$修改安装位置即可</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/texstudio-4.5.2-win-qt6_5StfAN4gxi.png" alt=""></p>
<p><strong>使用注意</strong>：<em>如果撰写中文论文，将默认编译器改为<code>Xelatex</code>。如果撰写英文论文，将默认编译器改为<code>Pdflatex</code></em></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/texstudio_xkx0Bq0fS9.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	LaTeX的安装教程：<a href="https://blog.csdn.net/weixin_43872190/article/details/113736283">https://blog.csdn.net/weixin_43872190/article/details/113736283</a><br>
[2]	Latex（一）安装和环境变量的设置：<a href="https://blog.csdn.net/explorer9607/article/details/103506387">https://blog.csdn.net/explorer9607/article/details/103506387</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Ps2019基础总结</title>
    <url>/archives/2888cf0.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><strong>安装</strong>：参考 <mark>软件管家</mark> 公众号(<a href="https://mp.weixin.qq.com/s/jUEyqVY8RrU2RB_mlPlKDQ">https://mp.weixin.qq.com/s/jUEyqVY8RrU2RB_mlPlKDQ</a>)，推荐2019及以上版本</p>
<p><u>注意：电脑出现蓝屏自动重启情况，是显卡驱动问题，需更新到最新版</u></p>
<p>推荐使用<strong>GeForce Experience</strong>更新<strong>Studio</strong>（3D工作流畅）最新驱动</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504091325087.png" alt=""></p>
</blockquote>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<p><strong>色相、饱和度和亮度</strong> 是 <mark>颜色</mark> 的三个基本属性，通常缩写为HSL。它们是用于描述颜色的一种常见方式，特别是在计算机图形学和设计中。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>色相（Hue）：指颜色的基本色调，如红色、绿色、蓝色等。色相可以用一个0到360度的角度值来表示，其中0度表示红色，120度表示绿色，240度表示蓝色。</p>
</li>
<li class="lvl-2">
<p>饱和度（Saturation）：指颜色的纯度或强度，即颜色中灰色成分的比例。饱和度越高，颜色越鲜艳，越接近于纯色。饱和度可以用一个0到100%的值来表示，其中0%表示灰色，100%表示纯色。</p>
</li>
<li class="lvl-2">
<p>亮度（Lightness）：指颜色的明暗程度，即颜色中黑色成分的比例。亮度可以用一个0到100%的值来表示，其中0%表示黑色，100%表示白色。</p>
</li>
</ul>
<p><mark>图像</mark> 中最基本的概念除 <strong>颜色</strong> 之外,还包括:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对比度:指图像中明暗度的差异,对比度大意味着同一图像中的亮度差异较大,对比度小则差异较小。对比度直接影响图像的清晰度和层次感。</p>
</li>
<li class="lvl-2">
<p>纹理:指图像中像素在空间方向的变化模式。纹理为图像提供了粗糙或平滑的视觉感觉,丰富了图像的内容。</p>
</li>
<li class="lvl-2">
<p>空间频率:指图像中视觉模式的重复频率,它控制了图像中的细节程度。高频图像具有更多细节,低频图像则较为平滑。</p>
</li>
</ul>
<h2 id="新建文档">新建文档</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>Ctrl + N</mark></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">像素</th>
<th>分辨率</th>
<th>颜色模式</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">打印</td>
<td>300</td>
<td>CMYK</td>
<td>cm</td>
</tr>
<tr>
<td style="text-align:left">显示</td>
<td>72</td>
<td>RGB</td>
<td>像素</td>
</tr>
</tbody>
</table>
<p><em>背景透明的显示：灰白格子</em></p>
<h3 id="文件打开">文件打开</h3>
<ol>
<li class="lvl-3">
<p><mark>Ctrl+O</mark> 打开文件（<strong>Ctrl</strong>：点选 <strong>Shift</strong>：连选）</p>
</li>
<li class="lvl-3">
<p>资源管理器$\rightarrow$拖拽文件</p>
</li>
</ol>
<h3 id="文件查看">文件查看</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>窗口$\rightarrow$排列</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/Photoshop_cmHe5yK04V.png" alt=""></p>
<h3 id="文件保存">文件保存</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>Ctrl+Shift+S</mark></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">保持背景透明保存为PNG</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">保存为GIF：文件$\rightarrow$导出$\rightarrow$存储为web格式（格式选为GIF）</label></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/%25E5%259B%25BE%25E5%2583%258F%25E6%25A0%25BC%25E5%25BC%258F.jpg" alt=""></p>
<h2 id="基本操作">基本操作</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>工具栏快捷键: <mark>Alt + 相应字母</mark></p>
</li>
<li class="lvl-2">
<p>右键点击工具$\rightarrow$工具切换</p>
</li>
<li class="lvl-2">
<p>打开滚轮缩放（编辑$\rightarrow$首选项$\rightarrow$工具$\rightarrow$滚轮缩放）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">移动</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">画笔</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">旋转</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td style="text-align:center">缩放</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">选框</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">裁剪</td>
</tr>
<tr>
<td style="text-align:center">Alt</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">Shift + 相应字母</td>
<td style="text-align:center">同类型工具切换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + <code>+-</code></td>
<td style="text-align:center">缩放</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Z</td>
<td style="text-align:center">撤回</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift+ Z</td>
<td style="text-align:center">前进</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + J</td>
<td style="text-align:center">复制图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift+ N</td>
<td style="text-align:center">新建图层</td>
</tr>
<tr>
<td style="text-align:center">Delete</td>
<td style="text-align:center">删除图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + E</td>
<td style="text-align:center">合并图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  E</td>
<td style="text-align:center">合并可见图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + [</td>
<td style="text-align:center">图层下移</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + ]</td>
<td style="text-align:center">图层上移</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  [</td>
<td style="text-align:center">下移最底</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  ]</td>
<td style="text-align:center">上移最顶</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + G</td>
<td style="text-align:center">新建组</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + T</td>
<td style="text-align:center">自由变换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +T</td>
<td style="text-align:center">再次变换</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Ps</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown进阶</title>
    <url>/archives/97cdff40.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>Markdown是一种轻量级标记语言，旨在提供一个易于学习和使用的文本到HTML转换工具。它提供了标题、列表、代码块、链接等简单的标记和语法，使文本排版更加简单、清晰和易读。现在，许多平台都支持Markdown，包括GitHub、Stack Overflow和Reddit。掌握Markdown是非常有用的，具体参考<a href="https://liuaoao.top/archives/1ef37645.html">Markdown-For-Typora</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="常用查表">常用查表</h2>
<table>
<thead>
<tr>
<th style="text-align:center">样式名</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">转义</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">加粗</td>
<td style="text-align:center"><code>**文本**</code> 或 <code>__文本__</code></td>
</tr>
<tr>
<td style="text-align:center">斜体</td>
<td style="text-align:center"><code>*文本*</code> 或 <code>_文本_</code></td>
</tr>
<tr>
<td style="text-align:center">删除线</td>
<td style="text-align:center"><code>~~文本~~</code></td>
</tr>
<tr>
<td style="text-align:center">下划线</td>
<td style="text-align:center"><code>&lt;u&gt;文本&lt;/u&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">上标</td>
<td style="text-align:center"><code>文本^上标^</code></td>
</tr>
<tr>
<td style="text-align:center">下标</td>
<td style="text-align:center"><code>文本~下标~</code></td>
</tr>
<tr>
<td style="text-align:center">小号字体</td>
<td style="text-align:center"><code>&lt;small&gt;小号字体&lt;/small&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">大号字体</td>
<td style="text-align:center"><code>&lt;big&gt;大号字体&lt;/big&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">高亮</td>
<td style="text-align:center"><code>==文本==</code></td>
</tr>
<tr>
<td style="text-align:center">代码块</td>
<td style="text-align:center">`代码` 或 ```代码```</td>
</tr>
<tr>
<td style="text-align:center">链接</td>
<td style="text-align:center"><code>[链接文本](链接地址)</code></td>
</tr>
<tr>
<td style="text-align:center">图片</td>
<td style="text-align:center"><code>![图片替代文本](图片链接地址)</code></td>
</tr>
<tr>
<td style="text-align:center">引用</td>
<td style="text-align:center">&gt; 引用内容</td>
</tr>
<tr>
<td style="text-align:center">分割线</td>
<td style="text-align:center">— 或 ***</td>
</tr>
<tr>
<td style="text-align:center">数学公式</td>
<td style="text-align:center"><code>$$LaTex$$</code></td>
</tr>
</tbody>
</table>
<h2 id="箭头">箭头</h2>
<p><strong>基本箭头</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\uparrow$</td>
<td style="text-align:center"><code>$\uparrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\downarrow$</td>
<td style="text-align:center"><code>$\downarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\leftarrow$</td>
<td style="text-align:center"><code>$\leftarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\rightarrow$</td>
<td style="text-align:center"><code>$\rightarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\updownarrow$</td>
<td style="text-align:center"><code>$\updownarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\leftrightarrow$</td>
<td style="text-align:center"><code>$\leftrightarro$</code></td>
</tr>
</tbody>
</table>
<p><strong>双线箭头</strong>：基本箭头<mark>首字母大写</mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">双线箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\Uparrow$</td>
<td style="text-align:center"><code>$\Uparrow$</code></td>
</tr>
</tbody>
</table>
<p><strong>长箭头</strong>：基本箭头前+<mark>long</mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">长箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\longrightarrow$</td>
<td style="text-align:center"><code>$\longrightarrow$</code></td>
</tr>
</tbody>
</table>
<hr>
<p>继续更新ing😄</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows终端代理</title>
    <url>/archives/7b6d4a85.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="CMD">CMD</h2>
<h3 id="临时生效">临时生效</h3>
<p>命令行窗口关闭就失效</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置</span><br><span class="line">set http_proxy=http://127.0.0.1:7890</span><br><span class="line">set https_proxy=http://127.0.0.1:7890</span><br><span class="line"># 如需账户、密码</span><br><span class="line">set http_proxy_user=username</span><br><span class="line">set http_proxy_pass=password</span><br><span class="line"># 查看</span><br><span class="line">set http_proxy</span><br><span class="line">set https_proxy</span><br><span class="line"># 取消</span><br><span class="line">set http_proxy=</span><br><span class="line">set https_proxy=</span><br><span class="line">set http_proxy_user=</span><br><span class="line">set http_proxy_pass=</span><br></pre></td></tr></table></figure>
<h3 id="永久生效">永久生效</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加如下环境变量（右键我的电脑-&gt; 属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">http_proxy</td>
<td style="text-align:center"><code> http://127.0.0.1:7890</code></td>
</tr>
<tr>
<td style="text-align:center">https_proxy</td>
<td style="text-align:center"><code> http://127.0.0.1:7890</code></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/c68f9ab677f3436d8a02a8a847329137.png" alt=""></p>
<h3 id="常用快捷键">常用快捷键</h3>
<p>有的需要右键–&gt;编辑模式–&gt;开启复制粘贴</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + a</td>
<td>将光标移到行首</td>
</tr>
<tr>
<td>Ctrl + e</td>
<td>将光标移到末尾</td>
</tr>
<tr>
<td>Ctrl + u</td>
<td>删除整行</td>
</tr>
<tr>
<td>Ctrl + k</td>
<td>向后删除，从光标开始直至行尾</td>
</tr>
<tr>
<td>Alt + Backspace</td>
<td>光标向前删除一个单词</td>
</tr>
<tr>
<td>Alt + f</td>
<td>将光标移动到后一个单词</td>
</tr>
<tr>
<td>Alt + b</td>
<td>将光标移动到前一个单词</td>
</tr>
<tr>
<td>Ctrl + p</td>
<td>上一条命令</td>
</tr>
<tr>
<td>Ctrl + n</td>
<td>下一条命令</td>
</tr>
</tbody>
</table>
<h2 id="Git（永久生效）">Git（永久生效）</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 设施全局代理</span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line"># 查看代理</span><br><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br><span class="line"># 取消全局代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>重启<code>cmd</code>命令行，使用 <code>curl www.google.com</code> ，如果有内容返回，说明设置成功（不可以是 <code>ping</code> 命令进行测试）</p>
<h2 id="Reference">Reference</h2>
<p>[1]	windows设置和删除代理: <a href="https://liuxingjun.github.io/blog/2018/05/03/windows%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%88%A0%E9%99%A4%E4%BB%A3%E7%90%86">https://liuxingjun.github.io/blog/2018/05/03/windows设置和删除代理</a></p>
<p>[2]	git设置、查看、取消代理: <a href="https://www.cnblogs.com/yongy1030/p/11699086.html">https://www.cnblogs.com/yongy1030/p/11699086.html</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>CMD</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown-For-Typora</title>
    <url>/archives/1ef37645.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Overview">Overview</h2>
<p><strong>Markdown</strong> is created by <a href="http://daringfireball.net/">Daring Fireball</a>; the original guideline is <a href="http://daringfireball.net/projects/markdown/syntax">here</a>. Its syntax, however, varies between different parsers or editors. <strong>Typora</strong> is using <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a>.</p>
<span id="more"></span>
<h2 id="Block-Elements">Block Elements</h2>
<h3 id="Paragraph-and-line-breaks">Paragraph and line breaks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.按一次&quot;return&quot;即可创建新段落</span><br><span class="line">2.按&quot;shift&quot;+&quot;return&quot;以创建单行中断。大多数其他减值解析器将忽略单行中断，因此，为了让其他减值解析器识别您的线路中断，您可以在行的末尾留出两个空格，或插入&quot;<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>&quot;。</span><br></pre></td></tr></table></figure>
<h3 id="Headers">Headers</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">标题在行的开头使用 1-6 个哈希字符（&#x27;#&#x27;），对应于标题级别 1-6。</span><br><span class="line">例如：</span><br><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure>
<h3 id="Blockquotes">Blockquotes</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Markdown 使用电子邮件式&gt;字符进行阻止引用。它们被呈现为:</span><br><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. This is first paragraph.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; This is second pragraph. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote.</span></span><br><span class="line"></span><br><span class="line">在 Typora 中，输入&quot;&gt;&quot;，然后输入您的报价内容将生成报价块。Typora 将为您插入适当的&quot;&gt;&quot;或线路中断。嵌套块报价（另一个区块报价中的块报价），通过添加额外的&quot;&gt;&quot;级别。</span><br></pre></td></tr></table></figure>
<h3 id="Lists">Lists</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">输入&quot;* 列表项目 &quot; 将创建一个未排序的列表 -&quot;<span class="emphasis">*&quot;符号可以替换为&quot;+&quot;或&quot;-&quot;。   输入 &#x27;1.列表项目 &#x27; 将创建一个订单列表 - 其标记源代码如下：</span></span><br><span class="line"><span class="emphasis">## un-ordered list</span></span><br><span class="line"><span class="emphasis">*</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">*</span>   Blue</span><br><span class="line"></span><br><span class="line"><span class="section">## ordered list</span></span><br><span class="line"><span class="bullet">1.</span>  Red</span><br><span class="line"><span class="bullet">2.</span> 	Green</span><br><span class="line"><span class="bullet">3.</span>	Blue</span><br></pre></td></tr></table></figure>
<h3 id="Task-List">Task List</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">任务列表是标有 [] 或 [x] （不完整或已完成） 的项目列表。例如：</span><br><span class="line"><span class="bullet">-</span> [ ] a task list item</span><br><span class="line"><span class="bullet">-</span> [ ] list syntax required</span><br><span class="line"><span class="bullet">-</span> [ ] normal <span class="strong">**formatting**</span>, @mentions, #1234 refs</span><br><span class="line"><span class="bullet">-</span> [ ] incomplete</span><br><span class="line"><span class="bullet">-</span> [x] completed</span><br></pre></td></tr></table></figure>
<h3 id="Fenced-Code-Blocks">(Fenced) Code Blocks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Typora 只支持 fences in GitHub Flavored Markdown。不支持 Markdown 中的原始代码块。   使用 fences 很容易：输入<span class="code">```和按 &#x27;return&#x27;。在```</span>之后添加可选语言标识符，我们将通过语法加亮来运行它：</span><br><span class="line">Here&#x27;s an example:</span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">function test() &#123;</span></span><br><span class="line"><span class="code">  console.log(&quot;notice the blank line before this function?&quot;);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">syntax highlighting:</span><br><span class="line"><span class="code">```ruby</span></span><br><span class="line"><span class="code">require &#x27;redcarpet&#x27;</span></span><br><span class="line"><span class="code">markdown = Redcarpet.new(&quot;Hello World!&quot;)</span></span><br><span class="line"><span class="code">puts markdown.to_html</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>
<h3 id="Math-Blocks">Math Blocks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">您可以使用<span class="strong">**MathJax**</span>来渲染[LaTeX]数学表达式。</span><br><span class="line">要添加数学表达，输入&quot;$$&quot;并按&quot;return&quot;键。这将触发一个接受 <span class="emphasis">*Tex/LaTex*</span> 源的输入字段。例如：</span><br></pre></td></tr></table></figure>
<p>$$<br>
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>
\end{vmatrix}<br>
$$</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">In the markdown source file, the math block is a <span class="emphasis">*LaTeX*</span> expression wrapped by a pair of ‘$$’ marks:</span><br><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;<span class="emphasis">_1 \times \mathbf&#123;V&#125;_</span>2 =  \begin&#123;vmatrix&#125;</span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Tables">Tables</h3>
<p>输入<code>| First Header  | Second Header |</code> &quot;并按<code>&quot;return&quot;</code>键。这将创建一个带有两列的表。   创建表后，将焦点放在该表上将打开表的工具栏，您可以调整表大小、对齐或删除表。您还可以使用上下文菜单复制和添加/删除单个列/行。   表的完整语法如下所述，但无需详细了解完整的语法，因为表的标记源代码由 Typora 自动生成。</p>
<p>在 markdown 源代码中，它们看起来像：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure>
<p>您还可以在表中包含 inline Markdown 标记，如链接、粗体、斜体或删除线（links, bold, italics, or strikethrough）。</p>
<p>最后，通过在头行中包含冒号  (<code>:</code>)，您可以将该列中的文本定义为左对齐、右对齐或中对齐：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure>
<p>最左边的冒号表示左对齐的列；最右边的冒号表示列是右对齐的；两边的冒号表示是中心对齐的列。</p>
<h3 id="Footnotes">Footnotes</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You can create footnotes like this[^footnote].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^footnote</span>]: <span class="link">Here is the *text* of the **footnote**.</span></span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>You can create footnotes like this<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p>
<p>将鼠标悬停在“脚注”上标上，可以查看脚注的内容。</p>
<h3 id="Horizontal-Rules">Horizontal Rules</h3>
<p>在空行输入 <code>***</code> 或 <code>---</code>，并按 <code>return</code> 将画出一条水平线。</p>
<h3 id="YAML-Front-Matter">YAML Front Matter</h3>
<p>Typora 现在支持<a href="http://jekyllrb.com/docs/frontmatter/">YAML Front Matter</a>。在文章的顶部输入<code>---</code>，然后按 <code>Return</code> 引入元数据块。或者，您可以从 Typora 的顶部菜单中插入元数据块。</p>
<h3 id="Table-of-Contents-TOC">Table of Contents(TOC)</h3>
<p>输入<code>[toc]</code>并按<code>Return</code>键。这将创建一个“目录”部分。TOC从文档中提取所有标题，当您添加到文档时，它的内容会自动更新。</p>
<h2 id="Span-Elements">Span Elements</h2>
<p>Span元素将在输入后立即被解析和呈现。将光标移动到这些span元素的中间会将这些元素展开为markdown源。下面是每个span元素的语法解释</p>
<h3 id="Links">Links</h3>
<p>Markdown支持两种样式的链接:内联和引用。</p>
<p>在这两种样式中，链接文本由 [方括号] 分隔。</p>
<p>要创建内联链接，请在链接文本的右方括号后立即使用一组规则括号。在圆括号内，将URL放置在您希望链接指向的位置，并为链接提供一个可选的标题，用引号括起来。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>](<span class="link">http://example.com/ &quot;Title&quot;</span>) inline link.</span><br><span class="line"></span><br><span class="line">[<span class="string">This link</span>](<span class="link">http://example.net/</span>) has no title attribute.</span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>This is <a href="http://example.com/" title="Title">an example</a> inline link. (<code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</code>)</p>
<p><a href="http://example.net/">This link</a> has no title attribute… (<code>&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</code>)</p>
<h4 id="Internal-Links">Internal Links</h4>
<p><strong>您可以将 href 设置为headers</strong>，这将创建一个书签，允许您单击后跳转到该部分。</p>
<p>例如: 命令(在Windows上:Ctrl) +单击此 <a href="#block-elements">This link</a> 将跳转到标题块元素。要查看如何编写，请移动光标或按下⌘键单击该链接以将元素展开为 markdown 源。</p>
<h4 id="Reference-Links">Reference Links</h4>
<p>参考样式的链接使用第二组方括号，在里面你可以选择一个标签来标识链接:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>][<span class="symbol">id</span>] reference-style link.</span><br><span class="line"></span><br><span class="line">Then, anywhere in the document, you define your link label on a line by itself like this:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">id</span>]: <span class="link">http://example.com/  &quot;Optional Title Here&quot;</span></span><br></pre></td></tr></table></figure>
<p>will produce</p>
<p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p>
<p>Then, anywhere in the document, you define your link label on a line by itself like this:</p>
<p>隐式链接名称快捷方式允许您省略链接的名称，在这种情况下链接文本本身将用作名称。只需使用一组空的方括号-例如，链接单词“Google”到 <a href="http://google.com">google.com</a> 网站，你可以简单地写:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol"></span>]</span><br><span class="line">And then define the link:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">Google</span>]: <span class="link">http://google.com/</span></span><br></pre></td></tr></table></figure>
<p><a href="http://google.com/">Google</a><br>
And then define the link:</p>
<h3 id="URLs">URLs</h3>
<p>Typora允许你以链接的形式插入url，用’ &lt; <code>brackets</code> &gt; '包围。</p>
<p><code>&lt;i@typora.io&gt;</code> becomes <a href="mailto:i@typora.io">i@typora.io</a>.</p>
<p>Typora 也会自动链接标准 url。例如: <a href="http://www.google.com">www.google.com</a>。</p>
<h3 id="Images">Images</h3>
<p>图片的语法与链接类似，但它们在链接开始之前需要额外的 <code>!</code> 符号。插入图像的语法是这样的:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg &quot;Optional title&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>您可以使用拖放从图像文件或 web 浏览器插入图像。您可以通过单击图像来修改 markdown 源代码。如果使用拖放方式添加的图像与当前正在编辑的文档位于同一目录或子目录，则使用相对路径。</p>
<p>如果你正在使用 markdown 来构建网站，你可以在 YAML Front Matters 中 使用属性<code>typora-root-url</code>为你的本地计算机上的图像预览指定一个URL前缀。例如，在YAML Front Matters 输入<code>typora-root-url:/User/Abner/Website/typora.io/</code>，然后<code>![alt](/blog/img/test.png)</code>在 Typora 将被视为<code>![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)</code></p>
<p>You can find more details <a href="https://support.typora.io/Images/">here</a>.</p>
<h3 id="Emphasis">Emphasis</h3>
<p>Markdown 将星号 (<code>*</code>) 和下划线(<code> _</code>)作为强调的指示符。用一个 <code>*</code> or <code>_</code> 包装的文本将用一个 HTML <code>&lt;em&gt;</code> tag 包装。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*single asterisks*</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_single underscores_</span></span><br></pre></td></tr></table></figure>
<p>output:</p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p>GFM 会忽略单词中常用的下划线，比如:</p>
<blockquote>
<p>wow_great_stuff</p>
<p>do_this_and_do_that_and_another_thing.</p>
</blockquote>
<p>要在原本用作强调分隔符的位置产生星号或下划线，可以使用反斜杠转义:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="emphasis">*this text is surrounded by literal asterisks\*</span></span><br></pre></td></tr></table></figure>
<p>推荐使用<code>*</code>符号。</p>
<h3 id="Strong">Strong</h3>
<p>双引号<code>*</code>或<code>_</code>将导致其包含的内容被一个HTML ’ <strong> '标签包装，例如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**double asterisks**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__double underscores__</span></span><br></pre></td></tr></table></figure>
<p>output:</p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<p>推荐使用 <code>**</code>符号</p>
<h3 id="Code">Code</h3>
<p>若要指示代码的内联跨度，请用反勾引号(`)将其包装起来。与预格式化的代码块不同，代码跨度表示正常段落中的代码。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Use the <span class="code">`printf()`</span> function.</span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>Use the <code>printf()</code> function.</p>
<p>使用<code>printf()</code>函数</p>
<h3 id="Strikethrough">Strikethrough</h3>
<p>GFM 添加了创建划线文本的语法，这是标准 Markdown 所缺少的。</p>
<p><code>~~Mistaken text.~~</code> becomes <s>Mistaken text.</s></p>
<h3 id="Underlines">Underlines</h3>
<p>Underline 是由原始 HTML 驱动的。</p>
<p><code>&lt;u&gt;Underline&lt;/u&gt;</code> becomes <u>Underline</u>.</p>
<h3 id="Emoji-😄">Emoji 😄</h3>
<p>输入带有语法的表情符号: <code>:smile:</code>。</p>
<p>用户可以按下<code>ESC</code> 键自动完成对表情符号的建议，或者在首选面板上启用后自动触发。此外，直接输入 UTF-8 表情符号也可以通过菜单栏中的 <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>来实现。</p>
<h3 id="Inline-Math">Inline Math</h3>
<p>要使用此功能，请先在 <code>Preference</code> 面板-&gt; <code>Markdown</code> 选项卡中启用它。然后，使用 <code>$</code> 包装 TeX 命令。例如: <code>$\lim_&#123;x \to \infty&#125; \exp(-x) = 0$</code> 将被呈现为 LaTeX 命令。</p>
<p>要触发内联数学的内联预览:输入“$”，然后按“ESC”键，然后输入 TeX 命令。</p>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Subscript">Subscript</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用 <code>~</code> 包装下标内容。例如: <code>H~2~O</code>, <code>X~long\ text~</code>/</p>
<h3 id="Superscript">Superscript</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用  <code>^</code>  包装上标内容。例如: <code>X^2^</code>.</p>
<h3 id="Highlight">Highlight</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用 <code>==</code> 包装高亮内容。例如: <code>==highlight==</code>.</p>
<h2 id="HTML">HTML</h2>
<p>您可以使用 HTML 来样式化纯 Markdown 不支持的内容。例如，使用 <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> 来添加红色文本。</p>
<h3 id="Embed-Contents">Embed Contents</h3>
<p>一些网站提供基于框架的嵌入代码，你也可以将其粘贴到 Typora 中。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">&#x27;265&#x27;</span> <span class="attr">scrolling</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">title</span>=<span class="string">&#x27;Fancy Animated SVG Menu&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#x27;</span> <span class="attr">frameborder</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">allowtransparency</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">allowfullscreen</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;width: 100%;&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Video">Video</h3>
<p>你可以使用<code>&lt;video&gt;</code>HTML标签来嵌入视频。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Other-HTML-Support">Other HTML Support</h3>
<p>You can find more details <a href="https://support.typora.io/HTML/">here</a>.</p>
<h2 id="Reference">Reference</h2>
<p>[1]	Typora的Markdown语法: <a href="https://support.typoraio.cn/zh/Markdown-Reference">https://support.typoraio.cn/zh/Markdown-Reference</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Here is the <em>text</em> of the <strong>footnote</strong>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>浅层语义分析（LSA）</title>
    <url>/archives/d42a069d.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p><strong>前言</strong></p>
<p><mark>浅层语义分析（LSA）</mark> 是一种自然语言处理中用到的方法，其通过“矢量语义空间”来提取文档与词中的“概念”，进而分析文档与词之间的关系。LSA的基本假设是，如果两个词多次出现在同一文档中，则这两个词在语义上具有相似性。LSA使用大量的文本上构建一个矩阵，这个矩阵的一行代表一个词，一列代表一个文档，矩阵元素代表该词在该文档中出现的次数，然后再此矩阵上使用奇异值分解（SVD）来保留列信息的情况下减少矩阵行数，之后每两个词语的相似性则可以通过其行向量的cos值（或者归一化之后使用向量点乘）来进行标示，此值越接近于1则说明两个词语越相似，越接近于0则说明越不相似。</p>
<span id="more"></span>
<p>LSA最早在1988年由 <a href="https://en.wikipedia.org/wiki/Scott_Deerwester">Scott Deerwester</a>, <a href="https://en.wikipedia.org/wiki/Susan_Dumais">Susan Dumais</a>, <a href="https://en.wikipedia.org/wiki/George_Furnas">George Furnas</a>, <a href="https://en.wikipedia.org/wiki/Richard_Harshman">Richard Harshman</a>, <a href="https://en.wikipedia.org/wiki/Thomas_Landauer">Thomas Landauer</a>, <a href="https://en.wikipedia.org/w/index.php?title=Karen_Lochbaum&amp;action=edit&amp;redlink=1">Karen Lochbaum</a> and <a href="https://en.wikipedia.org/w/index.php?title=Lynn_Streeter&amp;action=edit&amp;redlink=1">Lynn Streeter</a>提出，在某些情况下，LSA又被称作潜在语义索引（LSI）。</p>
<p><strong>概述</strong></p>
<p><strong>词-文档矩阵（Occurences Matrix)</strong></p>
<p>LSA 使用词-文档矩阵来描述一个词语是否在一篇文档中。词-文档矩阵式一个稀疏矩阵，其行代表词语，其列代表文档。一般情况下，词-文档矩阵的元素是该词在文档中的出现次数，也可以是是该词语的tf-idf(term frequency–inverse document frequency)。</p>
<p>词-文档矩阵和传统的语义模型相比并没有实质上的区别，只是因为传统的语义模型并不是使用“矩阵”这种数学语言来进行描述。</p>
<p><strong>降维</strong></p>
<p>在构建好词-文档矩阵之后，LSA将对该矩阵进行降维，来找到词-文档矩阵的一个低阶近似。降维的原因有以下几点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>原始的词-文档矩阵太大导致计算机无法处理，从此角度来看，降维后的新矩阵式原有矩阵的一个近似。</p>
</li>
<li class="lvl-2">
<p>原始的词-文档矩阵中有噪音，从此角度来看，降维后的新矩阵式原矩阵的一个去噪矩阵。</p>
</li>
<li class="lvl-2">
<p>原始的词-文档矩阵过于稀疏。原始的词-文档矩阵精确的反映了每个词是否“出现”于某篇文档的情况，然而我们往往对某篇文档“相关”的所有词更感兴趣，因此我们需要发掘一个词的各种同义词的情况。</p>
</li>
</ul>
<p>降维的结果是不同的词或因为其语义的相关性导致合并，如：</p>
<p>{(car), (truck), (flower)} --&gt; {(1.3452 * car + 0.2828 * truck), (flower)}</p>
<p>将维可以解决一部分同义词的问题，也能解决一部分二义性问题。具体来说，原始词-文档矩阵经过降维处理后，原有词向量对应的二义部分会加到和其语义相似的词上，而剩余部分则减少对应的二义分量。</p>
<p><strong>推导</strong></p>
<p>假设X是词-文档矩阵，其元素（i,j）代表词语i在文档j中的出现次数，则X矩阵看上去是如下的样子：</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240431.png" alt=""></p>
<p>可以看到，每一行代表一个词的向量，该向量描述了该词和所有文档的关系。</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240905.png" alt=""></p>
<p>相似的，一列代表一个文档向量，该向量描述了该文档与所有词的关系。</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240123.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242577.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242830.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242875.png" alt=""></p>
<p>**代码：**<a href="https://github.com/Humble-LiuAo/Machine-Learning/tree/main/Data%20Mining/LSA">https://github.com/Humble-LiuAo/Machine-Learning/tree/main/Data Mining/LSA</a></p>
<p><strong>应用</strong></p>
<p>低维的语义空间可以用于以下几个方面:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在低维语义空间可对文档进行比较，进而可用于文档聚类和文档分类。</p>
</li>
<li class="lvl-2">
<p>在翻译好的文档上进行训练，可以发现不同语言的相似文档，可用于跨语言检索。</p>
</li>
<li class="lvl-2">
<p>发现词与词之间的关系，可用于同义词、歧义词检测。.</p>
</li>
<li class="lvl-2">
<p>通过查询映射到语义空间，可进行信息检索。</p>
</li>
<li class="lvl-2">
<p>从语义的角度发现词语的相关性，可用于“选择题回答模型”（multi choice qustions answering model）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
        <category>Data mining</category>
      </categories>
      <tags>
        <tag>Machine learning</tag>
        <tag>语义分析</tag>
        <tag>Data mining</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda-Python环境安装</title>
    <url>/archives/eabeff19.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="查询版本信息">查询版本信息</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>驱动器版本：右键NVIDIA–&gt;系统信息（点击开始菜单，搜索<code>dxdiag</code>）</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应cuda版本：</p>
<p><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a></p>
</li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应tensorflow版本：</p>
<p><a href="https://tensorflow.google.cn/install/source_windows?hl=en#gpu">https://tensorflow.google.cn/install/source_windows?hl=en#gpu</a></p>
</li>
<li class="lvl-2">
<p>对应pytorch版本：</p>
<p><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p>
</li>
</ul>
<h2 id="安装Anaconda">安装Anaconda</h2>
<p>下载网址：<a href="https://repo.anaconda.com/archive/">https://repo.anaconda.com/archive/</a><br>
<strong>安装事项</strong>：</p>
<ol>
<li class="lvl-3">
<p>修改路径</p>
</li>
<li class="lvl-3">
<p>不要勾选“Add Anaconda to the system PATH environment variable”。</p>
</li>
<li class="lvl-3">
<p>添加上：<mark>Anaconda3、Anaconda3/Scripts、Anaconda3/Library/bin</mark>这3个文件夹的路径（用户+系统的Path，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</p>
</li>
</ol>
<h3 id="设置镜像源">设置镜像源</h3>
<p>清华镜像网址：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p>
<p>参考：<a href="https://www.cpci.dev/anaconda-mirrors-configure/">https://www.cpci.dev/anaconda-mirrors-configure/</a></p>
<ol>
<li class="lvl-3">
<p>生成 <mark>.condarc</mark> 文件： <code>conda config --set show_channel_urls yes</code>（C:\users\username\）</p>
</li>
<li class="lvl-3">
<p>清华源复制到 <mark>.condarc</mark> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">ssl_verify: false</span><br><span class="line"># 命令行</span><br><span class="line">conda clean -i</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>不走镜像、代理设置</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line"><span class="bullet">  -</span> defaults</span><br><span class="line">show<span class="emphasis">_channel_</span>urls: true</span><br><span class="line">proxy<span class="emphasis">_servers:</span></span><br><span class="line"><span class="emphasis">  http: 127.0.0.1:7890</span></span><br><span class="line"><span class="emphasis">  https: 127.0.0.1:7890</span></span><br><span class="line"><span class="emphasis">ssl_</span>verify: false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="conda安装tensorflow">conda安装tensorflow</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n tf python=3.6</span><br><span class="line">activate tf</span><br><span class="line">conda install tensorflow-gpu=1.9.0</span><br><span class="line"># 根据python版本默认安装 </span><br><span class="line">conda install tensorflow-gpu</span><br><span class="line"></span><br><span class="line">pip install --upgrade tensorflow</span><br><span class="line">python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span><br></pre></td></tr></table></figure>
<h3 id="高版本安装">高版本安装</h3>
<p>需要 <strong>pip</strong>安装 <strong>tensorflow</strong>：<a href="https://tensorflow.google.cn/install/pip?hl=en#windows-native">https://tensorflow.google.cn/install/pip?hl=en#windows-native</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge cudatoolkit=11.2 cudnn=8.1.0</span><br><span class="line">#如果上面这个执行失败了，多执行几次</span><br><span class="line">#如果自己的显卡支持，安装了上面的两个配置后，再安装下面的tensorflow-gpu 2.7.0版本的话</span><br><span class="line">#就可以直接显示gpu版本的状态为为true</span><br><span class="line">pip install tensorflow-gpu==2.7.0</span><br><span class="line">pip install &quot;tensorflow&lt;2.11&quot;</span><br><span class="line"># 走清华镜像</span><br><span class="line"> -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># 设置timeout</span><br><span class="line">pip --default-timeout=600 install &quot;tensorflow&lt;2.11&quot; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># Verify install:</span><br><span class="line">#python</span><br><span class="line">#impor tensorflow as tf</span><br><span class="line">#print(tf.config.list_physical_devices(&#x27;GPU&#x27;))</span><br></pre></td></tr></table></figure>
<h2 id="conda安装pytorch">conda安装pytorch</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n pytorch python=3.8</span><br><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>
<p><strong>CondaSSLError: OpenSSL appears to be unavailable on this machine. OpenSSL is required to download and install packages. <mark>解决的方法</mark></strong></p>
<ol>
<li class="lvl-3">
<p>到你的anaconda的安装目录位置：比如<br>
<img src="https://gitee.com/humble_ao/Image/raw/master/c6c98a6807fd4b559bac2703f3399427.png" alt=""></p>
</li>
<li class="lvl-3">
<p><code>D:\ProgramData\Anaconda3\Library\bin</code>，找到如下两个DLL的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libcrypto-1_1-x64.dll</span><br><span class="line">libssl-1_1-x64.dll</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/humble_ao/Image/raw/master/db37a06081a944b6ad430fad2c9a5336.png" alt=""></p>
</li>
<li class="lvl-3">
<p>复制到 <code>D:\ProgramData\Anaconda3\DLLs</code><br>
<img src="https://gitee.com/humble_ao/Image/raw/master/b76e975a080d48a8bf437c02f17c4178.png" alt=""></p>
</li>
<li class="lvl-3">
<p>重启下shell</p>
</li>
</ol>
<h2 id="测试">测试</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">if</span> tf.test.gpu_device_name():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Default GPU Device: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(tf.test.gpu_device_name()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please install GPU version of TF&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="built_in">print</span>(tf.test.gpu_device_name())</span><br><span class="line"><span class="built_in">print</span>(tf.test.is_gpu_available())</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytorch</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">flag = torch.cuda.is_available()</span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CUDA可使用&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CUDA不可用&quot;</span>)</span><br><span class="line"></span><br><span class="line">ngpu= <span class="number">1</span></span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;驱动为：&quot;</span>,device)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;GPU型号： &quot;</span>,torch.cuda.get_device_name(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h2 id="conda常用命令">conda常用命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version:</span><br><span class="line">conda -V</span><br><span class="line">env:</span><br><span class="line">conda env list</span><br><span class="line">conda create -n env python=3.6 </span><br><span class="line">conda remove -n env --all</span><br><span class="line">conda deactivate</span><br><span class="line">Package:</span><br><span class="line">conda list</span><br><span class="line">conda list -n your_env_name</span><br><span class="line">conda install -n env_name package_name</span><br><span class="line">conda update -n env_name package_name</span><br><span class="line">conda install numpy pandas matplotlib scikit-learn seaborn scikit-image opencv</span><br><span class="line">conda update conda</span><br><span class="line">conda update anaconda-navigator</span><br><span class="line">conda update navigator-updater</span><br><span class="line">conda update --all</span><br><span class="line"></span><br><span class="line">numpy matplotlib scikit-image scikit-learn tqdm pandas global-land-mask netCDF4 gdal</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
</search>
