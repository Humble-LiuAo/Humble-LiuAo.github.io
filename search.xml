<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++运算符优先级</title>
    <url>/archives/10aa9482.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>优先级高的运算符在优先级低的运算符之前计算。当运算符具有相同的优先级时，它们的结合性决定了计算顺序</p>
</blockquote>
<span id="more"></span>
<h2 id="C语言中的运算符">C语言中的运算符</h2>
<table>
<thead>
<tr>
<th>说明</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>初等运算符</td>
<td>() [] -&gt; .</td>
<td>-&gt;</td>
</tr>
<tr>
<td>单目运算符</td>
<td>! ~ ++ – - (类型) * &amp; sizeof</td>
<td>&lt;-</td>
</tr>
<tr>
<td>算术运算符</td>
<td>* / %</td>
<td>-&gt;</td>
</tr>
<tr>
<td>算术运算符</td>
<td>+ -</td>
<td>-&gt;</td>
</tr>
<tr>
<td>移位运算符</td>
<td>&lt;&lt; &gt;&gt;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt; &gt;= &lt; &lt;=</td>
<td>-&gt;</td>
</tr>
<tr>
<td>关系运算符</td>
<td>== !=</td>
<td>-&gt;</td>
</tr>
<tr>
<td>按位与</td>
<td>&amp;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>按位异或</td>
<td>^</td>
<td>-&gt;</td>
</tr>
<tr>
<td>按位或</td>
<td>|</td>
<td>-&gt;</td>
</tr>
<tr>
<td>逻辑与</td>
<td>&amp;&amp;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>逻辑或</td>
<td>||</td>
<td>-&gt;</td>
</tr>
<tr>
<td>条件运算符</td>
<td>?:</td>
<td>&lt;-</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</td>
<td>&lt;-</td>
</tr>
<tr>
<td>逗号运算符</td>
<td>,</td>
<td>-&gt;</td>
</tr>
</tbody>
</table>
<h2 id="C-语言中的运算符">C++语言中的运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>::</td>
<td>二元作用域 一元作用域</td>
<td>-&gt;</td>
</tr>
<tr>
<td>() [] . -&gt; ++ – typeid dynamic_cast<type> static_cast<type> reinterpret_cast<type> const_cast<type></td>
<td>初等/类型转换 +±-为一元后自增</td>
<td>-&gt;</td>
</tr>
<tr>
<td>++ – + - ! ~ (类型) sizeof &amp; * new new[] delete delete[]</td>
<td>+±-为一元前自增</td>
<td>&lt;-</td>
</tr>
<tr>
<td>.* -&gt;*</td>
<td>取指向成员的指针</td>
<td>-&gt;</td>
</tr>
<tr>
<td>* / %</td>
<td>算术运算符</td>
<td>-&gt;</td>
</tr>
<tr>
<td>+ -</td>
<td>算术运算符</td>
<td>-&gt;</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt;</td>
<td>移位运算符</td>
<td>-&gt;</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>关系运算符</td>
<td>-&gt;</td>
</tr>
<tr>
<td>== !=</td>
<td>关系运算符</td>
<td>-&gt;</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>-&gt;</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>-&gt;</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>-&gt;</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>-&gt;</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>-&gt;</td>
</tr>
<tr>
<td>?:</td>
<td>条件运算符</td>
<td>&lt;-</td>
</tr>
<tr>
<td>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</td>
<td>赋值运算符</td>
<td>&lt;-</td>
</tr>
<tr>
<td>,</td>
<td>逗号运算符</td>
<td>-&gt;</td>
</tr>
</tbody>
</table>
<p>注:从上到下优先级递减!</p>
<p><strong>总结:初单算移关,位逻条赋逗!(请一定记住这句话,虽然不是很顺口)</strong></p>
<h2 id="Reference">Reference</h2>
<p>[1]	C/C++中的运算符优先级总结：<a href="https://blog.twofei.com/531/">https://blog.twofei.com/531/</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数详解</title>
    <url>/archives/d59d73b9.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<p>这里先额外介绍一下C++类的存储方式，然后介绍虚函数。</p>
<p>C++程序的内存格局通常分为五个区：全局数据区（data area）,代码区（code area）、栈区（stack area）、堆区（heap area）（即自由存储区）,文字常量区。全局数据区存放全局变量和静态变量，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；文字常量区存储常量字符串，程序结束后由系统释放，余下的空间都被称为堆区。类的存储方式如下图所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/qzYkw63xWavR7XA.png" alt=""></p>
 <span id="more"></span>
<p>其中对象数据中存储非静态成员变量、虚函数表指针以及虚基类表指针（如果继承多个）。这里就有一个问题，既然对象里不存储类的成员函数的指针，那类的对象是怎么调用公用函数代码的呢？对象对公用函数代码的调用是在编译阶段就已经决定了的，例如有类对象a，成员函数为show()，如果有代码a.show()，那么在编译阶段会解释为 类名::show(&amp;a)。会给show()传一个对象的指针，即this指针。</p>
<p>从上面的this指针可以说明一个问题：静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，但是类为什么只能直接调用静态成员函数，而非静态成员函数（即使函数没有参数）只有类对象能够调用的问题？原因是类的非静态成员函数其实都内含了一个指向类对象的指针型参数（即this指针），因而只有类对象才能调用（此时this指针有实值）。</p>
<h2 id="虚函数表">虚函数表</h2>
<h3 id="内存布局">内存布局</h3>
<p>先说一下虚函数表的内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/Qz6Km5FUToVgtra.png" alt=""></p>
<p>每一个有虚函数的类都有一个虚函数表，虚函数是整个类所共有的，虚函数表存储在对象内存最开始的位置。如果子类继承了多个父类，并且父类有虚函数，则子类要存储多个虚函数指针。如上图所示，如果继承了n个父类，并且每个父类都有虚函数，那子类会有n个虚函数表指针。</p>
<h3 id="无继承">无继承</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base a;</span><br><span class="line">    Fun pf = <span class="literal">NULL</span>, pg = <span class="literal">NULL</span>, ph = <span class="literal">NULL</span>;</span><br><span class="line">    pf = (Fun)*((<span class="type">int</span>*)*((<span class="type">int</span>*)(&amp;a)));</span><br><span class="line">    pg = (Fun)*((<span class="type">int</span>*)*((<span class="type">int</span>*)(&amp;a))+<span class="number">1</span>);</span><br><span class="line">    ph = (Fun)*((<span class="type">int</span>*)*((<span class="type">int</span>*)(&amp;a))+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">pf</span>();</span><br><span class="line">    <span class="built_in">pg</span>();</span><br><span class="line">    <span class="built_in">ph</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Base的内存布局（<a href="https://blog.csdn.net/tennysonsky/article/details/52054291">类查看内存布局的方法</a>）：</p>
<p><img src="https://s2.loli.net/2023/11/11/g7B5TP6v3I4Xiha.png" alt=""></p>
<p>运行结果：</p>
<p><img src="https://s2.loli.net/2023/11/11/IFboJqH2B6fsNkV.png" alt=""></p>
<p>Base类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/seCQExyJrHB6438.png" alt=""></p>
<p>这里的sizeof(a) = 8 是虚函数表指针的大小 4 和 data的大小4。图3 最后一个虚函数表中的最后一个位置表示虚函数表的结束。</p>
<h3 id="一般继承（无虚函数覆盖）">一般继承（无虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node a;</span><br><span class="line">    Base b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/qMJKmtcWdGjYR2N.png" alt=""></p>
<p>输出结果：</p>
<p><img src="https://s2.loli.net/2023/11/11/XgQAPLhWk7Bnsio.png" alt=""></p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/zQci9L3IPGpJr4W.png" alt=""></p>
<p>如图4 所以，虚函数表现存储父类的虚函数，然后存子类的虚函数。</p>
<h3 id="一般继承（有虚函数覆盖）">一般继承（有虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="comment">//覆盖Base的f()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node a;</span><br><span class="line">    Base b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局:</p>
<p><img src="https://s2.loli.net/2023/11/11/iGzUsxoN2OTuWaQ.png" alt=""></p>
<p>类Base内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/RcOmu81sjNUgboV.png" alt=""></p>
<p>输出结果同上一个。</p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/gq21fsGLEQI3Rbo.png" alt=""></p>
<p>如图5 所示，如果子类覆盖了父类的虚函数，则父类的虚函数会替换为子类的虚函数，没有被覆盖的虚函数依旧，这样当把子类的地址赋给父类指针的时候就可以实现多态了。</p>
<h3 id="多重继承（无虚函数覆盖）">多重继承（无虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 b1;</span><br><span class="line">    Base2 b2;</span><br><span class="line">    Base3 b3;</span><br><span class="line">    Node a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b1) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b2) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b3) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/4SXV1MLEKYw6yrq.png" alt=""></p>
<p>输出结果：</p>
<p><img src="https://s2.loli.net/2023/11/11/AexRiWschFuY9dz.png" alt=""></p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/K7QB2VXDGLeJjFZ.png" alt=""></p>
<p>如图6 所示，虚函数表的指针是按照声明的顺序来的，子类的虚函数放入第一个虚函数表里。</p>
<h3 id="多重继承（有虚函数覆盖）">多重继承（有虚函数覆盖）</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::f()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::g()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::h()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base3::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;  <span class="comment">//覆盖父类的f()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::f1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::g1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::h1()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Node::print()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 b1;</span><br><span class="line">    Base2 b2;</span><br><span class="line">    Base3 b3;</span><br><span class="line">    Node a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a) = &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Node内存布局：</p>
<p><img src="https://s2.loli.net/2023/11/11/ziLgvSfOqUBet1N.png" alt=""></p>
<p>输出结果为：</p>
<p><img src="https://s2.loli.net/2023/11/11/KoUtNAq9u7La6vQ.png" alt=""></p>
<p>Node类的虚函数表如下所示：</p>
<p><img src="https://s2.loli.net/2023/11/11/Eay7YNCD1wz6eSR.png" alt=""></p>
<p>如图 7所示，父类被覆盖的函数f()，都被替换为子类的虚函数f()。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 虚函数表详解【建议收藏】: <a href="https://bbs.huaweicloud.com/blogs/302735">https://bbs.huaweicloud.com/blogs/302735</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++设计模式</title>
    <url>/archives/9725cb23.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h1>设计模式大纲</h1>
<ol>
<li class="lvl-3">
<p>创建型模式：用来描述 “如何创建对象”，它的主要特点是 “将对象的创建和使用分离”。包括单例、原型、工厂方法、抽象工厂和建造者 5 种模式。</p>
</li>
<li class="lvl-3">
<p>结构型模式：用来描述如何将类或对象按照某种布局组成更大的结构。包括代理、适配器、桥接、装饰、外观、享元和组合 7 种模式。</p>
</li>
<li class="lvl-3">
<p>行为型模式：用来识别对象之间的常用交流模式以及如何分配职责。包括模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录和解释器 11 种模式。</p>
</li>
</ol>
<span id="more"></span>
<p><img src="https://s2.loli.net/2024/05/20/9m5F4wJqaOnTcsK.png" alt=""></p>
<h1>创造型模式</h1>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<p>单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
</blockquote>
<p><strong>实现思路</strong>：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p>
<p>单例模式有两种实现方法，分别是懒汉和饿汉模式。顾名思义，懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；饿汉模式，即迫不及待，在程序运行时立即初始化。</p>
<h3 id="经典的线程安全懒汉模式"><strong>经典的线程安全懒汉模式</strong></h3>
<p>单例模式的实现思路如前述所示，其中，经典的线程安全懒汉模式，使用双检测锁模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有静态指针变量指向唯一实例</span></span><br><span class="line">    <span class="type">static</span> single *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态锁，是由于静态函数只能访问静态成员</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="built_in">single</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有静态方法获取实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> single::lock;</span><br><span class="line">single* single::p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>为什么要用双检测，只检测一次不行吗？</mark></p>
<p>如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。</p>
<h3 id="局部静态变量之线程安全懒汉模式"><strong>局部静态变量之线程安全懒汉模式</strong></h3>
<p>前面的双检测锁模式，写起来不太优雅，《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> single obj;</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>这时候有人说了，这种方法不加锁会不会造成线程安全问题？</mark></p>
<p>其实，C<ins>0X以后，要求编译器保证内部静态变量的线程安全性，故C</ins>0x之后该实现是线程安全的，C<ins>0x之前仍需加锁，其中C</ins>0x是C++11标准成为正式标准之前的草案临时名字。</p>
<p>所以，如果使用C++11之前的标准，还是需要加锁，这里同样给出加锁的版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">single</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> single::lock;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">    <span class="type">static</span> single obj;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态变量在C++中具有特定的作用域和生命周期，这些特性与普通局部变量或全局变量有所不同。</p>
<ol>
<li class="lvl-3">
<p>作用域（Scope）：</p>
<ul class="lvl-3">
<li class="lvl-5">静态局部变量（局部静态变量）：静态局部变量的作用域限于定义它的函数内，它在函数内可见，但在函数外不可访问。</li>
<li class="lvl-5">静态全局变量：静态全局变量的作用域是整个文件（或编译单元），即它在定义它的文件内可见，但在其他文件中不可访问。</li>
</ul>
</li>
<li class="lvl-3">
<p>生命周期（Lifetime）：</p>
<ul class="lvl-3">
<li class="lvl-5">静态局部变量：静态局部变量的生命周期贯穿整个程序的执行过程，从首次初始化到程序结束。它会一直存在于内存中，而不是在函数退出时销毁，这使得它可以在多次函数调用之间保持其值。</li>
<li class="lvl-5">静态全局变量：静态全局变量的生命周期也贯穿整个程序的执行过程，从程序启动到结束。与普通全局变量不同，静态全局变量只在定义它的文件内可见。</li>
</ul>
</li>
</ol>
<p>静态变量适用于需要在多次函数调用之间保持状态的情况，因为它们的值在函数调用之间保持不变，且不会被销毁。它们也用于实现单例模式或共享状态的情况。</p>
<p>需要注意的是，静态变量的初始化只会发生一次，无论是静态局部变量还是静态全局变量，它们的值在首次初始化后将保持不变。</p>
</blockquote>
<h3 id="饿汉模式"><strong>饿汉模式</strong></h3>
<p>饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> single* p;</span><br><span class="line">    <span class="built_in">single</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p = <span class="keyword">new</span> <span class="built_in">single</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    single* p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">    single* p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>
<h3 id="使用场景">使用场景</h3>
<ol>
<li class="lvl-3">
<p>资源共享</p>
</li>
</ol>
<p>多个模块共享某个资源的时候，可以使用单例模式，比如说应用程序需要一个全局的配置管理器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。</p>
<ol start="2">
<li class="lvl-3">
<p>只有一个实例</p>
</li>
</ol>
<p>当系统中某个类只需要一个实例来协调行为的时候，可以考虑使用单例模式， 比如说管理应用程序中的缓存，确保只有一个缓存实例，避免重复的缓存创建和管理，或者使用单例模式来创建和管理线程池。</p>
<ol start="3">
<li class="lvl-3">
<p>懒加载</p>
</li>
</ol>
<p>如果对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用，可以使用单例模式实现懒加载。</p>
<h2 id="工厂模式">工厂模式</h2>
<p>我们先看工厂模式的介绍</p>
<blockquote>
<p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<p>简单来说，使用了C++<strong>多态</strong>的特性，将存在<strong>继承</strong>关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</p>
<p>工厂模式的实现方式可分别<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong>，每个实现方式都存在优和劣。</p>
<p>最近炒鞋炒的非常的火，那么以鞋厂的形式，一一分析针对每个实现方式进行分析。</p>
<h3 id="简单工厂模式"><strong>简单工厂模式</strong></h3>
<p><strong>具体的情形</strong>：</p>
<p>鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋子。哪个鞋炒的火爆，老板就生产哪个，看形势生产。</p>
<p><strong>UML图：</strong></p>
<p><img src="https://s2.loli.net/2023/11/05/F4uySOnkEKUBcbd.jpg" alt=""></p>
<p><strong>简单工厂模式的结构组成</strong>：</p>
<ol>
<li class="lvl-3">
<p>工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。</p>
</li>
<li class="lvl-3">
<p>抽象产品类：是具体产品类的继承的父类或实现的接口。</p>
</li>
<li class="lvl-3">
<p>具体产品类：工厂类所创建的对象就是此具体产品实例。</p>
</li>
</ol>
<p><strong>简单工厂模式的特点：</strong></p>
<p>工厂类封装了创建具体产品对象的函数。</p>
<p><strong>简单工厂模式的缺陷：</strong></p>
<p>扩展性非常差，新增产品的时候，需要去修改工厂类。</p>
<p><strong>简单工厂模式的代码：</strong></p>
<p>Shoes为鞋子的抽象类（基类），接口函数为Show()，用于显示鞋子广告。</p>
<p>NiKeShoes、AdidasShoes、LiNingShoes为具体鞋子的类，分别是耐克、阿迪达斯和李宁鞋牌的鞋，它们都继承于Shoes抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鞋子抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是李宁球鞋，我的广告语：Everything is possible&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ShoesFactory为工厂类，类里实现根据鞋子类型创建对应鞋子产品对象的CreateShoes(SHOES_TYPE type)函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SHOES_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    NIKE,</span><br><span class="line">    LINING,</span><br><span class="line">    ADIDAS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据鞋子类型创建对应的鞋子对象</span></span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">(SHOES_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NIKE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LINING:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADIDAS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数，先是构造了工厂对象，后创建指定类型的具体鞋子产品对象，创建了具体鞋子产品的对象便可直接打印广告。因为采用的是<code>new</code>的方式创建了对象，用完了要通过<code>delete</code> 释放资源资源哦！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造工厂对象</span></span><br><span class="line">    ShoesFactory shoesFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pNikeShoes = shoesFactory.<span class="built_in">CreateShoes</span>(NIKE);</span><br><span class="line">    <span class="keyword">if</span> (pNikeShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">        pNikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">        pNikeShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pLiNingShoes = shoesFactory.<span class="built_in">CreateShoes</span>(LINING);</span><br><span class="line">    <span class="keyword">if</span> (pLiNingShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 李宁球鞋广告喊起</span></span><br><span class="line">        pLiNingShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pLiNingShoes;</span><br><span class="line">        pLiNingShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pAdidasShoes = shoesFactory.<span class="built_in">CreateShoes</span>(ADIDAS);</span><br><span class="line">    <span class="keyword">if</span> (pAdidasShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阿迪达斯球鞋广告喊起</span></span><br><span class="line">        pAdidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pAdidasShoes;</span><br><span class="line">        pAdidasShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@lincoding factory]# ./simpleFactory </span><br><span class="line">我是耐克球鞋，我的广告语：Just do it</span><br><span class="line">我是阿迪达斯球鞋，我的广告语:Impossible is nothing</span><br><span class="line">我是李宁球鞋，我的广告语：Everything is possible</span><br></pre></td></tr></table></figure>
<h3 id="工厂方法模式"><strong>工厂方法模式</strong></h3>
<p><strong>具体情形：</strong></p>
<p>现各类鞋子抄的非常火热，于是为了大量生产每种类型的鞋子，则要针对不同品牌的鞋子开设独立的生产线，那么每个生产线就只能生产同类型品牌的鞋。</p>
<p><strong>UML图：</strong></p>
<p><img src="https://s2.loli.net/2023/11/05/nr6y2ld3ZpEgkUV.jpg" alt=""></p>
<p><strong>工厂方法模式的结构组成：</strong></p>
<ol>
<li class="lvl-3">
<p>抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</p>
</li>
<li class="lvl-3">
<p>具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。</p>
</li>
<li class="lvl-3">
<p>抽象产品类：它是具体产品继承的父类（基类）。</p>
</li>
<li class="lvl-3">
<p>具体产品类：具体工厂所创建的对象，就是此类。</p>
</li>
</ol>
<p><strong>工厂方法模式的特点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。</p>
</li>
<li class="lvl-2">
<p>工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。</p>
</li>
</ul>
<p><strong>工厂方法模式的缺陷：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义。</p>
</li>
<li class="lvl-2">
<p>一条生产线只能一个产品。</p>
</li>
</ul>
<p><strong>工厂方法模式的代码：</strong></p>
<p>ShoesFactory抽象工厂类，提供了创建具体鞋子产品的纯虚函数。</p>
<p><code>NiKeProducer、AdidasProducer、LiNingProducer</code>具体工厂类，继承持续工厂类，实现对应具体鞋子产品对象的创建。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShoesFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数针对每种类型的鞋子，构造了每种类型的生产线，再由每个生产线生产出对应的鞋子。需注意的是具体工厂对象和具体产品对象，用完了需要通过delete释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    ShoesFactory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line">    <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================ 生产阿迪达斯流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设阿迪达斯生产者</span></span><br><span class="line">    ShoesFactory *adidasProducer = <span class="keyword">new</span> <span class="built_in">AdidasProducer</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯生产线产出球鞋</span></span><br><span class="line">    Shoes *adidasShoes = adidasProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯球鞋广喊起</span></span><br><span class="line">    adidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> adidasShoes;</span><br><span class="line">    <span class="keyword">delete</span> adidasProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@lincoding factory]# ./methodFactory </span><br><span class="line">我是耐克球鞋，我的广告语：Just do it</span><br><span class="line">我是阿迪达斯球鞋，我的广告语:Impossible is nothing</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><strong>抽象工厂模式</strong></h3>
<p><strong>具体情形：</strong></p>
<p>鞋厂为了扩大了业务，不仅只生产鞋子，把运动品牌的衣服也一起生产了。</p>
<p><strong>UML图：</strong></p>
<p><img src="https://s2.loli.net/2023/11/05/Do6KdgTftqWbklM.jpg" alt=""></p>
<p><strong>抽象工厂模式的结构组成（和工厂方法模式一样）：</strong></p>
<ol>
<li class="lvl-3">
<p>抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</p>
</li>
<li class="lvl-3">
<p>具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。</p>
</li>
<li class="lvl-3">
<p>抽象产品类：它是具体产品继承的父类（基类）。</p>
</li>
<li class="lvl-3">
<p>具体产品类：具体工厂所创建的对象，就是此类。</p>
</li>
</ol>
<p><strong>抽象工厂模式的特点：</strong></p>
<p>提供一个接口，可以创建多个产品族中的产品对象。如创建耐克工厂，则可以创建耐克鞋子产品、衣服产品、裤子产品等。</p>
<p><strong>抽象工厂模式的缺陷：</strong></p>
<p>同工厂方法模式一样，新增产品时，都需要增加一个对应的产品的具体工厂类。</p>
<p><strong>抽象工厂模式的代码：</strong></p>
<p>Clothe和Shoes，分别为衣服和鞋子的抽象产品类。</p>
<p>NiKeClothe和NiKeShoes，分别是耐克衣服和耐克衣服的具体产品类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeClothe</span> : <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克衣服，时尚我最在行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，让你酷起来！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Factory为抽象工厂，提供了创建鞋子CreateShoes()和衣服产品CreateClothe()对象的接口。</p>
<p>NiKeProducer为具体工厂，实现了创建耐克鞋子和耐克衣服的方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Clothe *<span class="title">CreateClothe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Clothe *<span class="title">CreateClothe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeClothe</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数，构造耐克工厂对象，通过耐克工厂对象再创建耐克产品族的衣服和鞋子对象。同样，对象不再使用时，需要手动释放资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    Factory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">	<span class="comment">// 耐克生产线产出衣服</span></span><br><span class="line">    Clothe *nikeClothe = niKeProducer-&gt;<span class="built_in">CreateClothe</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">	<span class="comment">// 耐克衣服广告喊起</span></span><br><span class="line">    nikeClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">	<span class="keyword">delete</span> nikeClothe;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@lincoding factory]# ./abstractFactory </span><br><span class="line">我是耐克球鞋，让你酷起来！</span><br><span class="line">我是耐克衣服，时尚我最在行！</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>以上三种工厂模式，在新增产品时，都存在一定的缺陷。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单工厂模式，，需要去修改工厂类，这违背了开闭法则。</p>
</li>
<li class="lvl-2">
<p>工厂方式模式和抽象工厂模式，都需要增加一个对应的产品的具体工厂类，这就会增大了代码的编写量。</p>
</li>
</ul>
<blockquote>
<p>那么有什么好的方法，在新增产品时，即不用修改工厂类，也不用新增具体的工厂类？详细内容可以跳转至 <a href="https://zhuanlan.zhihu.com/p/83537599">C++ 深入浅出工厂模式（进阶篇）</a></p>
</blockquote>
<h2 id="建造者模式">建造者模式</h2>
<blockquote>
<p>建造者模式（也被成为⽣成器模式），是⼀种创建型设计模式，软件开发过程中有的时候需要创建很复杂的对象， ⽽建造者模式的主要思想是将对象的构建过程分为多个步骤，并为每个步骤定义⼀个抽象的接⼝。具体的构建过程 由实现了这些接⼝的具体建造者类来完成。同时有⼀个指导者类负责协调建造者的⼯作，按照⼀定的顺序或逻辑来 执⾏构建步骤，最终⽣成产品。</p>
</blockquote>
<h3 id="基本结构">基本结构</h3>
<p>建造者模式有下⾯⼏个关键⻆⾊：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>产品Product：被构建的复杂对象, 包含多个组成部分。</p>
</li>
<li class="lvl-2">
<p>抽象建造者 Builder : 定义构建产品各个部分的抽象接⼝和⼀个返回复杂产品的⽅法</p>
</li>
<li class="lvl-2">
<p>具体建造者 getResult Concrete Builder ：实现抽象建造者接⼝，构建产品的各个组成部分，并提供⼀个⽅法返回最 终的产品。</p>
</li>
<li class="lvl-2">
<p>指导者 Director ：调⽤具体建造者的⽅法，按照⼀定的顺序或逻辑来构建产品。</p>
</li>
</ul>
<p>在客户端中，通过指导者来构建产品，而并不和具体建造者进行直接的交互。</p>
<p><img src="https://s2.loli.net/2024/05/20/EFbq2PGIhcQnUgu.png" alt=""></p>
<h3 id="简易实现">简易实现</h3>
<p>建造者模式的实现步骤通常包括以下几个阶段</p>
<ol>
<li class="lvl-3">
<p>定义产品类：产品类应该包含多个组成部分，这些部分的属性和方法构成了产品的接口</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string part1;</span><br><span class="line">    std::string part2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPart1</span><span class="params">(<span class="type">const</span> std::string&amp; part1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part1 = part1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPart2</span><span class="params">(<span class="type">const</span> std::string&amp; part2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;part2 = part2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showProduct</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Product with Part1: &quot;</span> &lt;&lt; part1 &lt;&lt; <span class="string">&quot; and Part2: &quot;</span> &lt;&lt; part2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>定义抽象建造者接口：创建一个接口，包含构建产品各个部分的抽象方法。这些方法通常用于设置产品的各个属性。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象建造者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildPart1</span><span class="params">(<span class="type">const</span> std::string&amp; part1)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildPart2</span><span class="params">(<span class="type">const</span> std::string&amp; part2)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>创建具体建造者：实现抽象建造者接口，构建具体的产品。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体建造者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> : <span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Product* product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        product = <span class="keyword">new</span> <span class="built_in">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ConcreteBuilder</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildPart1</span><span class="params">(<span class="type">const</span> std::string&amp; part1)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        product-&gt;<span class="built_in">setPart1</span>(part1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildPart2</span><span class="params">(<span class="type">const</span> std::string&amp; part2)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        product-&gt;<span class="built_in">setPart2</span>(part2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Product* <span class="title">getResult</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>定义<code>Director</code>类： 指导者类来控制构建产品的顺序和步骤。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指导者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Builder* builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Director</span>(Builder* builder) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方法构建产品</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">buildPart1</span>(<span class="string">&quot;Part1&quot;</span>);</span><br><span class="line">        builder-&gt;<span class="built_in">buildPart2</span>(<span class="string">&quot;Part2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>客户端使用建造者模式：在客户端中创建【具体建造者对象】和【指导者对象】，通过指导者来构建产品。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体建造者</span></span><br><span class="line">    Builder* builder = <span class="keyword">new</span> <span class="built_in">ConcreteBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建指导者</span></span><br><span class="line">    <span class="function">Director <span class="title">director</span><span class="params">(builder)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指导者构建产品</span></span><br><span class="line">    director.<span class="built_in">construct</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取构建好的产品</span></span><br><span class="line">    Product* product = builder-&gt;<span class="built_in">getResult</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出产品信息</span></span><br><span class="line">    product-&gt;<span class="built_in">showProduct</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-2">使用场景</h3>
<p>使⽤建造者模式有下⾯⼏处优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使⽤建造者模式可以将⼀个复杂对象的构建与其表示分离，通过将构建复杂对象的过程抽象出来，可以使客户 端代码与具体的构建过程解耦</p>
</li>
<li class="lvl-2">
<p>同样的构建过程可以创建不同的表示，可以有多个具体的建造者(相互独⽴），可以更加灵活地创建不同组合 的对象。</p>
</li>
</ul>
<p>对应的，建造者模式适⽤于复杂对象的创建，当对象构建过程相对复杂时可以考虑使⽤建造者模式，但是当产品的 构建过程发⽣变化时，可能需要同时修改指导类和建造者类，这就使得重构变得相对困难。</p>
<h2 id="原型模式">原型模式</h2>
<blockquote>
<p>原型模式⼀种创建型设计模式，该模式的核⼼思想是基于现有的对象创建新的对象，⽽不是从头开始创建。 在原型模式中，通常有⼀个原型对象，它被⽤作创建新对象的模板。新对象通过复制原型对象的属性和状态来创 建，⽽⽆需知道具体的创建细节</p>
</blockquote>
<h3 id="基本结构-2">基本结构</h3>
<p>实现原型模式需要给【原型对象】声明一个克隆方法，执行该方法会创建一个当前类的新对象，并将原始对象中的成员变量复制到新生成的对象中，而不必实例化。并且在这个过程中只需要调用原型对象的克隆方法，而无需知道原型对象的具体类型。</p>
<p>原型模式包含两个重点模块：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抽象原型接口<code>prototype</code>: 声明一个克隆自身的方法<code>clone</code></p>
</li>
<li class="lvl-2">
<p>具体原型类<code>ConcretePrototype</code>: 实现<code>clone</code>方法，复制当前对象并返回一个新对象。</p>
</li>
</ul>
<p>在客户端代码中，可以声明一个具体原型类的对象，然后调用<code>clone()</code>方法复制原对象生成一个新的对象。</p>
<p><img src="https://s2.loli.net/2024/05/20/eAfiHEzmnrKa1VU.png" alt=""></p>
<h3 id="基本实现">基本实现</h3>
<p>原型模式的实现过程即上面描述模块的实现过程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建一个抽象类或接口，声明一个克隆方法<code>clone</code></p>
</li>
<li class="lvl-2">
<p>实现具体原型类，重写克隆方法</p>
</li>
<li class="lvl-2">
<p>客户端中实例化具体原型类的对象，并调用其克隆方法来创建新的对象。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Prototype</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Prototype* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> : <span class="keyword">public</span> Prototype &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcretePrototype</span>(<span class="type">const</span> std::string&amp; data) : <span class="built_in">data</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 clone 方法</span></span><br><span class="line">    <span class="function">Prototype* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcretePrototype</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原型对象</span></span><br><span class="line">    Prototype* original = <span class="keyword">new</span> <span class="built_in">ConcretePrototype</span>(<span class="string">&quot;Original Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆原型对象</span></span><br><span class="line">    Prototype* clone = original-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出克隆对象的数据</span></span><br><span class="line">    ConcretePrototype* concreteClone = <span class="built_in">dynamic_cast</span>&lt;ConcretePrototype*&gt;(clone);</span><br><span class="line">    <span class="keyword">if</span> (concreteClone) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Clone Data: &quot;</span> &lt;&lt; concreteClone-&gt;<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> original;</span><br><span class="line">    <span class="keyword">delete</span> clone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用场景-3">使用场景</h3>
<p>相比于直接实例化对象，通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象的创建过程复杂或对象的创建代价较大的情况下。当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景时可以考虑使用原型模式，在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。</p>
<p>但是使用原型模式也需要考虑到如果对象的内部状态包含了引用类型的成员变量，那么实现深拷贝就会变得较为复杂，需要考虑引用类型对象的克隆问题。</p>
<h1>结构型模式</h1>
<h2 id="适配器模式">适配器模式</h2>
<p><strong>什么是适配器</strong></p>
<p>适配器模式<code>Adapter</code>是一种结构型设计模式，它可以将一个类的接口转换成客户希望的另一个接口，主要目的是充当两个不同接口之间的桥梁，使得原本接口不兼容的类能够一起工作。</p>
<h3 id="基本结构-3">基本结构</h3>
<p>适配器模式分为以下几个基本角色：</p>
<blockquote>
<p>可以把适配器模式理解成拓展坞，起到转接的作用，原有的接口是USB，但是客户端需要使用<code>type-c</code>， 便使用拓展坞提供一个<code>type-c</code>接口给客户端使用</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/05/20/RSeX6h3gHGTJI2p.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>目标接口<code>Target</code>: 客户端希望使用的接口</p>
</li>
<li class="lvl-2">
<p>适配器类<code>Adapter</code>: 实现客户端使用的目标接口，持有一个需要适配的类实例。</p>
</li>
<li class="lvl-2">
<p>被适配者<code>Adaptee</code>: 需要被适配的类</p>
</li>
</ul>
<p>这样，客户端就可以使用目标接口，而不需要对原来的<code>Adaptee</code>进行修改，<code>Adapter</code>起到一个转接扩展的作用。</p>
<h3 id="基本实现-2">基本实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Target</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specific request&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> : <span class="keyword">public</span> Target &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Adaptee* adaptee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>(Adaptee* adaptee) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用被适配者类的方法</span></span><br><span class="line">        adaptee-&gt;<span class="built_in">specificRequest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Adaptee* adaptee = <span class="keyword">new</span> <span class="built_in">Adaptee</span>();</span><br><span class="line">    Target* target = <span class="keyword">new</span> <span class="built_in">Adapter</span>(adaptee);</span><br><span class="line">    target-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> target;</span><br><span class="line">    <span class="keyword">delete</span> adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="应用场景">应用场景</h3>
<p>在开发过程中，适配器模式往往扮演者“补救”和“扩展”的角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当使用一个已经存在的类，但是它的接口与你的代码不兼容时，可以使用适配器模式。</p>
</li>
<li class="lvl-2">
<p>在系统扩展阶段需要增加新的类时，并且类的接口和系统现有的类不一致时，可以使用适配器模式。</p>
</li>
</ul>
<p>使用适配器模式可以将客户端代码与具体的类解耦，客户端不需要知道被适配者的细节，客户端代码也不需要修改，这使得它具有良好的扩展性，但是这也势必导致系统变得更加复杂。</p>
<h2 id="代理模式">代理模式</h2>
<h3 id="基本概念">基本概念</h3>
<p>代理模式<code>Proxy Pattern</code>是一种结构型设计模式，用于控制对其他对象的访问。</p>
<p>在代理模式中，允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。通常用于在访问某个对象时引入一些间接层(中介的作用)，这样可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。</p>
<p>比如说有一个文件加载的场景，为了避免直接访问“文件”对象，我们可以新增一个代理对象，代理对象中有一个对“文件对象”的引用，在代理对象的 <code>load</code> 方法中，可以在访问真实的文件对象之前进行一些操作，比如权限检查，然后调用真实文件对象的 <code>load</code> 方法，最后在访问真实对象后进行其他操作，比如记录访问日志。</p>
<h3 id="基本结构-4">基本结构</h3>
<p>代理模式的主要角色有：</p>
<p><img src="https://s2.loli.net/2024/05/20/z3xTUAp9EMJyswi.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Subject（抽象主题）： 抽象类，通过接口或抽象类声明真实主题和代理对象实现的业务方法。</p>
</li>
<li class="lvl-2">
<p>RealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。</p>
</li>
<li class="lvl-2">
<p>Proxy（代理）：包含一个引用，该引用可以是RealSubject的实例，控制对RealSubject的访问，并可能负责创建和删除RealSubject的实例。</p>
</li>
</ul>
<h3 id="实现方式">实现方式</h3>
<p>代理模式的基本实现分为以下几个步骤：</p>
<ol>
<li class="lvl-3">
<p>定义抽象主题, 一般是接口或者抽象类，声明真实主题和代理对象实现的业务方法。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义抽象主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>定义真实主题，实现抽象主题中的具体业务</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 定义真实主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;RealSubject handles the request.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>定义代理类，包含对<code>RealSubject</code>的引用，并提供和真实主题相同的接口，这样代理就可以替代真实主题，并对真实主题进行功能扩展。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 定义代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealSubject* realSubject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>() : <span class="built_in">realSubject</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Proxy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在访问真实主题之前可以添加额外的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用真实主题的方法</span></span><br><span class="line">        realSubject-&gt;<span class="built_in">request</span>();</span><br><span class="line">        <span class="comment">// 在访问真实主题之后可以添加额外的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>客户端使用代理</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 客户端使用代理</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用代理</span></span><br><span class="line">    Subject* proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br><span class="line">    proxy-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-2">应用场景</h3>
<p>代理模式可以控制客户端对真实对象的访问，从而限制某些客户端的访问权限，此外代理模式还常用在访问真实对象之前或之后执行一些额外的操作（比如记录日志），对功能进行扩展。</p>
<p>以上特性决定了代理模式在以下几个场景中有着广泛的应用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>虚拟代理：当一个对象的创建和初始化比较昂贵时，可以使用虚拟代理，虚拟代理可以延迟对象的实际创建和初始化，只有在需要时才真正创建并初始化对象。</p>
</li>
<li class="lvl-2">
<p>安全代理：安全代理可以根据访问者的权限决定是否允许访问真实对象的方法。</p>
</li>
</ul>
<p>但是代理模式涉及到多个对象之间的交互，引入代理模式会增加系统的复杂性，在需要频繁访问真实对象时，还可能会有一些性能问题。</p>
<h2 id="装饰模式">装饰模式</h2>
<h3 id="基本概念-2">基本概念</h3>
<p>通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，子类越多，装饰模式（<code>Decorator Pattern</code>, 结构型设计模式）可以在**不定义子类的情况下动态的给对象添加一些额外的功能。**具体的做法是将原始对象放入包含行为的特殊封装类(装饰类)，从而为原始对象动态添加新的行为，而无需修改其代码。</p>
<h3 id="基本结构：">基本结构：</h3>
<p>装饰模式包含以下四个主要角色：</p>
<p><img src="https://s2.loli.net/2024/05/20/IeqhMl3UPdoWT7K.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>组件<code>Component</code>：通常是抽象类或者接口，是具体组件和装饰者的父类，定义了具体组件需要实现的方法，比如说我们定义<code>Coffee</code>为组件。</p>
</li>
<li class="lvl-2">
<p>具体组件<code>ConcreteComponent</code>: 实现了Component接口的具体类，是<strong>被装饰的对象</strong>。</p>
</li>
<li class="lvl-2">
<p>装饰类<code>Decorator</code>: 一个抽象类，给具体组件添加功能，但是具体的功能由其子类具体装饰者完成，持有一个指向Component对象的引用。</p>
</li>
<li class="lvl-2">
<p>具体装饰类<code>ConcreteDecorator</code>: 扩展Decorator类，负责向Component对象添加新的行为，加牛奶的咖啡是一个具体装饰类，加糖的咖啡也是一个具体装饰类。</p>
</li>
</ul>
<h3 id="基本实现-3">基本实现</h3>
<p>装饰模式的实现包括以下步骤：</p>
<ol>
<li class="lvl-3">
<p>定义Component接口</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>实现 ConcreteComponent</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteComponent operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>定义Decorator装饰类，继承自Component</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个抽象的装饰者类，继承自 Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Component* component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Decorator</span>(Component* component) : <span class="built_in">component</span>(component) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Decorator</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        component-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>定义具体的装饰者实现，给具体组件对象添加功能。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的装饰者实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator</span>(Component* component) : <span class="built_in">Decorator</span>(component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要添加额外的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以在调用前后添加额外的行为</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Before operation in ConcreteDecorator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        Decorator::<span class="built_in">operation</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;After operation in ConcreteDecorator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>在客户端使用</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体组件</span></span><br><span class="line">    Component* concreteComponent = <span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用具体装饰者包装具体组件</span></span><br><span class="line">    Component* decorator = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator</span>(concreteComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用操作</span></span><br><span class="line">    decorator-&gt;<span class="built_in">operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> decorator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-3">应用场景</h3>
<p>装饰模式通常在以下几种情况使用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当需要给一个现有类添加附加功能，但由于某些原因不能使用继承来生成子类进行扩充时，可以使用装饰模式。</p>
</li>
<li class="lvl-2">
<p>动态的添加和覆盖功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使用装饰模式。</p>
</li>
</ul>
<h2 id="外观模式">外观模式</h2>
<h3 id="基本概念-3">基本概念</h3>
<p>外观模式<code>Facade Pattern</code>, 也被称为“门面模式”，是一种结构型设计模式，外观模式定义了一个高层接口，这个接口使得子系统更容易使用，同时也隐藏了子系统的复杂性。</p>
<blockquote>
<p>门面模式可以将子系统关在“门里”隐藏起来，客户端只需要通过外观接口与外观对象进行交互，而不需要直接和多个子系统交互，无论子系统多么复杂，对于外部来说是隐藏的，这样可以降低系统的耦合度。</p>
</blockquote>
<h3 id="基本结构-5">基本结构</h3>
<p>外观模式的基本结构比较简单，只包括“外观”和“子系统类”</p>
<p><img src="https://s2.loli.net/2024/05/20/mnQCkq5vwKPBRVZ.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>外观类：对外提供一个统一的高层次接口，使复杂的子系统变得更易使用。</p>
</li>
<li class="lvl-2">
<p>子系统类：实现子系统的功能，处理外观类指派的任务。</p>
</li>
</ul>
<h3 id="简易实现-2">简易实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子系统A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubsystemA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SubsystemA operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubsystemB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SubsystemB operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubsystemC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operationC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SubsystemC operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SubsystemA* subsystemA;</span><br><span class="line">    SubsystemB* subsystemB;</span><br><span class="line">    SubsystemC* subsystemC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Facade</span>() &#123;</span><br><span class="line">        subsystemA = <span class="keyword">new</span> <span class="built_in">SubsystemA</span>();</span><br><span class="line">        subsystemB = <span class="keyword">new</span> <span class="built_in">SubsystemB</span>();</span><br><span class="line">        subsystemC = <span class="keyword">new</span> <span class="built_in">SubsystemC</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Facade</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> subsystemA;</span><br><span class="line">        <span class="keyword">delete</span> subsystemB;</span><br><span class="line">        <span class="keyword">delete</span> subsystemC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外观方法，封装了对子系统的操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">facadeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subsystemA-&gt;<span class="built_in">operationA</span>();</span><br><span class="line">        subsystemB-&gt;<span class="built_in">operationB</span>();</span><br><span class="line">        subsystemC-&gt;<span class="built_in">operationC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建外观对象</span></span><br><span class="line">    Facade facade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端通过外观类调用子系统的操作</span></span><br><span class="line">    facade.<span class="built_in">facadeOperation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>Facade</code> 类是外观类，封装了对三个子系统<code>SubSystem</code>的操作。客户端通过调用外观类的方法来实现对子系统的访问，而不需要直接调用子系统的方法。</p>
<h3 id="优缺点和使用场景">优缺点和使用场景</h3>
<p>外观模式通过提供一个简化的接口，隐藏了系统的复杂性，降低了客户端和子系统之间的耦合度，客户端不需要了解系统的内部实现细节，也不需要直接和多个子系统交互，只需要通过外观接口与外观对象进行交互。</p>
<p>但是如果需要添加新的子系统或修改子系统的行为，就可能需要修改外观类，这违背了“开闭原则”。</p>
<h2 id="桥接模式">桥接模式</h2>
<h3 id="基本概念-4">基本概念</h3>
<p>桥接模式（Bridge Pattern）是一种结构型设计模式，它的UML图很像一座桥，它通过将【抽象部分】与【实现部分】分离，使它们可以独立变化，从而达到降低系统耦合度的目的。桥接模式的主要目的是通过组合建立两个类之间的联系，而不是继承的方式。</p>
<p><img src="https://s2.loli.net/2024/05/20/CcKveOiLo1SAjZm.png" alt=""></p>
<h3 id="基本结构-6">基本结构</h3>
<p>桥接模式的基本结构分为以下几个角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抽象<code>Abstraction</code>：一般是抽象类，定义抽象部分的接口，维护一个对【实现】的引用。</p>
</li>
<li class="lvl-2">
<p>修正抽象<code>RefinedAbstaction</code>：对抽象接口进行扩展，通常对抽象化的不同维度进行变化或定制。</p>
</li>
<li class="lvl-2">
<p>实现<code>Implementor</code>： 定义实现部分的接口，提供具体的实现。这个接口通常是抽象化接口的实现。</p>
</li>
<li class="lvl-2">
<p>具体实现<code>ConcreteImplementor</code>：实现实现化接口的具体类。这些类负责实现实现化接口定义的具体操作。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/20/o86d4akhAUOSzfg.png" alt=""></p>
<h3 id="简易实现-3">简易实现</h3>
<p>下面是实现桥接模式的基本步骤：</p>
<ol>
<li class="lvl-3">
<p>定义实现接口</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Implementation</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>创建具体实现类</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationA</span> : <span class="keyword">public</span> Implementation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteImplementationA operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementationB</span> : <span class="keyword">public</span> Implementation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operationImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteImplementationB operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>创建抽象接口</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Implementation* implementation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Abstraction</span>(Implementation* implementation) : <span class="built_in">implementation</span>(implementation) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Abstraction</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        implementation-&gt;<span class="built_in">operationImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>实现抽象接口，创建 RefinedAbstraction 类</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩充抽象化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> : <span class="keyword">public</span> Abstraction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefinedAbstraction</span>(Implementation* implementation) : <span class="built_in">Abstraction</span>(implementation) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        implementation-&gt;<span class="built_in">operationImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>客户端代码</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体实现化对象</span></span><br><span class="line">    Implementation* implementationA = <span class="keyword">new</span> <span class="built_in">ConcreteImplementationA</span>();</span><br><span class="line">    Implementation* implementationB = <span class="keyword">new</span> <span class="built_in">ConcreteImplementationB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用扩充抽象化对象，将实现化对象传递进去</span></span><br><span class="line">    Abstraction* abstractionA = <span class="keyword">new</span> <span class="built_in">RefinedAbstraction</span>(implementationA);</span><br><span class="line">    Abstraction* abstractionB = <span class="keyword">new</span> <span class="built_in">RefinedAbstraction</span>(implementationB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用抽象化的操作</span></span><br><span class="line">    abstractionA-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    abstractionB-&gt;<span class="built_in">operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> abstractionA;</span><br><span class="line">    <span class="keyword">delete</span> abstractionB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-4">使用场景</h3>
<p>桥接模式在日常开发中使用的并不是特别多，通常在以下情况下使用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当一个类存在两个独立变化的维度，而且这两个维度都需要进行扩展时，使用桥接模式可以使它们独立变化，减少耦合。</p>
</li>
<li class="lvl-2">
<p>不希望使用继承，或继承导致类爆炸性增长</p>
</li>
</ul>
<p>总体而言，桥接模式适用于那些有多个独立变化维度、需要灵活扩展的系统。</p>
<h2 id="组合模式">组合模式</h2>
<h3 id="基本概念-5">基本概念</h3>
<p>组合模式是一种结构型设计模式，它<strong>将对象组合成树状结构</strong>来表示“部分-整体”的层次关系。组合模式使得客户端可以<strong>统一处理单个对象和对象的组合</strong>，而无需区分它们的具体类型。</p>
<h3 id="基本结构-7">基本结构</h3>
<p>组合模式包括下面几个角色：</p>
<p><img src="https://s2.loli.net/2024/05/20/OhSQc7dMLovstJb.png" alt=""><code>Component</code>组件： 组合模式的“根节点”，定义组合中所有对象的通用接口，可以是抽象类或接口。该类中定义了子类的共性内容。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Leaf</code>叶子：实现了Component接口的叶子节点，表示组合中的叶子对象，叶子节点没有子节点。</p>
</li>
<li class="lvl-2">
<p><code>Composite</code>合成： 作用是存储子部件，并且在Composite中实现了对子部件的相关操作，比如添加、删除、获取子组件等。</p>
</li>
</ul>
<p>通过组合模式，整个省份的获取信息操作可以一次性地执行，而无需关心省份中的具体城市。这样就实现了对国家省份和城市的管理和操作。</p>
<h3 id="简易实现-4">简易实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Leaf operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合节点：包含叶子节点的操作行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Component*&gt; components;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Composite</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (Component* component : components) &#123;</span><br><span class="line">            <span class="keyword">delete</span> component;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* component)</span> </span>&#123;</span><br><span class="line">        components.<span class="built_in">push_back</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* component)</span> </span>&#123;</span><br><span class="line">        components.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(components.<span class="built_in">begin</span>(), components.<span class="built_in">end</span>(), component), components.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Composite operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (Component* component : components) &#123;</span><br><span class="line">            component-&gt;<span class="built_in">operation</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    Component* leaf = <span class="keyword">new</span> <span class="built_in">Leaf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建组合节点，并添加叶子节点</span></span><br><span class="line">    Composite* composite = <span class="keyword">new</span> <span class="built_in">Composite</span>();</span><br><span class="line">    composite-&gt;<span class="built_in">add</span>(leaf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一调用</span></span><br><span class="line">    composite-&gt;<span class="built_in">operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> composite;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-5">使用场景</h3>
<p>组合模式可以使得客户端可以统一处理单个对象和组合对象，无需区分它们之间的差异，比如在图形编辑器中，图形对象可以是简单的线、圆形，也可以是复杂的组合图形，这个时候可以对组合节点添加统一的操作。</p>
<p>总的来说，组合模式适用于任何需要构建具有部分-整体层次结构的场景，比如组织架构管理、文件系统的文件和文件夹组织等。</p>
<h2 id="享元模式">享元模式</h2>
<h3 id="基础概念">基础概念</h3>
<p>享元模式是一种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下文使用，而不必在每个上下文中都创建新的对象。想要了解享元模式，就必须要区分什么是内部状态，什么是外部状态。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内部状态是指那些可以被多个对象共享的状态，它存储在享元对象内部，并且对于所有享元对象都是相同的，这部分状态通常是不变的。</p>
</li>
<li class="lvl-2">
<p>而外部状态是享元对象依赖的、可能变化的部分。这部分状态不存储在享元对象内部，而是在使用享元对象时通过参数传递给对象。</p>
</li>
</ul>
<h3 id="基本结构-8">基本结构</h3>
<p>享元模式包括以下几个重要角色：</p>
<p><img src="https://s2.loli.net/2024/05/20/HFL8fMh3EXwglYd.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>享元接口<code>Flyweight</code>: 所有具体享元类的共享接口，通常包含对外部状态的操作。</p>
</li>
<li class="lvl-2">
<p>具体享元类<code>ConcreteFlyweight</code>: 继承<code>Flyweight</code>类或实现享元接口，包含内部状态。</p>
</li>
<li class="lvl-2">
<p>享元工厂类<code>FlyweightFactory</code>: 创建并管理享元对象，当用户请求时，提供已创建的实例或者创建一个。</p>
</li>
<li class="lvl-2">
<p>客户端<code>Client</code>: 维护外部状态，在使用享元对象时，将外部状态传递给享元对象。</p>
</li>
</ul>
<h3 id="简易实现-5">简易实现</h3>
<p>享元模式的实现通常涉及以下步骤：</p>
<ol>
<li class="lvl-3">
<p>定义享元接口，接受外部状态作为参数并进行处理。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Flyweight</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operation</span><span class="params">(<span class="type">const</span> std::string&amp; externalState)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>实现具体享元类, 存储内部状态。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体享元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> : <span class="keyword">public</span> Flyweight &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string intrinsicState; <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFlyweight</span>(<span class="type">const</span> std::string&amp; intrinsicState) : <span class="built_in">intrinsicState</span>(intrinsicState) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">(<span class="type">const</span> std::string&amp; externalState)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Intrinsic State: &quot;</span> &lt;&lt; intrinsicState &lt;&lt; <span class="string">&quot;, External State: &quot;</span> &lt;&lt; externalState &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>创建享元工厂类，创建并管理<code>Flyweight</code>对象，当用户请求一个<code>Flyweight</code>时，享元工厂会提供一个已经创建的实例或者创建一个。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, Flyweight*&gt; flyweights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">FlyweightFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : flyweights) &#123;</span><br><span class="line">            <span class="keyword">delete</span> pair.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Flyweight* <span class="title">getFlyweight</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flyweights.<span class="built_in">find</span>(key) == flyweights.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            flyweights[key] = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweight</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweights[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>客户端使用享元模式</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FlyweightFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取或创建享元对象，并传递外部状态</span></span><br><span class="line">    Flyweight* flyweight1 = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    flyweight1-&gt;<span class="built_in">operation</span>(<span class="string">&quot;External State 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Flyweight* flyweight2 = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    flyweight2-&gt;<span class="built_in">operation</span>(<span class="string">&quot;External State 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Flyweight* flyweight3 = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;A&quot;</span>); <span class="comment">// 重复使用已存在的享元对象</span></span><br><span class="line">    flyweight3-&gt;<span class="built_in">operation</span>(<span class="string">&quot;External State 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用场景-6">使用场景</h3>
<p>使用享元模式的关键在于包含大量相似对象，并且这些对象的内部状态可以共享。具体的应用场景包括文本编辑器，图形编辑器，游戏中的角色创建，这些对象的内部状态比较固定(外观，技能，形状)，但是外部状态变化比较大时，可以使用。</p>
<h1>行为型模式</h1>
<h2 id="观察者模式">观察者模式</h2>
<p>观察者模式（发布-订阅模式）属于行为型模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。</p>
<h3 id="基本概念-6">基本概念</h3>
<p>观察者模式依赖两个模块：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Subject</code>(主题)：也就是被观察的对象，它可以维护一组观察者，当主题本身发生改变时就会通知观察者。</p>
</li>
<li class="lvl-2">
<p><code>Observer</code>(观察者)：观察主题的对象，当“被观察”的主题发生变化时，观察者就会得到通知并执行相应的处理。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/20/q7uIrSaiHXgFzlO.png" alt=""></p>
<p>使用观察者模式有很多好处，比如说观察者模式将主题和观察者之间的关系解耦，主题只需要关注自己的状态变化，而观察者只需要关注在主题状态变化时需要执行的操作，两者互不干扰，并且由于观察者和主题是相互独立的，可以轻松的增加和删除观察者，这样实现的系统更容易扩展和维护。</p>
<h3 id="基本结构-9">基本结构</h3>
<p>观察者模式依赖主题和观察者，但是一般有4个组成部分：</p>
<p><img src="https://s2.loli.net/2024/05/20/scGRXTK1oHxVIwB.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>主题Subject</code>， 一般会定义成一个接口，提供方法用于<strong>注册、删除和通知观察者</strong>，通常也包含一个状态，当状态发生改变时，通知所有的观察者。</p>
</li>
<li class="lvl-2">
<p><code>观察者Observer</code>: 观察者也需要实现一个接口，包含一个更新方法，在接收主题通知时执行对应的操作。</p>
</li>
<li class="lvl-2">
<p><code>具体主题ConcreteSubject</code>: 主题的具体实现, 维护一个观察者列表，包含了观察者的注册、删除和通知方法。</p>
</li>
<li class="lvl-2">
<p><code>具体观察者ConcreteObserver</code>: 观察者接口的具体实现，每个具体观察者都注册到具体主题中，当主题状态变化并通知到具体观察者，具体观察者进行处理。</p>
</li>
</ul>
<h3 id="基本实现-4">基本实现</h3>
<p>根据上面的类图，我们可以写出观察者模式的基本实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体主题实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;</span><br><span class="line">    std::string state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer), observers.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer* observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(<span class="type">const</span> std::string&amp; newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Observer received message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteSubject subject;</span><br><span class="line"></span><br><span class="line">    ConcreteObserver observer1;</span><br><span class="line">    ConcreteObserver observer2;</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">registerObserver</span>(&amp;observer1);</span><br><span class="line">    subject.<span class="built_in">registerObserver</span>(&amp;observer2);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">setState</span>(<span class="string">&quot;State 1&quot;</span>);</span><br><span class="line">    subject.<span class="built_in">setState</span>(<span class="string">&quot;State 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    subject.<span class="built_in">removeObserver</span>(&amp;observer1);</span><br><span class="line">    subject.<span class="built_in">setState</span>(<span class="string">&quot;State 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-7">使用场景</h3>
<p>观察者模式特别适用于<strong>一个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够自动更新的情况。</strong> 比如说在图形用户界面中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被广泛应用于GUI框架，比如Java的Swing框架。</p>
<p>此外，观察者模式在前端开发和分布式系统中也有应用，比较典型的例子是前端框架<code>Vue</code>, 当数据发生变化时，视图会自动更新。而在分布式系统中，观察者模式可以用于实现节点之间的消息通知机制，节点的状态变化将通知其他相关节点。</p>
<h2 id="策略模式">策略模式</h2>
<h3 id="基本概念-7">基本概念</h3>
<p>策略模式是一种行为型设计模式，它定义了一系列算法（这些算法完成的是相同的工作，只是实现不同），并将每个算法封装起来，使它们可以相互替换，而且算法的变化不会影响使用算法的客户。</p>
<p><img src="https://s2.loli.net/2024/05/20/tMTy2ln8F914gfL.png" alt=""></p>
<h3 id="基本结构-10">基本结构</h3>
<p>策略模式包含下面几个结构：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>策略类<code>Strategy</code>: 定义所有支持的算法的公共接口。</p>
</li>
<li class="lvl-2">
<p>具体策略类<code>ConcreteStrategy</code>: 实现了策略接口，提供具体的算法实现。</p>
</li>
<li class="lvl-2">
<p>上下文类<code>Context</code>: 包含一个策略实例，并在需要时调用策略对象的方法。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/20/qNTOlrsLnHEyXYM.png" alt=""></p>
<h3 id="简单实现">简单实现</h3>
<p>下面是一个简单的策略模式的基本实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象策略类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，定义算法接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 具体的策略1执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strategy B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 具体的策略2执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* strategy; <span class="comment">// 持有策略的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，设置具体的策略</span></span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy) : <span class="built_in">strategy</span>(strategy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">contextInterface</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        strategy-&gt;<span class="built_in">algorithmInterface</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：设置策略的方法，可以动态切换策略</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建上下文对象，并设置具体的策略</span></span><br><span class="line">    <span class="function">Context <span class="title">contextA</span><span class="params">(<span class="keyword">new</span> ConcreteStrategyA())</span></span>;</span><br><span class="line">    <span class="comment">// 执行策略</span></span><br><span class="line">    contextA.<span class="built_in">contextInterface</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Context <span class="title">contextB</span><span class="params">(<span class="keyword">new</span> ConcreteStrategyB())</span></span>;</span><br><span class="line">    contextB.<span class="built_in">contextInterface</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-8">使用场景</h3>
<p>那什么时候可以考虑使用策略模式呢？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当一个系统根据业务场景需要动态地在几种算法中选择一种时，可以使用策略模式。例如，根据用户的行为选择不同的计费策略。</p>
</li>
<li class="lvl-2">
<p>当代码中存在大量条件判断，条件判断的区别仅仅在于行为，也可以通过策略模式来消除这些条件语句。</p>
</li>
</ul>
<h2 id="命令模式">命令模式</h2>
<h3 id="基本概念-8">基本概念</h3>
<p>命令模式是一种行为型设计模式，其允许<strong>将请求封装成一个对象</strong>(命令对象，包含执行操作所需的所有信息)，<strong>并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。</strong></p>
<p>这样一来，发送者只需要触发命令就可以完成操作，不需要知道接受者的具体操作，从而实现两者间的解耦。</p>
<h3 id="基本结构-11">基本结构</h3>
<p>命令模式包含以下几个基本角色：</p>
<p><img src="https://s2.loli.net/2024/05/20/a1HnKET6FfCuvmQ.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>命令接口<code>Command</code>：接口或者抽象类，定义执行操作的接口。</p>
</li>
<li class="lvl-2">
<p>具体命令类<code>ConcreteCommand</code>: 实现命令接口，执行具体操作，在调用<code>execute</code>方法时使“接收者对象”根据命令完成具体的任务</p>
</li>
<li class="lvl-2">
<p>接收者类<code>Receiver</code>: 接受并执行命令的对象，可以是任何对象</p>
</li>
<li class="lvl-2">
<p>调用者类<code>Invoker</code>: 发起请求的对象，有一个将命令作为参数传递的方法。它不关心命令的具体实现，只负责调用命令对象的 <code>execute()</code> 方法来传递请求</p>
</li>
<li class="lvl-2">
<p>客户端：创建具体的命令对象和接收者对象，然后将它们组装起来。</p>
</li>
</ul>
<h3 id="简易实现-6">简易实现</h3>
<ol>
<li class="lvl-3">
<p>定义执行操作的接口：包含一个<code>execute</code>方法。有的时候还会包括<code>unExecute</code>方法，表示撤销命令。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>实现命令接口，执行具体的操作。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver* receiver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>(Receiver* receiver) : <span class="built_in">receiver</span>(receiver) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        receiver-&gt;<span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        receiver-&gt;<span class="built_in">undoAction</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>定义接受者类，知道如何实施与执行一个请求相关的操作。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Action executed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Action undone.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>定义调用者类，调用命令对象执行请求。</p>
</li>
</ol>
<p>调用者类中可以维护一个命令队列或者“撤销栈”，以支持批处理和撤销命令。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Command&gt;&gt; commandQueue; <span class="comment">// 命令队列</span></span><br><span class="line">    std::stack&lt;std::shared_ptr&lt;Command&gt;&gt; undoStack;    <span class="comment">// 撤销栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAndExecuteCommand</span><span class="params">(std::shared_ptr&lt;Command&gt; command)</span> </span>&#123;</span><br><span class="line">        command-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        commandQueue.<span class="built_in">push</span>(command);</span><br><span class="line">        undoStack.<span class="built_in">push</span>(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undoLastCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!undoStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lastCommand = undoStack.<span class="built_in">top</span>();</span><br><span class="line">            undoStack.<span class="built_in">pop</span>();</span><br><span class="line">            lastCommand-&gt;<span class="built_in">undo</span>();</span><br><span class="line">            <span class="built_in">removeCommandFromQueue</span>(lastCommand);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No command to undo.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令队列中的所有命令</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeCommandsInQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::queue&lt;Command*&gt; tempQueue = commandQueue; <span class="comment">// 临时队列，用于遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!tempQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Command* command = tempQueue.<span class="built_in">front</span>();</span><br><span class="line">            command-&gt;<span class="built_in">execute</span>();</span><br><span class="line">            tempQueue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 从队列中移除命令</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCommandFromQueue</span><span class="params">(Command* command)</span> </span>&#123;</span><br><span class="line">        std::queue&lt;Command*&gt; tempQueue;</span><br><span class="line">        <span class="keyword">while</span> (!commandQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Command* currentCommand = commandQueue.<span class="built_in">front</span>();</span><br><span class="line">            commandQueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (currentCommand != command) &#123;</span><br><span class="line">                tempQueue.<span class="built_in">push</span>(currentCommand);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        commandQueue = tempQueue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>客户端使用，创建具体的命令对象和接收者对象，然后进行组装。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建接收者对象</span></span><br><span class="line">    <span class="keyword">auto</span> receiver = std::<span class="built_in">make_shared</span>&lt;Receiver&gt;();</span><br><span class="line">    <span class="comment">// 创建具体命令对象</span></span><br><span class="line">    <span class="keyword">auto</span> command = std::<span class="built_in">make_shared</span>&lt;ConcreteCommand&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">// 创建调用者对象</span></span><br><span class="line">    Invoker invoker;</span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    invoker.<span class="built_in">setAndExecuteCommand</span>(command);</span><br><span class="line">    <span class="comment">// 撤销命令</span></span><br><span class="line">    invoker.<span class="built_in">undoLastCommand</span>();</span><br><span class="line">    <span class="comment">// 执行命令队列中的所有命令</span></span><br><span class="line">    invoker.<span class="built_in">executeCommandsInQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优缺点和使用场景-2">优缺点和使用场景</h3>
<p>命令模式在需要将请求封装成对象、支持撤销和重做、设计命令队列等情况下，都是一个有效的设计模式。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>撤销操作：</strong> 需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。</p>
</li>
<li class="lvl-2">
<p><strong>队列请求：</strong> 命令模式可以将请求排队，形成一个命令队列，依次执行命令。</p>
</li>
<li class="lvl-2">
<p><strong>可扩展性：</strong> 可以很容易地添加新的命令类和接收者类，而不影响现有的代码。新增命令不需要修改现有代码，符合开闭原则。</p>
</li>
</ul>
<p>但是对于每个命令，都会有一个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。</p>
<h2 id="中介者模式">中介者模式</h2>
<h3 id="基本概念-9">基本概念</h3>
<p>中介者模式（Mediator Pattern）也被称为调停者模式，是一种行为型设计模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。</p>
<h3 id="基本结构-12">基本结构</h3>
<p>中介者模式包括以下几个重要角色：</p>
<p><img src="https://s2.loli.net/2024/05/20/LcvKr5OwERTS6uA.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>抽象中介者（Mediator）：</strong> 定义中介者的接口，用于各个具体同事对象之间的通信。</p>
</li>
<li class="lvl-2">
<p><strong>具体中介者（Concrete Mediator）：</strong> 实现抽象中介者接口，负责协调各个具体同事对象的交互关系，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。</p>
</li>
<li class="lvl-2">
<p><strong>抽象同事类（Colleague）：</strong> 定义同事类的接口，维护一个对中介者对象的引用，用于通信。</p>
</li>
<li class="lvl-2">
<p><strong>具体同事类（Concrete Colleague）：</strong> 实现抽象同事类接口，每个具体同事类只知道自己的行为，而不了解其他同事类的情况，因为它们都需要与中介者通信，通过中介者协调与其他同事对象的交互。</p>
</li>
</ul>
<h3 id="简易实现-7">简易实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerColleague</span><span class="params">(Colleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(std::string message, Colleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Colleague*&gt; colleagues;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerColleague</span><span class="params">(Colleague* colleague)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        colleagues.<span class="built_in">push_back</span>(colleague);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string message, Colleague* colleague)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague* c : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != colleague) &#123;</span><br><span class="line">                c-&gt;<span class="built_in">receive</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同事对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Mediator* mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Colleague</span>(Mediator* mediator) : <span class="built_in">mediator</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(std::string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(std::string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事对象1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleague1</span>(Mediator* mediator) : <span class="built_in">Colleague</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mediator-&gt;<span class="built_in">send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteColleague1 received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事对象2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague2</span> : <span class="keyword">public</span> Colleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleague2</span>(Mediator* mediator) : <span class="built_in">Colleague</span>(mediator) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mediator-&gt;<span class="built_in">send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(std::string message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteColleague2 received: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建中介者</span></span><br><span class="line">    Mediator* mediator = <span class="keyword">new</span> <span class="built_in">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建同事对象</span></span><br><span class="line">    Colleague* colleague1 = <span class="keyword">new</span> <span class="built_in">ConcreteColleague1</span>(mediator);</span><br><span class="line">    Colleague* colleague2 = <span class="keyword">new</span> <span class="built_in">ConcreteColleague2</span>(mediator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册同事对象到中介者</span></span><br><span class="line">    mediator-&gt;<span class="built_in">registerColleague</span>(colleague1);</span><br><span class="line">    mediator-&gt;<span class="built_in">registerColleague</span>(colleague2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同事对象之间发送消息</span></span><br><span class="line">    colleague1-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hello from Colleague1!&quot;</span>);</span><br><span class="line">    colleague2-&gt;<span class="built_in">send</span>(<span class="string">&quot;Hi from Colleague2!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> colleague1;</span><br><span class="line">    <span class="keyword">delete</span> colleague2;</span><br><span class="line">    <span class="keyword">delete</span> mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-9">使用场景</h3>
<p>中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进行通信，简化了系统的复杂度，也降低了各对象之间的耦合度，但是这也会使得中介者对象变得过于庞大和复杂，如果中介者对象出现问题，整个系统可能会受到影响。</p>
<p>中介者模式适用于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进行灵活的通信时使用，可以使得问题简化，</p>
<h2 id="备忘录模式">备忘录模式</h2>
<h3 id="基本概念-10">基本概念</h3>
<p>备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在<strong>不暴露对象实现的情况下捕获对象的内部状态</strong>并<strong>在对象之外保存这个状态</strong>，以便稍后可以将其还原到先前的状态。</p>
<img src="https://s2.loli.net/2024/05/20/tVInsxHW8u2GOFg.png" style="zoom: 67%;" />
<h3 id="基本结构-13">基本结构</h3>
<p>备忘录模式包括以下几个重要角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>发起人<code>Originator</code>： 需要还原状态的那个对象，负责创建一个【备忘录】，并使用备忘录记录当前时刻的内部状态。</p>
</li>
<li class="lvl-2">
<p>备忘录<code>Memento</code>: 存储发起人对象的内部状态，它可以包含发起人的部分或全部状态信息，但是对外部是不可见的，只有发起人能够访问备忘录对象的状态。</p>
</li>
</ul>
<blockquote>
<p>备忘录有两个接口，发起人能够通过宽接口访问数据，管理者只能看到窄接口，并将备忘录传递给其他对象。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>管理者<code>Caretaker</code>: 负责存储备忘录对象，但并不了解其内部结构，管理者可以存储多个备忘录对象。</p>
</li>
<li class="lvl-2">
<p>客户端：在需要恢复状态时，客户端可以从管理者那里获取备忘录对象，并将其传递给发起人进行状态的恢复。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/20/JKuQRb1VpS6rdt9.png" alt=""></p>
<h3 id="基本实现-5">基本实现</h3>
<ol>
<li class="lvl-3">
<p>创建发起人类：可以创建备忘录对象</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(<span class="type">const</span> std::string&amp; state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录对象</span></span><br><span class="line">    <span class="function">Memento <span class="title">createMemento</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过备忘录对象恢复状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restoreFromMemento</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Memento <span class="title">Originator::createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Memento</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Originator::restoreFromMemento</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">    state = memento.<span class="built_in">getState</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>创建备忘录类：保存发起人对象的状态</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使 Originator 成为 Memento 的友元类，以便它可以访问 Memento 的私有成员</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Originator</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Memento</span>(<span class="type">const</span> std::string&amp; state) : <span class="built_in">state</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>创建管理者：维护一组备忘录对象</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Memento&gt; mementos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMemento</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        mementos.<span class="built_in">push_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">getMemento</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; mementos.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> mementos[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Invalid memento index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>客户端使用备忘录模式</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建发起人对象</span></span><br><span class="line">    Originator originator;</span><br><span class="line">    originator.<span class="built_in">setState</span>(<span class="string">&quot;State 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管理者对象</span></span><br><span class="line">    Caretaker caretaker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前状态</span></span><br><span class="line">    caretaker.<span class="built_in">addMemento</span>(originator.<span class="built_in">createMemento</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改状态</span></span><br><span class="line">    originator.<span class="built_in">setState</span>(<span class="string">&quot;State 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次保存当前状态</span></span><br><span class="line">    caretaker.<span class="built_in">addMemento</span>(originator.<span class="built_in">createMemento</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复到先前状态</span></span><br><span class="line">    originator.<span class="built_in">restoreFromMemento</span>(caretaker.<span class="built_in">getMemento</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current State: &quot;</span> &lt;&lt; originator.<span class="built_in">getState</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用场景-10">使用场景</h3>
<p>备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起人，实现“备份”，不过 备份对象往往会消耗较多的内存，资源消耗增加。</p>
<h2 id="模板方法模式">模板方法模式</h2>
<h3 id="基本概念-11">基本概念</h3>
<p>模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。【引用自大话设计第10章】</p>
<h3 id="基本结构-14">基本结构</h3>
<p>模板方法模式的基本结构包含以下两个角色：</p>
<p><img src="https://s2.loli.net/2024/05/20/n98PpzOCqGlLiZS.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>模板类<code>AbstractClass</code>：由一个模板方法和若干个基本方法构成，模板方法定义了逻辑的骨架，按照顺序调用包含的基本方法，基本方法通常是一些<strong>抽象方法，这些方法由子类去实现</strong>。基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，在具体子类中可以继承或者重写。</p>
</li>
<li class="lvl-2">
<p>具体类<code>ConcreteClass</code>：继承自模板类，实现了在模板类中定义的抽象方法，以完成算法中特定步骤的具体实现。</p>
</li>
</ul>
<h3 id="简易实现-8">简易实现</h3>
<p>模板方法模式的简单示例如下：</p>
<ol>
<li class="lvl-3">
<p>定义模板类，包含模板方法，定义了算法的骨架, 一般都加上<code>final</code>关键字，避免子类重写。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 模板方法，定义了算法的骨架</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">step1</span>();</span><br><span class="line">        <span class="built_in">step2</span>();</span><br><span class="line">        <span class="built_in">step3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 虚函数，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">step3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>定义具体类, 实现模板类中的抽象方法</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass&lt;ConcreteClass&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">step3</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Step 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>客户端实现</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteClass concreteTemplate;</span><br><span class="line">    <span class="comment">// 触发整个算法的执行</span></span><br><span class="line">    concreteTemplate.<span class="built_in">templateMethod</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-4">应用场景</h3>
<p>模板方法模式将算法的不变部分被封装在模板方法中，而可变部分算法由子类继承实现，这样做可以很好的提高代码的复用性，但是当算法的框架发生变化时，可能需要修改模板类，这也会影响到所有的子类。</p>
<h2 id="迭代器模式">迭代器模式</h2>
<h3 id="基本概念-12">基本概念</h3>
<p>迭代器模式是一种行为设计模式，是一种使用频率非常高的设计模式，在各个语言中都有应用，其主要目的是**提供一种统一的方式来访问一个聚合对象中的各个元素，**而不需要暴露该对象的内部表示。通过迭代器，客户端可以顺序访问聚合对象的元素，而无需了解底层数据结构。</p>
<blockquote>
<p>迭代器模式应用广泛，但是大多数语言都已经内置了迭代器接口，不需要自己实现。</p>
</blockquote>
<h3 id="基本结构-15">基本结构</h3>
<p>迭代器模式包括以下几个重要角色</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>迭代器接口<code>Iterator</code>：定义访问和遍历元素的接口, 通常会包括<code>hasNext()</code>方法用于检查是否还有下一个元素，以及<code>next()</code>方法用于获取下一个元素。有的还会实现获取第一个元素以及获取当前元素的方法。</p>
</li>
<li class="lvl-2">
<p>具体迭代器<code>ConcreateIterator</code>：实现迭代器接口，实现遍历逻辑对聚合对象进行遍历。</p>
</li>
<li class="lvl-2">
<p>抽象聚合类：定义了创建迭代器的接口，包括一个<code>createIterator</code>方法用于创建一个迭代器对象。</p>
</li>
<li class="lvl-2">
<p>具体聚合类：实现在抽象聚合类中声明的<code>createIterator() </code>方法，返回一个与具体聚合对应的具体迭代器</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/20/HVEXBnOdtPm6Ii4.png" alt=""></p>
<h3 id="简易实现-9">简易实现</h3>
<ol>
<li class="lvl-3">
<p>定义迭代器接口：通常会有检查是否还有下一个元素以及获取下一个元素的方法。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否还有下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>定义具体迭代器：实现迭代器接口，遍历集合。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    std::vector&lt;<span class="type">void</span>*&gt; elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数初始化迭代器</span></span><br><span class="line">    <span class="built_in">ConcreteIterator</span>(<span class="type">const</span> std::vector&lt;<span class="type">void</span>*&gt;&amp; elements)</span><br><span class="line">        : <span class="built_in">elements</span>(elements), <span class="built_in">index</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; elements.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> elements[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>定义聚合接口：通常包括<code>createIterator()</code>方法，用于创建迭代器</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iterable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterable</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">createIterator</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>实现具体聚合：创建具体的迭代器</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterable</span> : <span class="keyword">public</span> Iterable &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">void</span>*&gt; elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数初始化可迭代对象</span></span><br><span class="line">    <span class="built_in">ConcreteIterable</span>(<span class="type">const</span> std::vector&lt;<span class="type">void</span>*&gt;&amp; elements)</span><br><span class="line">        : <span class="built_in">elements</span>(elements) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator* <span class="title">createIterator</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>客户端使用</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">void</span>*&gt; elements;</span><br><span class="line">    elements.<span class="built_in">push_back</span>((<span class="type">void</span>*)<span class="string">&quot;Element 1&quot;</span>);</span><br><span class="line">    elements.<span class="built_in">push_back</span>((<span class="type">void</span>*)<span class="string">&quot;Element 2&quot;</span>);</span><br><span class="line">    elements.<span class="built_in">push_back</span>((<span class="type">void</span>*)<span class="string">&quot;Element 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterable* iterable = <span class="keyword">new</span> <span class="built_in">ConcreteIterable</span>(elements);</span><br><span class="line">    Iterator* iterator = iterable-&gt;<span class="built_in">createIterator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator-&gt;<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(iterator-&gt;<span class="built_in">next</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> iterator;</span><br><span class="line">    <span class="keyword">delete</span> iterable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-11">使用场景</h3>
<p>迭代器模式是一种通用的设计模式，其封装性强，简化了客户端代码，客户端不需要知道集合的内部结构，只需要关心迭代器和迭代接口就可以完成元素的访问。但是引入迭代器模式会增加额外的类，每增加一个集合类，都需要增加该集合对应的迭代器，这也会使得代码结构变得更加复杂。</p>
<h2 id="状态模式">状态模式</h2>
<h3 id="基本结构-16">基本结构</h3>
<p>状态模式（State Pattern）是一种行为型设计模式，它适用于一个对象在在不同的状态下有不同的行为时，比如说电灯的开、关、闪烁是不停的状态，状态不同时，对应的行为也不同，在没有状态模式的情况下，为了添加新的状态或修改现有的状态，往往<strong>需要修改已有的代码</strong>，这违背了开闭原则，而且如果对象的状态切换逻辑和各个状态的行为都在同一个类中实现，就可能导致该类的职责过重，不符合单一职责原则。</p>
<p>而状态模式将每个状态的行为封装在一个具体状态类中，使得每个状态类相对独立，并将对象在不同状态下的行为进行委托，从而使得对象的状态可以在运行时动态改变，每个状态的实现也不会影响其他状态。</p>
<h3 id="基本结构：-2">基本结构：</h3>
<p>状态模式包括以下几个重要角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>State</code>（状态）： 定义一个接口，用于封装与Context的一个特定状态相关的行为。</p>
</li>
<li class="lvl-2">
<p><code>ConcreteState</code>（具体状态）： 负责处理Context在状态改变时的行为, 每一个具体状态子类实现一个与<code>Context</code>的一个状态相关的行为。</p>
</li>
<li class="lvl-2">
<p><code>Context</code>（上下文）: 维护一个具体状态子类的实例，这个实例定义当前的状态。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/20/vDHmd7BIAwbMqzP.png" alt=""></p>
<h3 id="基本使用、">基本使用、</h3>
<ol>
<li class="lvl-3">
<p>定义状态接口：创建一个状态接口，该接口声明了对象可能的各种状态对应的方法。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，定义在不同状态下的行为</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>实现具体状态类： 为对象可能的每种状态创建具体的状态类，实现状态接口中定义的方法。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体状态类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteState1</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Handling state 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteState2</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Handling state 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>创建上下文类：该类包含对状态的引用，并在需要时调用当前状态的方法。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;State&gt; currentState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;State&gt;&amp; state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState) &#123;</span><br><span class="line">            currentState-&gt;<span class="built_in">handle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;State is not set!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>客户端使用：创建具体的状态对象和上下文对象，并通过上下文对象调用相应的方法。通过改变状态，可以改变上下文对象的行为</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;State&gt; state1 = std::<span class="built_in">make_shared</span>&lt;ConcreteState1&gt;();</span><br><span class="line">    std::shared_ptr&lt;State&gt; state2 = std::<span class="built_in">make_shared</span>&lt;ConcreteState2&gt;();</span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setState</span>(state1);</span><br><span class="line">    context.<span class="built_in">request</span>(); <span class="comment">// 执行在状态1下的操作</span></span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">setState</span>(state2);</span><br><span class="line">    context.<span class="built_in">request</span>(); <span class="comment">// 执行在状态2下的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-12">使用场景</h3>
<p>状态模式将每个状态的实现都封装在一个类中，每个状态类的实现相对独立，使得添加新状态或修改现有状态变得更加容易，避免了使用大量的条件语句来控制对象的行为。但是如果状态过多，会导致类的数量增加，可能会使得代码结构复杂。</p>
<h2 id="责任链模式">责任链模式</h2>
<h3 id="基本概念-13">基本概念</h3>
<p>责任链模式是一种行为型设计模式，它允许你构建一个对象链，让请求从链的一端进入，然后沿着链上的对象依次处理，直到链上的某个对象能够处理该请求为止。</p>
<p><img src="https://s2.loli.net/2024/05/20/9iROwIlCoaDzNE7.png" alt="">职责链上的处理者就是一个对象，可以对请求进行处理或者将请求转发给下一个节点，这个场景在生活中很常见，就是一个逐层向上递交的过程，最终的请求要么被处理者所处理，要么处理不了，这也因此可能导致请求无法被处理。</p>
<h3 id="组成结构">组成结构</h3>
<p>责任链模式包括以下几个基本结构：</p>
<ol>
<li class="lvl-3">
<p>处理者<code>Handler</code> ：定义一个处理请求的接口，包含一个处理请求的抽象方法和一个指向下一个处理者的链接。</p>
</li>
<li class="lvl-3">
<p>具体处理者<code>ConcreteHandler</code>: 实现处理请求的方法，并判断能否处理请求，如果能够处理请求则进行处理，否则将请求传递给下一个处理者。</p>
</li>
<li class="lvl-3">
<p>客户端：创建并组装处理者对象链，并将请求发送到链上的第一个处理者。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/20/mCUlWEP67ZgJRMw.png" alt=""></p>
<h3 id="简易实现-10">简易实现</h3>
<ol>
<li class="lvl-3">
<p>处理者：定义处理请求的接口</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">double</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setNextHandler</span><span class="params">(Handler* nextHandler)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>具体处理者：实现处理请求</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体处理者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Handler* nextHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteHandler</span>() : <span class="built_in">nextHandler</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandle</span>(amount)) &#123;</span><br><span class="line">            <span class="comment">// 处理请求的逻辑</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handled by ConcreteHandler&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 交给下一个处理者处理</span></span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(amount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无法处理请求的逻辑</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Cannot be handled&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextHandler</span><span class="params">(Handler* nextHandler)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 具体处理者自己的判断条件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandle</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据具体情况判断是否能够处理请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* 判断条件 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>客户端创建并组装处理者对象链，将请求发送给链上第一个处理者</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建处理者实例</span></span><br><span class="line">    Handler* handler1 = <span class="keyword">new</span> <span class="built_in">ConcreteHandler</span>();</span><br><span class="line">    Handler* handler2 = <span class="keyword">new</span> <span class="built_in">ConcreteHandler</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建责任链</span></span><br><span class="line">    handler1-&gt;<span class="built_in">setNextHandler</span>(handler2);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="type">double</span> requestAmount = <span class="number">100.0</span>;</span><br><span class="line">    handler1-&gt;<span class="built_in">handleRequest</span>(requestAmount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> handler1;</span><br><span class="line">    <span class="keyword">delete</span> handler2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-13">使用场景</h3>
<p>责任链模式具有下面几个优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>降低耦合度：将请求的发送者和接收者解耦，每个具体处理者都只负责处理与自己相关的请求，客户端不需要知道具体是哪个处理者处理请求。</p>
</li>
<li class="lvl-2">
<p>增强灵活性：可以动态地添加或删除处理者，改变处理者之间的顺序以满足不同需求。</p>
</li>
</ul>
<p>但是由于一个请求可能会经过多个处理者，这可能会导致一些性能问题，并且如果整个链上也没有合适的处理者来处理请求，就会导致请求无法被处理。</p>
<h2 id="解释器模式">解释器模式</h2>
<h3 id="基本概念-14">基本概念</h3>
<p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一个语言的文法，并且建立一个【解释器】来解释该语言中的句子。</p>
<h3 id="组成结构-2">组成结构</h3>
<p>解释器模式主要包含以下几个角色：</p>
<ol>
<li class="lvl-3">
<p><strong>抽象表达式（Abstract Expression）：</strong> 定义了解释器的接口，包含了解释器的方法 <code>interpret</code>。</p>
</li>
<li class="lvl-3">
<p><strong>终结符表达式（Terminal Expression）：</strong> 在语法中不能再分解为更小单元的符号。</p>
</li>
<li class="lvl-3">
<p><strong>非终结符表达式（Non-terminal Expression）：</strong> 文法中的复杂表达式，它由终结符和其他非终结符组成。</p>
</li>
<li class="lvl-3">
<p><strong>上下文（Context）：</strong> 包含解释器之外的一些全局信息，可以存储解释器中间结果，也可以用于向解释器传递信息。</p>
</li>
</ol>
<blockquote>
<p>举例来说，表达式 “3 + 5 * 2”，数字 “3” 和 “5”， “2” 是终结符，而运算符 “+”, &quot;*&quot;都需要两个操作数, 属于非终结符。</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/05/20/Fa2UsGeOYMSxL3A.png" alt=""></p>
<h3 id="简易实现-11">简易实现</h3>
<ol>
<li class="lvl-3">
<p>创建抽象表达式接口： 定义解释器的接口，声明一个 <code>interpret</code> 方法，用于解释语言中的表达式。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象表达式接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>创建具体的表达式类： 实现抽象表达式接口，用于表示语言中的具体表达式。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的终结符表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminalExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TerminalExpression</span>(<span class="type">int</span> value) : <span class="built_in">value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>非终结符表达式：抽象表达式的一种，用于表示语言中的非终结符表达式，通常包含其他表达式。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非终结符表达式类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddExpression</span>(Expression* left, Expression* right) : <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>() + right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>上下文：包含解释器需要的一些全局信息或状态。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="comment">// 可以在上下文中存储一些全局信息或状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>客户端：构建并组合表达式，然后解释表达式。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建表达式对象并解释表达式</span></span><br><span class="line">    Expression* expression = <span class="keyword">new</span> <span class="built_in">AddExpression</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">TerminalExpression</span>(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">TerminalExpression</span>(<span class="number">2</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = expression-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> expression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-14">使用场景</h3>
<p>当需要解释和执行特定领域或业务规则的语言时，可以使用解释器模式。例如，SQL解释器、正则表达式解释器等。但是需要注意的是解释器模式可能会导致类的层次结构较为复杂，同时也可能不够灵活，使用要慎重。</p>
<h2 id="访问者模式">访问者模式</h2>
<h3 id="基本概念-15">基本概念</h3>
<p>访问者模式（Visitor Pattern）是一种行为型设计模式，可以在不改变对象结构的前提下，对对象中的元素进行新的操作。</p>
<h3 id="基本结构：-3">基本结构：</h3>
<p>访问者模式包括以下几个基本角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>抽象访问者（Visitor）：</strong> 声明了访问者可以访问哪些元素，以及如何访问它们的方法<code>visit</code>。</p>
</li>
<li class="lvl-2">
<p><strong>具体访问者（ConcreteVisitor）：</strong> 实现了抽象访问者定义的方法，不同的元素类型可能有不同的访问行为。医生、管理员、游客都属于具体的访问者，它们的访问行为不同。</p>
</li>
<li class="lvl-2">
<p><strong>抽象元素（Element）：</strong> 定义了一个accept方法，用于接受访问者的访问。</p>
</li>
<li class="lvl-2">
<p><strong>具体元素（ConcreteElement）：</strong> 实现了accept方法，是访问者访问的目标。</p>
</li>
<li class="lvl-2">
<p><strong>对象结构（Object Structure）：</strong> 包含元素的集合，可以是一个列表、一个集合或者其他数据结构。负责遍历元素，并调用元素的接受方法。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/20/WnAUwNIXcBa2SfP.png" alt=""></p>
<h3 id="简易实现：">简易实现：</h3>
<ol>
<li class="lvl-3">
<p>定义抽象访问者: 声明那些元素可以访问</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>实现具体访问者：实现具体的访问逻辑</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体访问者A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorA</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA&amp; element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorA Visit ConcreteElementA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB&amp; element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorA Visit ConcreteElementB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorB</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA&amp; element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorB Visit ConcreteElementA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB&amp; element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteVisitorB Visit ConcreteElementB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>定义元素接口：声明接收访问者的方法。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>实现具体元素：实现接受访问者的方法</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体元素A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li class="lvl-3">
<p>创建对象结构：提供一个接口让访问者访问它的元素。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Element*&gt; elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Element* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Element* element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implement detach method if needed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element* element : elements) &#123;</span><br><span class="line">            element-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li class="lvl-3">
<p>客户端调用</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectStructure objectStructure;</span><br><span class="line">    objectStructure.<span class="built_in">attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteElementA</span>());</span><br><span class="line">    objectStructure.<span class="built_in">attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteElementB</span>());</span><br><span class="line"></span><br><span class="line">    ConcreteVisitorA visitorA;</span><br><span class="line">    ConcreteVisitorB visitorB;</span><br><span class="line"></span><br><span class="line">    objectStructure.<span class="built_in">accept</span>(visitorA);</span><br><span class="line">    objectStructure.<span class="built_in">accept</span>(visitorB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (Element* element : objectStructure.elements) &#123;</span><br><span class="line">        <span class="keyword">delete</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景-15">使用场景</h3>
<p>访问者模式结构较为复杂，但是访问者模式将同一类操作封装在一个访问者中，使得相关的操作彼此集中，提高了代码的可读性和维护性。它常用于<strong>对象结构比较稳定，但经常需要在此对象结构上定义新的操作</strong>，这样就无需修改现有的元素类，只需要定义新的访问者来添加新的操作。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 深入浅出工厂模式（初识篇）: <a href="https://zhuanlan.zhihu.com/p/83535678">https://zhuanlan.zhihu.com/p/83535678</a></p>
<p>[2]	卡码网设计模式精讲：<a href="https://github.com/youngyangyang04/kama-DesignPattern?tab=readme-ov-file">https://github.com/youngyangyang04/kama-DesignPattern?tab=readme-ov-file</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Makefile</title>
    <url>/archives/d5c3c62.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Makefile-概述">Makefile 概述</h2>
<p><strong>makefile</strong> 是一种用于自动化编译和构建程序的脚本文件，特别是在Unix-like系统中。它定义了如何将源代码编译成可执行文件或其他目标文件。通过 <code>make</code> 工具读取 Makefile 中的规则，自动处理源文件的依赖关系和编译顺序，从而简化和自动化了构建过程。</p>
<h3 id="编译与链接">编译与链接</h3>
<p>在编译过程中，源文件（如 <code>.c</code> 文件）会被编译成中间目标文件（在Unix下是 <code>.o</code> 文件）。这个步骤称为编译。编译器检查语法和声明，生成目标文件。如果源文件包含函数或变量的声明而没有定义，编译器会发出警告，但仍会生成目标文件。</p>
<span id="more"></span>
<p>链接过程将所有目标文件（<code>.o</code> 文件）合并成一个最终的可执行文件。在链接时，链接器负责解决函数和变量的实际定义，并检查是否所有的引用都有对应的实现。如果链接器找不到某个函数的实现，就会报错。</p>
<h3 id="Make的作用">Make的作用</h3>
<p><code>make</code> 是一个自动化构建工具，通过读取 Makefile，<code>make</code> 能够自动处理文件的依赖关系，执行编译和链接命令。它可以减少手动编译的繁琐步骤，提高开发效率。在开发大型工程时，编写 Makefile 让 <code>make</code> 工具管理编译过程，可以大大简化构建流程。</p>
<p>Makefile 的好处包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>自动化编译</strong>：只需运行 <code>make</code> 命令，即可自动编译整个工程。</p>
</li>
<li class="lvl-2">
<p><strong>依赖管理</strong>：自动处理文件间的依赖关系，确保只有在源文件修改后才重新编译相关的目标文件。</p>
</li>
<li class="lvl-2">
<p><strong>提高效率</strong>：避免了重复编译和手动管理编译过程的麻烦。</p>
</li>
</ul>
<h2 id="Makefile介绍">Makefile介绍</h2>
<p>makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li class="lvl-3">
<p>如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。</p>
</li>
<li class="lvl-3">
<p>如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</p>
</li>
<li class="lvl-3">
<p>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</p>
</li>
</ol>
<p>只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。</p>
<h3 id="Makefile内容">Makefile内容</h3>
<p>Makefile里主要包含了五个东西：显式规则、隐式规则、变量定义、指令和注释。</p>
<ol>
<li class="lvl-3">
<p>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</p>
</li>
<li class="lvl-3">
<p>隐式规则。由于我们的make有自动推导的功能，所以隐式规则可以让我们比较简略地书写Makefile，这是由make所支持的。</p>
</li>
<li class="lvl-3">
<p>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>
</li>
<li class="lvl-3">
<p>指令。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p>
</li>
<li class="lvl-3">
<p>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 <code>#</code> 字符，这个就像C/C++中的 <code>//</code> 一样。如果你要在你的Makefile中使用 <code>#</code> 字符，可以用反斜杠进行转义，如： <code>\#</code> 。</p>
</li>
</ol>
<p>值得一提的是，在Makefile中的命令，必须要以 <code>Tab</code> 键开始。</p>
<h3 id="Make的工作方式">Make的工作方式</h3>
<p>GNU的make工作时的执行步骤如下：</p>
<ol>
<li class="lvl-3">
<p>读入所有的Makefile。</p>
</li>
<li class="lvl-3">
<p>读入被include的其它Makefile。</p>
</li>
<li class="lvl-3">
<p>初始化文件中的变量。</p>
</li>
<li class="lvl-3">
<p>推导隐式规则，并分析所有规则。</p>
</li>
<li class="lvl-3">
<p>为所有的目标文件创建依赖关系链。</p>
</li>
<li class="lvl-3">
<p>根据依赖关系，决定哪些目标要重新生成。</p>
</li>
<li class="lvl-3">
<p>执行生成命令。</p>
</li>
</ol>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p>
<h3 id="Makefile中使用变量">Makefile中使用变量</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>反斜杠（ <code>\</code> ）是换行符的意思。</p>
<p>声明一个变量，叫 <code>objects</code> ， <code>OBJECTS</code> ， <code>objs</code> ， <code>OBJS</code> ， <code>obj</code> 或是 <code>OBJ</code> ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>改良版makefile就变成下面这个样子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>如果有新的 <code>.o</code> 文件加入，只需简单地修改一下 <code>object</code></p>
<h3 id="让Make自动推导">让Make自动推导</h3>
<p>GNU Make 具有强大的隐式规则功能，可以自动推导文件之间的依赖关系及其对应的构建命令。这样，你无需为每个目标文件明确指定构建命令，Make 可以自动处理这些任务。</p>
<h4 id="隐式规则的工作原理">隐式规则的工作原理</h4>
<ol>
<li class="lvl-3">
<p><strong>自动推导依赖</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">GNU Make 能够自动推导 <code>.o</code> 文件的生成规则。比如，它知道 <code>.o</code> 文件通常由同名的 <code>.c</code> 文件编译生成。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>自动生成命令</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">当 Make 发现一个 <code>.o</code> 文件时，它会自动将 <code>.c</code> 文件作为依赖，并使用类似 <code>cc -c whatever.c</code> 的命令进行编译。</li>
</ul>
</li>
</ol>
<h4 id="简化后的-Makefile-示例">简化后的 Makefile 示例</h4>
<p>使用 GNU Make 的隐式规则，可以简化 Makefile，避免为每个目标文件都写上类似的命令。以下是一个简化后的 Makefile 示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">makefileCopy code<span class="comment"># 定义目标文件</span></span><br><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义最终目标</span></span><br><span class="line"><span class="section">edit: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定头文件依赖（不再需要显式的编译规则）</span></span><br><span class="line"><span class="section">main.o: defs.h</span></span><br><span class="line"><span class="section">kbd.o: defs.h command.h</span></span><br><span class="line"><span class="section">command.o: defs.h command.h</span></span><br><span class="line"><span class="section">display.o: defs.h buffer.h</span></span><br><span class="line"><span class="section">insert.o: defs.h buffer.h</span></span><br><span class="line"><span class="section">search.o: defs.h buffer.h</span></span><br><span class="line"><span class="section">files.o: defs.h buffer.h command.h</span></span><br><span class="line"><span class="section">utils.o: defs.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理规则</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p><strong>另一种的写法</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<h3 id="清空目录的规则">清空目录的规则</h3>
<p>每个Makefile中都应该写一个清空目标文件（ <code>.o</code> ）和可执行文件的规则，这不仅便于重编译，也很利于保持文件的清洁。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<h3 id="包含其它Makefile">包含其它Makefile</h3>
<p>在 Makefile 中，<code>include</code> 指令用于将其他 Makefile 的内容包含到当前 Makefile 中。这种机制类似于 C 语言中的 <code>#include</code> 指令。通过 <code>include</code>，你可以将多个 Makefile 文件的内容合并到一个主 Makefile 中，从而实现代码的重用和组织。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filenames&gt;...</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;filenames&gt;</code> 可以是当前操作系统 Shell 的文件模式，包括路径和通配符。</p>
</li>
<li class="lvl-2">
<p><code>include</code> 前面可以有空格，但不能使用 Tab 键开始。</p>
</li>
<li class="lvl-2">
<p><code>include</code> 和 <code>&lt;filenames&gt;</code> 之间可以用一个或多个空格隔开。</p>
</li>
</ul>
<p>假设你有以下 Makefile 文件：<code>a.mk</code>、<code>b.mk</code>、<code>c.mk</code>，以及一个文件 <code>foo.make</code>，还有一个变量 <code>$(bar)</code>，其包含了 <code>bish</code> 和 <code>bash</code>，那么以下语句：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk bish bash</span><br></pre></td></tr></table></figure>
<h4 id="寻找文件的路径">寻找文件的路径</h4>
<p><code>make</code> 在处理 <code>include</code> 指令时，会按照以下顺序查找文件：</p>
<ol>
<li class="lvl-3">
<p><strong>当前目录</strong>：首先在当前目录下查找指定的文件。</p>
</li>
<li class="lvl-3">
<p><strong>指定的目录</strong>：如果使用了 <code>-I</code> 或 <code>--include-dir</code> 参数，则会在这些目录下查找。</p>
</li>
<li class="lvl-3">
<p><strong>默认目录</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>&lt;prefix&gt;/include</code>（如 <code>/usr/local/bin</code>）</li>
<li class="lvl-5"><code>/usr/gnu/include</code></li>
<li class="lvl-5"><code>/usr/local/include</code></li>
<li class="lvl-5"><code>/usr/include</code></li>
</ul>
</li>
</ol>
<p>环境变量 <code>.INCLUDE_DIRS</code> 也会影响 <code>make</code> 查找的目录列表。避免使用 <code>-I</code> 参数覆盖默认目录，以免使 <code>make</code> 忘记已设定的包含目录。</p>
<h4 id="错误处理">错误处理</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果指定的文件无法找到，<code>make</code> 会发出警告，但不会立即终止执行。</p>
</li>
<li class="lvl-2">
<p><code>make</code> 会继续处理其他文件，直到完成 Makefile 的读取。如果无法找到文件或读取失败，<code>make</code> 才会报致命错误。</p>
</li>
<li class="lvl-2">
<p>要忽略无法读取的文件并继续执行，可以使用减号 <code>-</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">-include</span> &lt;filenames&gt;...</span><br></pre></td></tr></table></figure>
<p>或者为了兼容其他 <code>make</code> 版本，可以使用 <code>sinclude</code> 代替 <code>-include</code>。：</p>
</li>
</ul>
<h3 id="环境变量MAKEFILES">环境变量MAKEFILES</h3>
<p>在使用 <code>make</code> 工具时，环境变量 <code>MAKEFILES</code> 可以指定一系列 Makefile 文件，这些文件的内容会在执行 <code>make</code> 时被自动引入。该变量中的值是由空格分隔的多个 Makefile 文件名。这种行为类似于 <code>include</code> 指令。</p>
<ol>
<li class="lvl-3">
<p><strong>自动引入</strong>：<code>make</code> 会将 <code>MAKEFILES</code> 环境变量中指定的文件内容自动包含进来，就像在 Makefile 中使用 <code>include</code> 指令一样。</p>
</li>
<li class="lvl-3">
<p><strong>默认目标忽略</strong>：从 <code>MAKEFILES</code> 环境变量引入的 Makefile 文件中的“默认目标”不会被执行。</p>
</li>
<li class="lvl-3">
<p><strong>错误忽略</strong>：如果指定的文件存在错误，<code>make</code> 不会中断执行，而是继续处理其他文件或目标。</p>
</li>
</ol>
<p>如果环境变量 <code>MAKEFILES</code> 设置为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MAKEFILES=<span class="string">&quot;common.mk utilities.mk&quot;</span></span><br></pre></td></tr></table></figure>
<p>那么 <code>make</code> 在执行时会自动将 <code>common.mk</code> 和 <code>utilities.mk</code> 中的内容包含进来。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>全局影响</strong>：一旦定义了 <code>MAKEFILES</code> 环境变量，所有的 <code>make</code> 执行都会受到这些文件的影响。这可能导致意外的行为或难以追踪的错误。</p>
</li>
<li class="lvl-2">
<p><strong>调试</strong>：如果遇到 Makefile 的异常行为，检查是否定义了 <code>MAKEFILES</code> 环境变量，并确保其内容正确。</p>
</li>
<li class="lvl-2">
<p><strong>避免使用</strong>：通常不建议使用 <code>MAKEFILES</code> 环境变量，因为它会影响所有 <code>make</code> 的执行过程。为避免混淆和难以追踪的错误，最好在 Makefile 中显式使用 <code>include</code> 指令来包含其他 Makefile 文件。</p>
</li>
<li class="lvl-2">
<p><strong>检查</strong>：在调试 Makefile 问题时，检查环境变量以确认是否有定义 <code>MAKEFILES</code>，以帮助识别潜在的问题来源。</p>
</li>
</ul>
<h3 id="Makefile文件名">Makefile文件名</h3>
<p>默认情况下，<code>make</code> 命令会按以下顺序在当前目录下寻找 Makefile 文件：</p>
<ol>
<li class="lvl-3">
<p><code>GNUmakefile</code></p>
</li>
<li class="lvl-3">
<p><code>makefile</code></p>
</li>
<li class="lvl-3">
<p><code>Makefile</code></p>
</li>
</ol>
<p>建议使用 <code>Makefile</code> 作为文件名，因为它在排序上靠近其他重要文件（如 <code>README</code>）。<code>GNUmakefile</code> 文件名仅被 GNU make 支持，其他版本的 make 可能不识别。</p>
<p>你也可以使用其他文件名，如 <code>Make.Solaris</code> 或 <code>Make.Linux</code>。要指定特定的 Makefile，可以使用 <code>-f</code> 或 <code>--file</code> 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f Make.Solaris</span><br><span class="line">make --file Make.Linux</span><br></pre></td></tr></table></figure>
<p>可以使用多个 <code>-f</code> 或 <code>--file</code> 参数来指定多个 Makefile。</p>
<h2 id="书写规则">书写规则</h2>
<h3 id="语法">语法</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    recipe</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>target</p>
<p>可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。</p>
</li>
<li class="lvl-2">
<p>prerequisites</p>
<p>生成该target所依赖的文件和/或target。</p>
</li>
<li class="lvl-2">
<p>recipe</p>
<p>该target要执行的命令（任意的shell命令）。</p>
</li>
</ul>
<h3 id="通配符">通配符</h3>
<p>make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> 。这是和Unix的B-Shell是相同的。</p>
<p>波浪号（ <code>~</code> ）字符在文件名中也有比较特殊的用途。如果是 <code>~/test</code> ，这就表示当前用户的 <code>$HOME</code> 目录下的test目录。而 <code>~hchen/test</code> 则表示用户hchen的宿主目录下的test 目录。</p>
<ol>
<li class="lvl-3">
<p><strong><code>*</code> (星号)</strong>: 匹配任意数量的字符<br>
删除所有以 <code>.o</code> 结尾的文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong><code>?</code> (问号)</strong>: 匹配单个字符<br>
匹配所有文件名为单个字符后加 <code>.c</code> 的文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">compile:</span></span><br><span class="line">    gcc -o output ?.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong><code>~</code> (波浪号)</strong>: 表示当前用户的 <code>$HOME</code> 目录<br>
进入用户主目录下的 <code>test</code> 目录</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">gohome:</span></span><br><span class="line">    cd ~/test</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="文件搜寻">文件搜寻</h3>
<p>Makefile中可以通过<code>VPATH</code>和<code>vpath</code>关键字设置文件搜索路径：</p>
<ol>
<li class="lvl-3">
<p><strong>VPATH</strong>: 指定全局搜索目录，多个目录用冒号分隔。</p>
<p>“src”和“…/headers”，make会按照这个顺序进行搜索</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>vpath</strong>: 更灵活，支持为不同类型的文件指定不同的搜索目录</p>
<p>使用方法有三种：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code></p>
<p>为符合模式<pattern>的文件指定搜索目录<directories>。</p>
</li>
<li class="lvl-5">
<p><code>vpath &lt;pattern&gt;</code></p>
<p>清除符合模式<pattern>的文件的搜索目录。</p>
</li>
<li class="lvl-5">
<p><code>vpath</code></p>
<p>清除所有已被设置好了的文件搜索目录。</p>
</li>
</ul>
<p>vpath使用方法中的<pattern>需要包含 <code>%</code> 字符。 <code>%</code> 的意思是匹配零或若干字符，（需引用 <code>%</code> ，使用 <code>\</code> ）例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件</p>
<p>要求make在“…/headers”目录下搜索所有以 .h 结尾的文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br><span class="line"><span class="keyword">vpath</span> %.c src</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="伪目标">伪目标</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>伪目标只是一个标签，通常用于Makefile中没有依赖文件的目标。伪目标不会生成实际的文件，只有在用<code>make</code>命令显式调用时才会执行。</p>
</li>
<li class="lvl-2">
<p>例如，<code>clean</code>是一个常见的伪目标，用于清理生成的文件。因为伪目标本身不生成文件，所以当目录下有与伪目标同名的文件时，执行<code>make</code>命令会出现错误。这时，我们可以使用伪目标来避免冲突。</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">ALL: hello.out</span></span><br><span class="line"> </span><br><span class="line"><span class="section">hello.out: <span class="variable">$(OBJ)</span></span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$(OBJ)</span>: <span class="variable">$(SRC)</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf <span class="variable">$(OBJ)</span> hello.out</span><br><span class="line"> </span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean ALL</span></span><br></pre></td></tr></table></figure>
<p>通常也会把ALL设置成伪目标</p>
<h3 id="多目标">多目标</h3>
<p>Makefile的规则中的目标可以不止一个，其支持多目标</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">    generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上述规则等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">    generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">    generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
<p>其中， <code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， <code>$@</code> 表示目标的集合，就像一个数组， <code>$@</code> 依次取出目标，并执于命令。</p>
<h3 id="静态模式">静态模式</h3>
<p>静态模式规则是Makefile中的一个强大特性，用于简化多目标文件的规则定义。它使得我们能够为一组目标文件定义共同的编译规则，从而避免重复书写相似的规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>&lt;targets ...&gt;</code></strong>: 定义了一系列目标文件，可以使用通配符来匹配多个目标文件。</p>
</li>
<li class="lvl-2">
<p><strong><code>&lt;target-pattern&gt;</code></strong>: 目标模式，指定目标文件的名称模式。通常使用 <code>%</code> 表示通配符。</p>
</li>
<li class="lvl-2">
<p><strong><code>&lt;prereq-patterns ...&gt;</code></strong>: 依赖模式，指定依赖文件的名称模式。通常使用 <code>%</code> 来与目标模式进行匹配。</p>
</li>
<li class="lvl-2">
<p><strong><code>&lt;commands&gt;</code></strong>: 执行的命令，用于生成目标文件。</p>
</li>
</ul>
<p><strong>示例一</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展后的规则等价于：</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p><strong>示例二</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">    emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p><strong><code>$(filter %.o,$(files))</code></strong>:</p>
<ul class="lvl-2">
<li class="lvl-5"><code>filter</code> 函数过滤 <code>files</code> 列表，得到 <code>.o</code> 文件（<code>bar.o</code> 和 <code>lose.o</code>）。</li>
<li class="lvl-5">对这些 <code>.o</code> 文件应用规则 <code>%.o: %.c</code>，即每个 <code>.o</code> 文件由相应的 <code>.c</code> 文件生成。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>$(filter %.elc,$(files))</code></strong>:</p>
<ul class="lvl-2">
<li class="lvl-5"><code>filter</code> 函数过滤 <code>files</code> 列表，得到 <code>.elc</code> 文件（<code>foo.elc</code>）。</li>
<li class="lvl-5">对这些 <code>.elc</code> 文件应用规则 <code>%.elc: %.el</code>，即每个 <code>.elc</code> 文件由相应的 <code>.el</code> 文件生成。</li>
</ul>
</li>
</ol>
<p>扩展后的规则等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br><span class="line">lose.o : lose.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> lose.c -o lose.o</span><br><span class="line">foo.elc : foo.el</span><br><span class="line">    emacs -f batch-byte-compile foo.el</span><br></pre></td></tr></table></figure>
<h3 id="自动生成依赖性">自动生成依赖性</h3>
<p>在大型工程中，手动维护头文件的依赖关系是一项繁琐且容易出错的工作。为了简化这一过程，我们可以利用编译器的自动依赖生成功能。</p>
<p>大多数 C/C++ 编译器都支持 <code>-M</code> 选项来自动找寻源文件中包含的头文件并生成依赖关系。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -MM main.c</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h</span></span><br></pre></td></tr></table></figure>
<p>对于 GNU 编译器，<code>-MM</code> 参数会忽略标准库头文件，仅生成用户头文件的依赖关系。</p>
<p>为了将这些自动生成的依赖关系集成到 Makefile 中，我们可以创建一个模式规则来生成 <code>.d</code> 文件。这些 <code>.d</code> 文件将存储每个源文件的依赖关系。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">    @set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">    <span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">    sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">    rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure>
<p>这个规则的工作流程如下：</p>
<ol>
<li class="lvl-3">
<p>删除旧的 <code>.d</code> 文件。</p>
</li>
<li class="lvl-3">
<p>使用编译器生成新的依赖文件。</p>
</li>
<li class="lvl-3">
<p>使用 <code>sed</code> 命令将生成的依赖关系格式化成 <code>.d</code> 文件的格式。</p>
</li>
<li class="lvl-3">
<p>删除临时文件。</p>
</li>
</ol>
<p>将 <code>.d</code> 文件集成到主 Makefile 中，可以通过 <code>include</code> 指令引入这些文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>
<p>这里，<code>$(sources:.c=.d)</code> 会将 <code>foo.c</code> 和 <code>bar.c</code> 替换为 <code>foo.d</code> 和 <code>bar.d</code>。这样，主 Makefile 会自动包含每个 <code>.d</code> 文件，确保所有依赖关系得到更新。</p>
<h2 id="使用变量">使用变量</h2>
<p>在Makefile中，变量类似于C/C<ins>中的宏，用于代表文本字符串。在执行Makefile时，这些变量会自动展开。与C/C</ins>不同的是，你可以在Makefile中修改变量的值。变量可以在“目标”、“依赖目标”、“命令”或Makefile的其他部分中使用。</p>
<h3 id="变量的命名">变量的命名</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以包含字符、数字和下划线（下划线可以在数字开头），但不应包含 <code>:</code>、<code>#</code>、<code>=</code> 或空字符（空格、回车等）。</p>
</li>
<li class="lvl-2">
<p>变量名是大小写敏感的。例如，<code>foo</code>、<code>Foo</code> 和 <code>FOO</code> 是不同的变量名。</p>
</li>
<li class="lvl-2">
<p>推荐使用大小写搭配的变量名，如 <code>MakeFlags</code>，以避免与系统变量冲突。</p>
</li>
</ul>
<h3 id="变量的基础">变量的基础</h3>
<p><strong>定义和使用变量</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable = value</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>使用变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(variable)</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;variable&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>如果需要在变量中使用 <code>$</code> 字符，需用 <code>$$</code> 表示。</p>
</li>
</ul>
<h3 id="变量中的变量">变量中的变量</h3>
<p><strong>使用其他变量定义变量</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单使用 <code>=</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>使用 <code>:=</code> 进行即时展开：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="递归定义和即时展开">递归定义和即时展开</h3>
<p><strong>递归定义（不推荐）</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(CFLAGS)</span> -O</span><br></pre></td></tr></table></figure>
<p><strong>即时展开（推荐）</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS := <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs := -Ifoo -Ibar</span><br></pre></td></tr></table></figure>
<h3 id="其他变量操作">其他变量操作</h3>
<p><strong>定义空格变量</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure>
<p><strong>条件赋值</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>
<h3 id="高级用法">高级用法</h3>
<p><strong>变量值替换</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>
<p><strong>模式替换</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>
<p><strong>变量的值再当作变量</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p><strong>复杂示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br></pre></td></tr></table></figure>
<h3 id="追加变量值">追加变量值</h3>
<p><strong>使用 <code>+=</code> 追加值</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure>
<h3 id="override-指令">override 指令</h3>
<p><strong>覆盖命令行或环境变量</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> variable := value</span><br></pre></td></tr></table></figure>
<h3 id="多行变量">多行变量</h3>
<p><strong>使用 <code>define</code> 定义多行变量</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h3 id="环境变量">环境变量</h3>
<p><strong>使用系统环境变量</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果定义了系统环境变量，则在Makefile中也可以使用。</p>
</li>
<li class="lvl-2">
<p>使用 <code>-e</code> 参数可以让环境变量覆盖Makefile中的变量。</p>
</li>
</ul>
<h3 id="目标变量">目标变量</h3>
<p><strong>定义目标特定变量</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br></pre></td></tr></table></figure>
<h3 id="模式变量">模式变量</h3>
<p><strong>定义模式特定变量</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>
<h2 id="使用条件判断">使用条件判断</h2>
<p>在 <code>Makefile</code> 中，条件判断允许根据运行时的不同情况选择不同的执行分支。这是实现更复杂的构建逻辑时非常有用的功能。以下是有关如何在 <code>Makefile</code> 中使用条件判断的说明。</p>
<p>以下示例演示了如何根据 <code>$(CC)</code> 变量的值来选择不同的编译选项：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果 <code>$(CC)</code> 的值是 <code>gcc</code>，则会将 <code>$(libs_for_gcc)</code> 作为库文件来编译目标 <code>foo</code>。否则，会使用 <code>$(normal_libs)</code> 作为库文件。</p>
<h3 id="语法-2">语法</h3>
<p>条件表达式的语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;conditional-directive&gt;</code> 是条件关键字。主要有以下四种：</p>
<ol>
<li class="lvl-3">
<p><strong><code>ifeq</code></strong>: 比较两个参数的值是否相同。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(foo)</span>)</span>,)</span><br><span class="line">&lt;text-if-empty&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong><code>ifneq</code></strong>: 比较两个参数的值是否不同。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong><code>ifdef</code></strong>: 检查一个变量是否被定义且值非空。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong><code>ifndef</code></strong>: 检查一个变量是否未定义或值为空。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在 <code>&lt;conditional-directive&gt;</code> 行上，多余的空格是允许的，但不能以 <code>Tab</code> 键开始。</p>
</li>
<li class="lvl-2">
<p>注释符 <code>#</code> 也是安全的。</p>
</li>
<li class="lvl-2">
<p><code>make</code> 在读取 <code>Makefile</code> 时计算条件表达式的值，所以最好不要将自动化变量（如 <code>$@</code>）放入条件表达式中，因为这些变量在运行时才会被定义。</p>
</li>
<li class="lvl-2">
<p><code>make</code> 不允许将条件语句分成两个部分放在不同的文件中。</p>
</li>
</ul>
<p>在 <code>Makefile</code> 中使用函数可以让你的构建规则更加灵活和智能。<code>make</code> 支持一些基本的函数，用于处理变量和字符串。以下是 <code>make</code> 中的主要函数及其用法的详细整理：</p>
<h2 id="使用函数">使用函数</h2>
<h3 id="函数调用语法">函数调用语法</h3>
<p>函数调用的基本语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&lt;</span>function&gt;(&lt;arguments&gt;)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;&lt;function&gt;(&lt;arguments&gt;)&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;function&gt;</code> 是函数名</p>
</li>
<li class="lvl-2">
<p><code>&lt;arguments&gt;</code> 是函数参数，参数间以逗号分隔</p>
</li>
</ul>
<h3 id="字符串处理函数">字符串处理函数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>subst</code></strong>: 字符串替换</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>替换 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 为 <code>&lt;to&gt;</code>。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span>  <span class="comment"># 结果: fEEt on the strEEt</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>patsubst</code></strong>: 模式匹配替换</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>按模式 <code>&lt;pattern&gt;</code> 替换 <code>&lt;text&gt;</code> 中的部分。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span>  <span class="comment"># 结果: x.c.o bar.o</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>strip</code></strong>: 去除首尾空格</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br></pre></td></tr></table></figure>
<p>去除 <code>&lt;string&gt;</code> 开头和结尾的空格。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span>  <span class="comment"># 结果: a b c</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>findstring</code></strong>: 查找子串</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span></span><br></pre></td></tr></table></figure>
<p>查找 <code>&lt;in&gt;</code> 中是否存在 <code>&lt;find&gt;</code>。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span>  <span class="comment"># 结果: a</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span>    <span class="comment"># 结果: （空）</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>filter</code></strong>: 按模式过滤</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>过滤 <code>&lt;text&gt;</code> 中符合 <code>&lt;pattern&gt;</code> 的单词。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources := foo.c bar.c baz.s ugh.h</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.c %.s,<span class="variable">$(sources)</span>)</span>  <span class="comment"># 结果: foo.c bar.c baz.s</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>filter-out</code></strong>: 反过滤</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>去除 <code>&lt;text&gt;</code> 中符合 <code>&lt;pattern&gt;</code> 的单词。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects=main1.o foo.o main2.o bar.o</span><br><span class="line">mains=main1.o main2.o</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(mains)</span>,<span class="variable">$(objects)</span>)</span>  <span class="comment"># 结果: foo.o bar.o</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>sort</code></strong>: 排序</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br></pre></td></tr></table></figure>
<p>对 <code>&lt;list&gt;</code> 中的单词进行升序排序。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> foo bar lose)</span>  <span class="comment"># 结果: bar foo lose</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>word</code></strong>: 取单词</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>获取 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> 2, foo bar baz)</span>  <span class="comment"># 结果: bar</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>wordlist</code></strong>: 取单词串</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>取 <code>&lt;text&gt;</code> 中从第 <code>&lt;ss&gt;</code> 到第 <code>&lt;e&gt;</code> 个单词。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> 2, 3, foo bar baz)</span>  <span class="comment"># 结果: bar baz</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>words</code></strong>: 单词个数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(words &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>统计 <code>&lt;text&gt;</code> 中的单词数量。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(words foo bar baz)</span>  <span class="comment"># 结果: 3</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>firstword</code></strong>: 取首单词</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>取 <code>&lt;text&gt;</code> 中的第一个单词。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> foo bar)</span>  <span class="comment"># 结果: foo</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件名操作函数">文件名操作函数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>dir</code></strong>: 取目录</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>提取 <code>&lt;names&gt;</code> 中的目录部分。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> src/foo.c hacks)</span>  <span class="comment"># 结果: src/ ./</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>notdir</code></strong>: 取文件名</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>提取 <code>&lt;names&gt;</code> 中的文件名部分。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> src/foo.c hacks)</span>  <span class="comment"># 结果: foo.c hacks</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>suffix</code></strong>: 取后缀</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>提取 <code>&lt;names&gt;</code> 中的文件后缀。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> src/foo.c src-1.0/bar.c hacks)</span>  <span class="comment"># 结果: .c .c</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>basename</code></strong>: 取前缀</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>提取 <code>&lt;names&gt;</code> 中的文件前缀。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> src/foo.c src-1.0/bar.c hacks)</span>  <span class="comment"># 结果: src/foo src-1.0/bar hacks</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>addsuffix</code></strong>: 添加后缀</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;,&lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>为 <code>&lt;names&gt;</code> 中的每个文件名添加 <code>&lt;suffix&gt;</code>。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> .c,foo bar)</span>  <span class="comment"># 结果: foo.c bar.c</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>addprefix</code></strong>: 添加前缀</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;,&lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>为 <code>&lt;names&gt;</code> 中的每个文件名添加 <code>&lt;prefix&gt;</code>。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> src/,foo bar)</span>  <span class="comment"># 结果: src/foo src/bar</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>join</code></strong>: 连接</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span></span><br></pre></td></tr></table></figure>
<p>将 <code>&lt;list2&gt;</code> 中的单词连接到 <code>&lt;list1&gt;</code> 的每个单词后面。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> aaa bbb , 111 222 333)</span>  <span class="comment"># 结果: aaa111 bbb222 333</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="控制-make的函数">控制 make的函数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>error</code></strong>: 报错并终止</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>输出错误信息并停止执行。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> An <span class="built_in">error</span> occurred!)</span>  <span class="comment"># 输出错误并终止</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>warning</code></strong>: 警告</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>输出警告信息但不终止执行。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> This is a <span class="built_in">warning</span>!)</span>  <span class="comment"># 输出警告</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="其他函数">其他函数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>call</code></strong>: 创建参数化函数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>&lt;expression&gt;</code> 和参数 <code>&lt;parm1&gt;</code>, <code>&lt;parm2&gt;</code>, … 创建新的字符串。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse = $(2) $(1)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span>  <span class="comment"># 结果: b a</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>origin</code></strong>: 获取变量来源</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>
<p>返回 <code>&lt;variable&gt;</code> 的来源类型。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> CC)</span>  <span class="comment"># 结果: default</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong><code>shell</code></strong>: 执行 Shell 命令</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">shell</span> &lt;command&gt;)</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>&lt;command&gt;</code> 并返回其输出。示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">shell</span> ls)</span>  <span class="comment"># 执行 &#x27;ls&#x27; 命令并返回结果</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="make的运行">make的运行</h2>
<h3 id="make的退出码">make的退出码</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>0</strong>: 成功执行</p>
</li>
<li class="lvl-2">
<p><strong>1</strong>: 执行过程中出现错误</p>
</li>
<li class="lvl-2">
<p><strong>2</strong>: 使用了 <code>-q</code> 选项且某些目标不需要更新</p>
</li>
</ul>
<h3 id="指定-Makefile">指定 Makefile</h3>
<p>默认情况下，<code>make</code> 会查找当前目录下的 <code>GNUmakefile</code>、<code>makefile</code> 或 <code>Makefile</code>。你可以使用 <code>-f</code> 或 <code>--file</code> 参数来指定其他 Makefile。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make -f hchen.mk</span><br></pre></td></tr></table></figure>
<p>如果指定多个 <code>-f</code> 参数，<code>make</code> 会按顺序读取所有指定的 Makefile。</p>
<h3 id="指定目标">指定目标</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认情况下，<code>make</code> 执行第一个目标。你可以指定其他目标，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><code>MAKECMDGOALS</code> 环境变量包含指定的终极目标列表，如果没有指定目标，该变量为空。</p>
</li>
</ul>
<h3 id="检查规则">检查规则</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>-n</code>, <code>--just-print</code>, <code>--dry-run</code>, <code>--recon</code></strong>: 不执行命令，只打印出命令序列。</p>
</li>
<li class="lvl-2">
<p><strong><code>-t</code>, <code>--touch</code></strong>: 更新目标文件的时间戳，但不真正编译。</p>
</li>
<li class="lvl-2">
<p><strong><code>-q</code>, <code>--question</code></strong>: 检查目标是否需要更新，不执行命令。</p>
</li>
<li class="lvl-2">
<p><strong><code>-W &lt;file&gt;</code>, <code>--what-if=&lt;file&gt;</code>, <code>--assume-new=&lt;file&gt;</code>, <code>--new-file=&lt;file&gt;</code></strong>: 假定指定的文件需要更新，常与 <code>-n</code> 参数结合使用。</p>
</li>
</ul>
<h3 id="make的常用参数">make的常用参数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>-b</code>, <code>-m</code></strong>: 忽略与其他版本 <code>make</code> 的兼容性。</p>
</li>
<li class="lvl-2">
<p><strong><code>-B</code>, <code>--always-make</code></strong>: 认为所有目标都需要更新。</p>
</li>
<li class="lvl-2">
<p><strong><code>-C &lt;dir&gt;</code>, <code>--directory=&lt;dir&gt;</code></strong>: 指定 Makefile 所在目录。</p>
</li>
<li class="lvl-2">
<p><strong><code>-d</code></strong>: 输出调试信息，相当于 <code>--debug=a</code>。</p>
</li>
<li class="lvl-2">
<p><strong><code>-e</code>, <code>--environment-overrides</code></strong>: 环境变量值覆盖 Makefile 中的变量值。</p>
</li>
<li class="lvl-2">
<p><strong><code>-f &lt;file&gt;</code>, <code>--file=&lt;file&gt;</code>, <code>--makefile=&lt;file&gt;</code></strong>: 指定需要执行的 Makefile。</p>
</li>
<li class="lvl-2">
<p><strong><code>-i</code>, <code>--ignore-errors</code></strong>: 执行时忽略所有错误。</p>
</li>
<li class="lvl-2">
<p><strong><code>-I &lt;dir&gt;</code>, <code>--include-dir=&lt;dir&gt;</code></strong>: 指定包含 Makefile 的搜索目录。</p>
</li>
<li class="lvl-2">
<p><strong><code>-j [&lt;jobsnum&gt;]</code>, <code>--jobs[=&lt;jobsnum&gt;]</code></strong>: 指定同时运行的命令数量。</p>
</li>
<li class="lvl-2">
<p><strong><code>-k</code>, <code>--keep-going</code></strong>: 出错时继续执行。</p>
</li>
<li class="lvl-2">
<p><strong><code>-l &lt;load&gt;</code>, <code>--load-average[=&lt;load&gt;]</code></strong>: 指定命令运行的负载。</p>
</li>
<li class="lvl-2">
<p><strong><code>-p</code>, <code>--print-data-base</code></strong>: 输出 Makefile 中的所有数据。</p>
</li>
<li class="lvl-2">
<p><strong><code>-r</code>, <code>--no-builtin-rules</code></strong>: 禁止使用隐含规则。</p>
</li>
<li class="lvl-2">
<p><strong><code>-s</code>, <code>--silent</code>, <code>--quiet</code></strong>: 运行时不输出命令。</p>
</li>
<li class="lvl-2">
<p><strong><code>-t</code>, <code>--touch</code></strong>: 使目标文件的时间戳更新。</p>
</li>
<li class="lvl-2">
<p><strong><code>-v</code>, <code>--version</code></strong>: 输出 <code>make</code> 程序的版本信息。</p>
</li>
<li class="lvl-2">
<p><strong><code>-w</code>, <code>--print-directory</code></strong>: 输出运行 Makefile 之前和之后的目录信息。</p>
</li>
<li class="lvl-2">
<p><strong><code>--warn-undefined-variables</code></strong>: 输出未定义变量的警告信息。</p>
</li>
</ul>
<h2 id="隐含规则">隐含规则</h2>
<h3 id="隐含规则概述">隐含规则概述</h3>
<p>隐含规则是 <code>make</code> 提供的一种机制，允许自动推导目标文件的生成规则，而无需显式地在 <code>Makefile</code> 中定义这些规则。它们是 <code>make</code> 内部预设的一些规则，用于处理常见的编译和构建任务。理解隐含规则可以帮助你简化 <code>Makefile</code>，避免重复的规则定义。</p>
<h3 id="隐含规则的基本使用">隐含规则的基本使用</h3>
<p>当你在 <code>Makefile</code> 中只定义了目标和最终的依赖目标而没有明确列出如何生成依赖目标的规则时，<code>make</code> 会自动根据隐含规则来生成这些依赖目标。例如，在下述 <code>Makefile</code> 中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo: foo.o bar.o</span></span><br><span class="line">    cc -o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Makefile</code> 中没有定义 <code>foo.o</code> 和 <code>bar.o</code> 的生成规则。<code>make</code> 会自动推导出这些目标的规则，通常是通过隐含规则将 <code>.c</code> 文件编译为 <code>.o</code> 文件。</p>
<h3 id="隐含规则的默认行为">隐含规则的默认行为</h3>
<p><code>make</code> 内部有一套默认的隐含规则，这些规则处理各种文件后缀的编译和转换。例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>编译 C 程序</strong>：<code>&lt;n&gt;.o</code> 的目标依赖于 <code>&lt;n&gt;.c</code> 文件，使用 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code> 命令生成目标文件。</p>
</li>
<li class="lvl-2">
<p><strong>编译 C++ 程序</strong>：<code>&lt;n&gt;.o</code> 的目标依赖于 <code>&lt;n&gt;.cc</code>、<code>&lt;n&gt;.cpp</code> 或 <code>&lt;n&gt;.C</code> 文件，使用 <code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)</code> 命令生成目标文件。</p>
</li>
<li class="lvl-2">
<p><strong>编译 Fortran 程序</strong>：<code>&lt;n&gt;.o</code> 的目标依赖于 <code>&lt;n&gt;.f</code>、<code>&lt;n&gt;.F</code> 或 <code>&lt;n&gt;.r</code> 文件，使用相应的 Fortran 编译器命令生成目标文件。</p>
</li>
</ul>
<p>这些规则可以通过 <code>-r</code> 或 <code>--no-builtin-rules</code> 选项被禁用，但某些规则可能仍会根据后缀列表（如 <code>.o</code>、<code>.c</code>）生效。</p>
<h3 id="使用模式规则定义隐含规则">使用模式规则定义隐含规则</h3>
<p>你可以自定义隐含规则，使用模式规则定义规则的模式，其中 <code>％</code> 表示匹配文件名的一部分。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>这个规则的意义是，任何 <code>.o</code> 文件的生成都依赖于同名的 <code>.c</code> 文件，并且会使用指定的编译命令生成目标文件。<code>$@</code> 表示目标文件，<code>$&lt;</code> 表示第一个依赖文件。</p>
<h3 id="自动化变量">自动化变量</h3>
<p>自动化变量用于在规则中表示特定的文件名和文件集合。这些变量可以帮助你编写通用的规则，处理不同的目标和依赖文件。常见的自动化变量包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>$@</code></strong>：表示规则中的目标文件。</p>
</li>
<li class="lvl-2">
<p><strong><code>$&lt;</code></strong>：表示第一个依赖文件。</p>
</li>
<li class="lvl-2">
<p><strong><code>$^</code></strong>：表示所有的依赖文件（去重）。</p>
</li>
<li class="lvl-2">
<p><strong><code>$*</code></strong>：表示目标文件名中模式中 <code>％</code> 及其之前的部分部分。</p>
</li>
</ul>
<h3 id="隐含规则链">隐含规则链</h3>
<p>隐含规则链指的是一个目标的生成可能依赖于多个隐含规则的组合。例如，<code>make</code> 可能会先使用 Yacc 隐含规则将 <code>.y</code> 文件转换为 <code>.c</code> 文件，然后再使用 C 编译的隐含规则将 <code>.c</code> 文件编译为 <code>.o</code> 文件。</p>
<h3 id="伪目标和特殊规则">伪目标和特殊规则</h3>
<p>你可以使用伪目标来控制 <code>make</code> 的行为，例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>.INTERMEDIATE</code></strong>：声明中间目标，<code>make</code> 在生成最终目标后会删除这些中间文件。</p>
</li>
<li class="lvl-2">
<p><strong><code>.SECONDARY</code></strong>：声明中间目标，<code>make</code> 不会自动删除这些文件。</p>
</li>
<li class="lvl-2">
<p><strong><code>.PRECIOUS</code></strong>：声明被隐含规则生成的中间文件不会被删除。</p>
</li>
</ul>
<p>这些伪目标帮助你控制文件的生成和删除行为，以适应不同的构建需求。</p>
<p>通过理解和利用隐含规则、模式规则及自动化变量，你可以使 <code>Makefile</code> 更加简洁和高效，同时减少手动维护规则的复杂性。</p>
<h2 id="使用make更新函数库文件">使用make更新函数库文件</h2>
<ol>
<li class="lvl-3">
<p><strong>函数库文件（归档文件）</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">由多个对象文件（.o 文件）组成。</li>
<li class="lvl-5">使用 <code>ar</code> 命令打包，例如 <code>ar cr libfoo.a foo.o</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>函数库文件的成员定义</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">可以使用 <code>archive(member)</code> 的形式指定成员。</li>
<li class="lvl-5">多个成员用空格分开，或使用通配符来定义，如 <code>foolib(*.o)</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>隐含规则</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>make</code> 会将 <code>a(m)</code> 形式的目标变成 <code>m</code>，然后寻找对应的规则。</li>
<li class="lvl-5">例如，<code>make foo.a(bar.o)</code> 会尝试生成 <code>bar.o</code>，如果没有规则，<code>make</code> 会使用内建规则来编译 <code>bar.c</code> 生成 <code>bar.o</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>自动化变量</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><code>$%</code> 是函数库文件的自动化变量。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>后缀规则</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">使用 <code>.c.a</code> 后缀规则来生成归档文件。</li>
<li class="lvl-5">后缀规则的等效形式也可以使用隐含规则。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>注意事项</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">并行执行（<code>-j</code> 参数）时要小心，因为多个 <code>ar</code> 命令可能会损坏归档文件。</li>
</ul>
</li>
</ol>
<h2 id="Reference">Reference</h2>
<p>[1]	跟我一起写Makefile:<a href="https://seisman.github.io/how-to-write-makefile/index.html">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC&amp;Gdb基础教程</title>
    <url>/archives/7762eb42.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="GCC编译">GCC编译</h2>
<h3 id="GCC-介绍">GCC 介绍</h3>
<p><strong>GCC</strong>（GNU Compiler Collection）是由GNU开发的编程语言编译器。最初为GNU操作系统开发，现在已被多数类Unix系统（如Linux、BSD、MacOS X等）采用，甚至在Windows上也可以使用。</p>
<span id="more"></span>
<h3 id="GCC-编译流程">GCC 编译流程</h3>
<ol>
<li class="lvl-3">
<p><strong>预处理</strong>：生成 <code>.i</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello.i -E hello.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>编译</strong>：将预处理后的文件转换为汇编语言，生成 <code>.s</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello.s -S hello.i</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>汇编</strong>：将汇编代码转换为目标代码（机器代码），生成 <code>.o</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello.o -c hello.s</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>链接</strong>：将目标代码链接生成可执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.o</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="GCC-参数">GCC 参数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>-o</strong>：指定目标文件名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o output file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-S</strong>：仅生成汇编语言文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-c</strong>：仅编译为目标文件，不进行链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-E</strong>：仅进行预处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E file.c -o file.i</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-I[dirname]</strong>：将 <code>dirname</code> 加入到包含文件的搜索目录列表中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -I /usr/include file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-L[dirname]</strong>：将 <code>dirname</code> 加入到库文件的搜索目录列表中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -L /usr/lib file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-l[library]</strong>：链接时使用指定的库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -L /usr/lib -lcurses file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-O0, -O1, -O2, -O3</strong>：设置优化级别，-O0 表示无优化，-O3 表示最高优化级别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -O3 -o output file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-w</strong>：忽略警告信息</p>
</li>
<li class="lvl-2">
<p><strong>-Wall</strong>：显示所有警告信息</p>
</li>
<li class="lvl-2">
<p><strong>-Werror</strong>：将所有警告视为错误</p>
</li>
<li class="lvl-2">
<p><strong>-g</strong>：生成调试信息</p>
</li>
<li class="lvl-2">
<p><strong>-M</strong>：生成依赖关系信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -M file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-MM</strong>：生成依赖关系，但忽略标准头文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -MM file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-MD</strong> 和 <strong>-MMD</strong>：生成 <code>.d</code> 文件，包含依赖关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -MD file.c</span><br><span class="line">gcc -MMD file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-MF File</strong>：指定依赖文件名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -M -MF dependencies.d file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-D macro</strong>：定义宏</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -DYES -o output file.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>-U macro</strong>：取消宏定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -DYES -UYES -o output file.c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="静态库与动态库">静态库与动态库</h3>
<p><strong>静态库</strong>：以空间换时间，增加代码量，减少运行时间。静态库文件扩展名一般为 <code>.a</code>。</p>
<p><strong>动态库</strong>：以时间换空间，增加运行时间，减少代码量。动态库文件扩展名一般为 <code>.so</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myalib.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// myalib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myalib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argu[])</span></span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建静态库">创建静态库</h4>
<ol>
<li class="lvl-3">
<p>编译生成目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c myalib.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用 <code>ar</code> 命令归档目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar -rc libtest.a myalib.o</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用库文件测试程序main.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -I ./ -o main.o -c main.c</span><br><span class="line">gcc -o main -L ./ main.o -ltest</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="创建动态库">创建动态库</h4>
<ol>
<li class="lvl-3">
<p>编译生成动态库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libtest.so mylib.c</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>编译并链接使用动态库的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o main main.c -L ./ -ltest</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用 <code>ldd</code> 命令检查动态库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd main</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>解决动态库问题</p>
<ul class="lvl-2">
<li class="lvl-5">将库文件拷贝到系统库目录（如 <code>/lib</code>）。</li>
<li class="lvl-5">修改系统库搜索路径，通过配置 <code>/etc/ld.so.conf</code> 或在 <code>/etc/ld.so.conf.d/</code> 中添加配置文件，运行 <code>ldconfig</code> 更新配置。</li>
</ul>
</li>
</ol>
<h2 id="Gdb调试">Gdb调试</h2>
<h3 id="什么是-gdb">什么是 gdb</h3>
<p><strong>gdb</strong> 是 GNU 开源组织发布的一个强大的 Unix/Linux 下的程序调试工具。它可以帮助用户调试程序，检查程序运行中的状态，并动态改变程序的执行环境。</p>
<p><strong>gdb 说明文档位置</strong>：<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">gdb 在线文档</a></p>
<h3 id="gdb-的作用">gdb 的作用</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>启动用户程序</strong>：可以按照用户的要求随意运行程序。</p>
</li>
<li class="lvl-2">
<p><strong>设置断点</strong>：可让被调试的程序在用户设定的断点处停住。</p>
</li>
<li class="lvl-2">
<p><strong>检查程序状态</strong>：程序被停住时，可以检查当前程序中的状态。</p>
</li>
<li class="lvl-2">
<p><strong>动态改变执行环境</strong>：可以动态修改程序的执行环境。</p>
</li>
</ul>
<h3 id="gdb调试core">gdb调试core</h3>
<p><strong>查看程序是否带有调试信息</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -S &lt;executable&gt; | grep debug</span><br></pre></td></tr></table></figure>
<p><strong>生成Core文件方法</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/data/coredump/core.%e.%p&quot;</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
<p><strong>编译包含调试信息的可执行文件</strong>：使用 <code>-g</code> 选项编译源代码，以确保生成的可执行文件包含调试信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g main.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p><strong>调试Core文件</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb &lt;executable&gt; &lt;core_file&gt;</span><br></pre></td></tr></table></figure>
<h3 id="gdb-常用命令">gdb 常用命令</h3>
<p><strong>启动GDB</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb &lt;executable&gt;</span><br></pre></td></tr></table></figure>
<p><strong>载入被调试程序</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file &lt;executable&gt;</span><br></pre></td></tr></table></figure>
<p><strong>查看源码</strong>:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>列出指定行号的代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list &lt;line_number&gt;,&lt;line_number&gt;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>列出指定文件的源码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list &lt;filename&gt;:&lt;line_number&gt;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>列出指定函数的源码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list &lt;function_name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>运行程序</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run [arguments]</span><br></pre></td></tr></table></figure>
<p><strong>设置断点</strong>:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过行号设置断点:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> &lt;filename&gt;:&lt;line_number&gt;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>通过函数名设置断点:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> &lt;function_name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>设置条件断点:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> &lt;line_number&gt; <span class="keyword">if</span> &lt;condition&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>查看断点</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure>
<p><strong>删除断点</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete &lt;breakpoint_number&gt;</span><br></pre></td></tr></table></figure>
<p><strong>删除所有断点</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure>
<p><strong>禁用/启用所有断点</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disable</span> &lt;breakpoint_number&gt;</span><br><span class="line"><span class="built_in">enable</span> &lt;breakpoint_number&gt;</span><br></pre></td></tr></table></figure>
<p><strong>单步调试</strong>:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>单步进入（进入函数内部）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">step</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>单步执行（不进入函数内部）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">next</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>继续执行到下一个断点</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p><strong>查看变量</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> &lt;variable_name&gt;</span><br></pre></td></tr></table></figure>
<p><strong>设置变量</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> variable &lt;variable_name&gt; = &lt;value&gt;</span><br></pre></td></tr></table></figure>
<p><strong>设置观察点</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch &lt;variable_name&gt;</span><br></pre></td></tr></table></figure>
<p><strong>查看函数调用栈</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backtrace</span><br></pre></td></tr></table></figure>
<p><strong>分屏调试</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -tui &lt;executable&gt;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>上半屏显示代码，下半屏显示 GDB 交互界面。</p>
</li>
<li class="lvl-2">
<p>使用方向键调整源代码视图。</p>
</li>
<li class="lvl-2">
<p>使用 <code>fs n</code> 或 <code>focus next</code> 切换焦点。</p>
</li>
</ul>
<h2 id="Gdb调试死锁">Gdb调试死锁</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> g_tickets = <span class="number">100</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> g_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_proc1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line">        <span class="keyword">if</span> (g_tickets &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 1 sell tickets:%d\n&quot;</span>, g_tickets--);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;g_mutex); <span class="comment">// 错误地再次加锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_lock(&amp;g_mutex); <span class="comment">// 错误地再次加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_proc2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;g_mutex);</span><br><span class="line">        <span class="keyword">if</span> (g_tickets &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 2 sell tickets:%d\n&quot;</span>, g_tickets--);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;g_mutex); <span class="comment">// 正确的解锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex); <span class="comment">// 正确的解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit((<span class="type">void</span>*)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">void</span> *ret1, *ret2;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_proc1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_proc2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1, &amp;ret1);</span><br><span class="line">    pthread_join(tid2, &amp;ret2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret1:%d\n&quot;</span>,(<span class="type">int</span>)ret1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret2:%d\n&quot;</span>,(<span class="type">int</span>)ret2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译运行">编译运行</h3>
<ol>
<li class="lvl-3">
<p>编译代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -lpthread -o test</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>运行程序：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>输出结果：</strong> 程序输出&quot;thread 1 sell tickets:…&quot;直到死锁发生。</p>
</li>
</ol>
<h3 id="调试方法1">调试方法1</h3>
<ol>
<li class="lvl-3">
<p>查看test进程号：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ps aux | grep test</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>查看进程中的所有线程：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pstree -p &lt;process_id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用GDB调试：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>启动GDB：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gdb</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>附加到进程：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">attach &lt;process_id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>查看所有线程的堆栈跟踪：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">thread apply all bt</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/09/01/jMHENBayplD2AoC.png" alt=""></p>
<h3 id="调试方法2">调试方法2</h3>
<ol>
<li class="lvl-3">
<p>查看test进程号：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ps -e | grep test</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用GDB调试：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>启动GDB并附加到进程：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gdb test &lt;process_id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>显示所有线程信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>切换到特定线程（例如第二个线程）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">thread 2</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>查看该线程的堆栈跟踪，以确定死锁位置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bt</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/09/01/MsDmtgBJEGa4fTC.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	GDB调试指南(入门，看这篇够了): <a href="https://blog.csdn.net/chen1415886044/article/details/105094688">https://blog.csdn.net/chen1415886044/article/details/105094688</a></p>
<p>[2]	GDB：调试死锁:<a href="https://blog.csdn.net/guowenyan001/article/details/46238355">https://blog.csdn.net/guowenyan001/article/details/46238355</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Gdb</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层网络模型</title>
    <url>/archives/3c19d3a7.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="OSI模型">OSI模型</h2>
<p>（会话层、表示层、应用层合并为TCP/IP的应用层）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>大纲</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/18/IfktaOKuwS45nm1.webp" alt=""></p>
<span id="more"></span>
<h3 id="各层解析">各层解析</h3>
<ol>
<li class="lvl-3">
<p>物理层</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/18/uLztrEsKmQZN74I.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>数据链路层</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/18/JQFMxC5B7bkPtou.webp" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>网络层</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/18/ruemEQ26vkc1Owf.webp" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>传输层</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/18/YlJDAwKqOFZ9u5U.png" alt=""></p>
<ol start="5">
<li class="lvl-3">
<p>应用层</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/18/peQ9lFVvx6Jb4GU.png" alt=""></p>
<ol start="6">
<li class="lvl-3">
<p>pc连网的设置详解</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/18/MfoGWkYmIwuKABJ.webp" alt=""></p>
<h3 id="数据包解析">数据包解析</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据链路层数据包（以太网数据包）格式，除了应用层没有头部，其他都有</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/18/iaG76EPWfoCRkuH.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于以太网数据包的数据部分，最大长度为1500字节，当IP包过大时，会分割下来，但是每个分割包的头部都一样</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/18/hL8u6zeRbWtpY3Z.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据包在传送时的封装和解封装如下所示</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/18/9UdeiVP3MABnHTN.png" alt=""></p>
<h2 id="OSI和TCP-IP区别">OSI和TCP/IP区别</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>OSI: open system interconnection 开放式系统互联参考模型</p>
</li>
<li class="lvl-2">
<p>OSI 和TCP/IP 的对应关系和协议</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/18/ptjbDCcnh5qwBJX.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>OSI模型各层的基本作用</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/05/18/Aeom67iSzTGlrUx.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	OSI 7层模型和TCP/IP 4层模型：<a href="https://zhuanlan.zhihu.com/p/32059190">https://zhuanlan.zhihu.com/p/32059190</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>同步、异步、阻塞、非阻塞</title>
    <url>/archives/55b0962b.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h3 id="IO操作">IO操作</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CopyIO分两阶段（一旦拿到数据后就变成了数据操作，不再是IO）：</span><br><span class="line"><span class="code">    1.数据准备阶段</span></span><br><span class="line"><span class="code">    2.内核空间复制数据到用户进程缓冲区（用户空间）阶段</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">在操作系统中，程序运行的空间分为内核空间和用户空间。</span><br><span class="line"><span class="code">    应用程序都是运行在用户空间的，所以它们能操作的数据也都在用户空间。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">阻塞IO和非阻塞IO的区别在于第一步发起IO请求是否会被阻塞：</span><br><span class="line"><span class="code">    如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">一般来讲：</span><br><span class="line"><span class="code">    阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">同步IO和异步IO的区别就在于第二个步骤是否阻塞：</span><br><span class="line"><span class="code">    如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><img src="https://s2.loli.net/2024/04/05/d3vbT5BYtQhRXOe.png" alt="img"></p>
<h3 id="同步和异步IO-阻塞和非阻塞IO">同步和异步IO 阻塞和非阻塞IO</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Copy同步和异步IO的概念：</span><br><span class="line"></span><br><span class="line">	同步是用户线程发起<span class="selector-tag">I</span>/O请求后需要等待或者轮询内核<span class="selector-tag">I</span>/O操作完成后才能继续执行</span><br><span class="line"></span><br><span class="line">	异步是用户线程发起<span class="selector-tag">I</span>/O请求后仍需要继续执行，当内核<span class="selector-tag">I</span>/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数</span><br><span class="line"></span><br><span class="line">阻塞和非阻塞IO的概念：</span><br><span class="line"></span><br><span class="line">	阻塞是指<span class="selector-tag">I</span>/O操作需要彻底完成后才能返回用户空间</span><br><span class="line"></span><br><span class="line">	非阻塞是指<span class="selector-tag">I</span>/O操作被调用后立即返回一个状态值，无需等<span class="selector-tag">I</span>/O操作彻底完成</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/04/05/BYdKQewpI9iA5v1.png" alt="img"></p>
<p><img src="https://s2.loli.net/2024/04/05/5RqyJZeK6Hc8E91.png" alt="img"></p>
<p><img src="https://s2.loli.net/2024/04/05/lsnL8egyqQ6pA2N.png" alt="img"></p>
<h3 id="同步与异步（线程间调用）">同步与异步（线程间调用）</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Copy同步与异步是对应于调用者与被调用者，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的</span><br><span class="line"></span><br><span class="line"><span class="code">	同步操作时，调用者需要等待被调用者返回结果，才会进行下一步操作</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	而异步则相反，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果</span></span><br></pre></td></tr></table></figure>
<h3 id="阻塞与非阻塞（线程内调用）同步与异步调用-线程-通信">阻塞与非阻塞（线程内调用）同步与异步调用/线程/通信</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Copy同步就是两种东西通过一种机制实现步调一致，异步是两种东西不必步调一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一、同步调用与异步调用：</span><br><span class="line"></span><br><span class="line"><span class="code">    在用在调用场景中，无非是对调用结果的不同处理。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    同步调用就是调用一但返回，就能知道结果，而异步是返回时不一定知道结果，还得通过其他机制来获知结果，如：</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        a. 状态 b. 通知 c. 回调函数</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">二、同步线程与异步线程：</span><br><span class="line"></span><br><span class="line"><span class="code">    同步线程：即两个线程步调要一致，其中一个线程可能要阻塞等待另外一个线程的运行，要相互协商。快的阻塞一下等到慢的步调一致。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    异步线程：步调不用一致，各自按各自的步调运行，不受另一个线程的影响。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line">三、同步通信与异步通信：</span><br><span class="line"></span><br><span class="line"><span class="code">    同步和异步是指：发送方和接收方是否协调步调一致</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    同步通信是指：发送方和接收方通过一定机制，实现收发步调协调。</span></span><br><span class="line"><span class="code">        如：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    异步通信是指：发送方的发送不管接收方的接收状态。</span></span><br><span class="line"><span class="code">        如：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">阻塞可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。</span><br><span class="line"></span><br><span class="line">同步是两个对象之间的关系，而阻塞是一个对象的状态。</span><br></pre></td></tr></table></figure>
<h3 id="四种组合方式">四种组合方式</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Copy同步阻塞方式：</span><br><span class="line"><span class="code">    发送方发送请求之后一直等待响应。</span></span><br><span class="line"><span class="code">    接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">同步非阻塞方式：</span><br><span class="line"><span class="code">	发送方发送请求之后，一直等待响应。</span></span><br><span class="line"><span class="code">	接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。</span></span><br><span class="line"><span class="code">	但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。</span></span><br><span class="line"><span class="code">	当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">异步阻塞方式：</span><br><span class="line"><span class="code">	发送方向接收方请求后，不等待响应，可以继续其他工作。</span></span><br><span class="line"><span class="code">	接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">异步非阻塞方式：</span><br><span class="line"><span class="code">	发送方向接收方请求后，不等待响应，可以继续其他工作。</span></span><br><span class="line"><span class="code">	接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。</span></span><br><span class="line"><span class="code">	当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门教程</title>
    <url>/archives/29207ea7.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Git简介">Git简介</h2>
<p><code>Git</code> 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 <code>Git</code> 来做自己的文档版本管理工具。</p>
<p>大概是大二的时候开始接触和使用Git，从一开始的零接触到现在的重度依赖，真是感叹 <code>Git</code> 的强大。</p>
<p><code>Git</code> 的api很多，但其实平时项目中90%的需求都只需要用到几个基本的功能即可，所以本文将从 <code>实用主义</code> 和 <code>深入探索</code> 2个方面去谈谈如何在项目中使用 <code>Git</code>，一般来说，看完 <code>实用主义</code> 这一节就可以开始在项目中动手用。</p>
<blockquote>
<p>“</p>
<p>说明：本文的操作都是基于 Mac 系统</p>
</blockquote>
<span id="more"></span>
<h2 id="实用主义">实用主义</h2>
<h3 id="准备阶段">准备阶段</h3>
<p>进入 Git官网 下载合适你的安装包，安装好 <code>Git</code> 后，打开命令行工具，进入工作文件夹（<em>为了便于理解我们在系统桌面上演示</em>），创建一个新的demo文件夹。</p>
<p><img src="https://s2.loli.net/2023/11/09/3pCe2amBO4Dh9tl.png" alt=""></p>
<p>进入 Github网站 注册一个账号并登录，进入 我的博客，点击 <code>Clone or download</code>，再点击 <code>Use HTTPS</code> ，复制项目地址 <code>https://github.com/gafish/gafish.github.com.git</code> 备用。</p>
<p>再回到命令行工具，一切就绪，接下来进入本文的重点。</p>
<h3 id="常用操作">常用操作</h3>
<p>所谓实用主义，就是掌握了以下知识就可以玩转 <code>Git</code>，轻松应对90%以上的需求。以下是实用主义型的Git命令列表，先大致看一下</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>git clone</code></p>
</li>
<li class="lvl-2">
<p><code>git config</code></p>
</li>
<li class="lvl-2">
<p><code>git branch</code></p>
</li>
<li class="lvl-2">
<p><code>git checkout</code></p>
</li>
<li class="lvl-2">
<p><code>git status</code></p>
</li>
<li class="lvl-2">
<p><code>git add</code></p>
</li>
<li class="lvl-2">
<p><code>git commit</code></p>
</li>
<li class="lvl-2">
<p><code>git push</code></p>
</li>
<li class="lvl-2">
<p><code>git pull</code></p>
</li>
<li class="lvl-2">
<p><code>git log</code></p>
</li>
<li class="lvl-2">
<p><code>git tag</code></p>
</li>
</ul>
<p>接下来，将通过对 我的博客 仓库进行实例操作，讲解如何使用 <code>Git</code> 拉取代码到提交代码的整个流程。</p>
<h4 id="git-clone">git clone</h4>
<blockquote>
<p>“</p>
<p>从git服务器拉取代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/gafish/gafish.github.com.git</span><br></pre></td></tr></table></figure>
<p>代码下载完成后在当前文件夹中会有一个 <code>gafish.github.com</code> 的目录，通过 <code>cd gafish.github.com</code> 命令进入目录。</p>
<h4 id="git-config">git config</h4>
<blockquote>
<p>“</p>
<p>配置开发者用户名和邮箱</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name gafish</span><br><span class="line">git config user.email gafish@qqqq.com</span><br></pre></td></tr></table></figure>
<p>每次代码提交的时候都会生成一条提交记录，其中会包含当前配置的用户名和邮箱。</p>
<h4 id="git-branch">git branch</h4>
<blockquote>
<p>“</p>
<p>创建、重命名、查看、删除项目分支，通过 <code>Git</code> 做项目开发时，一般都是在开发分支中进行，开发完成后合并分支到主干。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch daily/0.0.0</span><br></pre></td></tr></table></figure>
<p>创建一个名为 <code>daily/0.0.0</code> 的日常开发分支，分支名只要不包括特殊字符即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -m daily/0.0.0 daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>如果觉得之前的分支名不合适，可以为新建的分支重命名，重命名分支名为 <code>daily/0.0.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>通过不带参数的branch命令可以查看当前项目分支列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>如果分支已经完成使命则可以通过 <code>-d</code> 参数将分支删除，这里为了继续下一步操作，暂不执行删除操作</p>
<h4 id="git-checkout">git checkout</h4>
<blockquote>
<p>“</p>
<p>切换分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>切换到 <code>daily/0.0.1</code> 分支，后续的操作将在这个分支上进行</p>
<h4 id="git-status">git status</h4>
<blockquote>
<p>“</p>
<p>查看文件变动状态</p>
</blockquote>
<p>通过任何你喜欢的编辑器对项目中的 <code>README.md</code> 文件做一些改动，保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>通过 <code>git status</code> 命令可以看到文件当前状态 <code>Changes not staged for commit:</code>（<em>改动文件未提交到暂存区</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch daily/0.0.1</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    modified:   README.md</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="git-add">git add</h4>
<blockquote>
<p>“</p>
<p>添加文件变动到暂存区</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure>
<p>通过指定文件名 <code>README.md</code> 可以将该文件添加到暂存区，如果想添加所有文件可用 <code>git add .</code> 命令，这时候可通过 <code>git status</code> 看到文件当前状态 <code>Changes to be committed:</code> （<em>文件已提交到暂存区</em>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch daily/0.0.1</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure>
<h4 id="git-commit">git commit</h4>
<blockquote>
<p>“</p>
<p>提交文件变动到版本库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;这里写提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>通过 <code>-m</code> 参数可直接在命令行里输入提交描述文本</p>
<h4 id="git-push">git push</h4>
<blockquote>
<p>“</p>
<p>将本地的代码改动推送到服务器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin daily/0.0.1</span><br></pre></td></tr></table></figure>
<p><code>origin</code> 指代的是当前的git服务器地址，这行命令的意思是把 <code>daily/0.0.1</code> 分支推送到服务器，当看到命令行返回如下字符表示推送成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local objects.</span><br><span class="line">To https://github.com/gafish/gafish.github.com.git</span><br><span class="line"> * [new branch]      daily/0.0.1 -&gt; daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>现在我们回到Github网站的项目首页，点击 <code>Branch:master</code> 下拉按钮，就会看到刚才推送的 <code>daily/00.1</code> 分支了</p>
<h4 id="git-pull">git pull</h4>
<blockquote>
<p>“</p>
<p>将服务器上的最新代码拉取到本地</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>如果其它项目成员对项目做了改动并推送到服务器，我们需要将最新的改动更新到本地，这里我们来模拟一下这种情况。</p>
<p>进入Github网站的项目首页，再进入 <code>daily/0.0.1</code> 分支，在线对 <code>README.md</code> 文件做一些修改并保存，然后在命令中执行以上命令，它将把刚才在线修改的部分拉取到本地，用编辑器打开 <code>README.md</code> ，你会发现文件已经跟线上的内容同步了。</p>
<p><em>如果线上代码做了变动，而你本地的代码也有变动，拉取的代码就有可能会跟你本地的改动冲突，一般情况下 <code>Git</code> 会自动处理这种冲突合并，但如果改动的是同一行，那就需要手动来合并代码，编辑文件，保存最新的改动，再通过 <code>git add .</code>和 <code>git commit -m 'xxx'</code> 来提交合并。</em></p>
<h4 id="git-log">git log</h4>
<blockquote>
<p>“</p>
<p>查看版本提交记录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>通过以上命令，我们可以查看整个项目的版本提交记录，它里面包含了<code>提交人</code>、<code>日期</code>、<code>提交原因</code>等信息，得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit c334730f8dba5096c54c8ac04fdc2b31ede7107a</span><br><span class="line">Author: gafish &lt;gafish@qqqq.com&gt;</span><br><span class="line">Date:   Wed Jan 11 09:44:13 2017 +0800</span><br><span class="line">    Update README.md</span><br><span class="line">commit ba6e3d21fcb1c87a718d2a73cdd11261eb672b2a</span><br><span class="line">Author: gafish &lt;gafish@qqqq.com&gt;</span><br><span class="line">Date:   Wed Jan 11 09:31:33 2017 +0800</span><br><span class="line">    test</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>提交记录可能会非常多，按 <code>J</code> 键往下翻，按 <code>K</code> 键往上翻，按 <code>Q</code> 键退出查看</p>
<h4 id="git-tag">git tag</h4>
<blockquote>
<p>“</p>
<p>为项目标记里程碑</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag publish/0.0.1</span><br><span class="line">git push origin publish/0.0.1</span><br></pre></td></tr></table></figure>
<p>当我们完成某个功能需求准备发布上线时，应该将此次完整的项目代码做个标记，并将这个标记好的版本发布到线上，这里我们以 <code>publish/0.0.1</code> 为标记名并发布，当看到命令行返回如下内容则表示发布成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/gafish/gafish.github.com.git</span><br><span class="line"> * [new tag]         publish/0.0.1 -&gt; publish/0.0.1</span><br></pre></td></tr></table></figure>
<h4 id="gitignore">.gitignore</h4>
<blockquote>
<p>“</p>
<p>设置哪些内容不需要推送到服务器，这是一个配置文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure>
<p><code>.gitignore</code> 不是 <code>Git</code> 命令，而在项目中的一个文件，通过设置 <code>.gitignore</code> 的内容告诉 <code>Git</code> 哪些文件应该被忽略不需要推送到服务器，通过以上命令可以创建一个 <code>.gitignore</code> 文件，并在编辑器中打开文件，每一行代表一个要忽略的文件或目录，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo.html</span><br><span class="line">build/</span><br></pre></td></tr></table></figure>
<p>以上内容的意思是 <code>Git</code> 将忽略 <code>demo.html</code> 文件 和 <code>build/</code> 目录，这些内容不会被推送到服务器上</p>
<h4 id="小结">小结</h4>
<p>通过掌握以上这些基本命令就可以在项目中开始用起来了，如果追求实用，那关于 <code>Git</code> 的学习就可以到此结束了，偶尔遇到的问题也基本上通过 <code>Google</code> 也能找到答案，如果想深入探索 <code>Git</code> 的高阶功能，那就继续往下看 <code>深入探索</code> 部分。</p>
<h2 id="深入探索">深入探索</h2>
<h3 id="基本概念">基本概念</h3>
<h4 id="工作区（Working-Directory）">工作区（<em>Working Directory</em>）</h4>
<p>就是你在电脑里能看到的目录，比如上文中的 <code>gafish.github.com</code> 文件夹就是一个工作区<img src="https://s2.loli.net/2023/11/09/nbtfv64AZhByPRC.jpg" alt=""></p>
<h4 id="本地版本库（Local-Repository）">本地版本库（<em>Local Repository</em>）</h4>
<p>工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库。</p>
<p><img src="https://s2.loli.net/2023/11/09/mCwzseD6itVTPLr.jpg" alt=""></p>
<h4 id="暂存区（stage）">暂存区（<em>stage</em>）</h4>
<p>本地版本库里存了很多东西，其中最重要的就是称为 <code>stage</code>（或者叫index）的暂存区，还有 <code>Git</code> 为我们自动创建的第一个分支 <code>master</code>，以及指向 <code>master</code> 的一个指针叫 <code>HEAD</code>。</p>
<h4 id="远程版本库（Remote-Repository）">远程版本库（<em>Remote Repository</em>）</h4>
<p>一般指的是 <code>Git</code> 服务器上所对应的仓库，本文的示例所在的<code>github</code>仓库就是一个远程版本库<img src="https://s2.loli.net/2023/11/09/mAtY1qnOJVd2oRb.jpg" alt=""></p>
<h4 id="以上概念之间的关系">以上概念之间的关系</h4>
<p><code>工作区</code>、<code>暂存区</code>、<code>本地版本库</code>、<code>远程版本库</code>之间几个常用的 <code>Git</code> 操作流程如下图所示：</p>
<p><img src="https://s2.loli.net/2023/11/09/uj36xbnd7MsPRpa.jpg" alt=""></p>
<h4 id="分支（Branch）">分支（<em>Branch</em>）</h4>
<p>分支是为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改</p>
<p><img src="https://s2.loli.net/2023/11/09/yKgbNPiQkcB9RuU.png" alt=""></p>
<h4 id="主分支（Master）">主分支（<em>Master</em>）</h4>
<p>前面提到过 <code>master</code> 是 <code>Git</code> 为我们自动创建的第一个分支，也叫主分支，其它分支开发完成后都要合并到 <code>master</code></p>
<p><img src="https://s2.loli.net/2023/11/09/rUVFvK3J9elEqon.png" alt=""></p>
<h4 id="标签（Tag）">标签（<em>Tag</em>）</h4>
<p>标签是用于标记特定的点或提交的历史，通常会用来标记发布版本的名称或版本号（如：<code>publish/0.0.1</code>），虽然标签看起来有点像分支，但打上标签的提交是固定的，不能随意的改动，参见上图中的<code>1.0</code> / <code>2.0</code> / <code>3.0</code></p>
<h4 id="HEAD">HEAD</h4>
<p><code>HEAD</code> 指向的就是当前分支的最新提交</p>
<p><img src="https://s2.loli.net/2023/11/09/Xkp9wrj3F6gCInN.png" alt=""></p>
<blockquote>
<p>“</p>
<p>以上概念了解的差不多，那就可以继续往下看，下面将以具体的操作类型来讲解 <code>Git</code> 的高阶用法</p>
</blockquote>
<h3 id="操作文件">操作文件</h3>
<h4 id="git-add-2">git add</h4>
<blockquote>
<p>“</p>
<p>添加文件到暂存区</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure>
<p>通过此命令将打开交互式子命令系统，你将看到如下子命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***Commands***</span><br><span class="line">  1: status      2: update      3: revert      4: add untracked</span><br><span class="line">  5: patch      6: diff      7: quit      8: help</span><br></pre></td></tr></table></figure>
<p>通过输入序列号或首字母可以选择相应的功能，具体的功能解释如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>status</code>：功能上和 <code>git add -i</code> 相似，没什么鸟用</p>
</li>
<li class="lvl-2">
<p><code>update</code>：详见下方 <code>git add -u</code></p>
</li>
<li class="lvl-2">
<p><code>revert</code>：把已经添加到暂存区的文件从暂存区剔除，其操作方式和 <code>update</code>类似</p>
</li>
<li class="lvl-2">
<p><code>add untracked</code>：可以把新增的文件添加到暂存区，其操作方式和 <code>update</code> 类似</p>
</li>
<li class="lvl-2">
<p><code>patch</code>：详见下方 <code>git add -p</code></p>
</li>
<li class="lvl-2">
<p><code>diff</code>：比较暂存区文件和本地版本库的差异，其操作方式和 <code>update</code> 类似</p>
</li>
<li class="lvl-2">
<p><code>quit</code>：退出 <code>git add -i</code> 命令系统</p>
</li>
<li class="lvl-2">
<p><code>help</code>：查看帮助信息</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure>
<p>直接进入交互命令中最有用的 <code>patch</code> 模式</p>
<p>这是交互命令中最有用的模式，其操作方式和 <code>update</code> 类似，选择后 <code>Git</code> 会显示这些文件的当前内容与本地版本库中的差异，然后您可以自己决定是否添加这些修改到暂存区，在命令行 <code>Stage deletion [y,n,q,a,d,/,?]?</code> 后输入 <code>y,n,q,a,d,/,?</code> 其中一项选择操作方式，具体功能解释如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>y：接受修改</p>
</li>
<li class="lvl-2">
<p>n：忽略修改</p>
</li>
<li class="lvl-2">
<p>q：退出当前命令</p>
</li>
<li class="lvl-2">
<p>a：添加修改</p>
</li>
<li class="lvl-2">
<p>d：放弃修改</p>
</li>
<li class="lvl-2">
<p>/：通过正则表达式匹配修改内容</p>
</li>
<li class="lvl-2">
<p>?：查看帮助信息</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure>
<p>直接进入交互命令中的 <code>update</code> 模式</p>
<p>它会先列出工作区 <code>修改</code> 或 <code>删除</code> 的文件列表，<code>新增</code> 的文件不会被显示，在命令行 <code>Update&gt;&gt;</code> 后输入相应的列表序列号表示选中该项，回车继续选择，如果已选好，直接回车回到命令主界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add --ignore-removal .</span><br></pre></td></tr></table></figure>
<p>添加工作区 <code>修改</code> 或 <code>新增</code> 的文件列表， <code>删除</code> 的文件不会被添加</p>
<h4 id="git-commit-2">git commit</h4>
<blockquote>
<p>“</p>
<p>把暂存区的文件提交到本地版本库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;第一行提交原因&#x27;  -m &#x27;第二行提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>不打开编辑器，直接在命令行中输入多行提交原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -am &#x27;提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>将工作区 <code>修改</code> 或 <code>删除</code> 的文件提交到本地版本库， <code>新增</code> 的文件不会被提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend -m &#x27;提交原因&#x27;</span><br></pre></td></tr></table></figure>
<p>修改最新一条提交记录的提交原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -C HEAD</span><br></pre></td></tr></table></figure>
<p>将当前文件改动提交到 <code>HEAD</code> 或当前分支的历史ID</p>
<h4 id="git-mv">git mv</h4>
<blockquote>
<p>“</p>
<p>移动或重命名文件、目录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv a.md b.md -f</span><br></pre></td></tr></table></figure>
<p>将 <code>a.md</code> 重命名为 <code>b.md</code> ，同时添加变动到暂存区，加 <code>-f</code> 参数可以强制重命名，相比用 <code>mv a.md b.md</code> 命令省去了 <code>git add</code> 操作</p>
<h4 id="git-rm">git rm</h4>
<blockquote>
<p>“</p>
<p>从工作区和暂存区移除文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm b.md</span><br></pre></td></tr></table></figure>
<p>从工作区和暂存区移除文件 <code>b.md</code> ，同时添加变动到暂存区，相比用 <code>rm b.md</code> 命令省去了 <code>git add</code> 操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm src/ -r</span><br></pre></td></tr></table></figure>
<p>允许从工作区和暂存区移除目录</p>
<h4 id="git-status-2">git status</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure>
<p>以简短方式查看工作区和暂存区文件状态，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> M demo.html</span><br><span class="line">?? test.html</span><br><span class="line">git status --ignored</span><br></pre></td></tr></table></figure>
<p>查看工作区和暂存区文件状态，包括被忽略的文件</p>
<h3 id="操作分支">操作分支</h3>
<h4 id="git-branch-2">git branch</h4>
<blockquote>
<p>“</p>
<p>查看、创建、删除分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>查看本地版本库和远程版本库上的分支列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<p>查看远程版本库上的分支列表，加上 <code>-d</code> 参数可以删除远程版本库上的分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -D</span><br></pre></td></tr></table></figure>
<p>分支未提交到本地版本库前强制删除分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>
<p>查看带有最后提交id、最近提交原因等信息的本地版本库分支列表</p>
<p><img src="https://s2.loli.net/2023/11/09/vC3FyE5qDUiur9f.png" alt=""></p>
<h4 id="git-merge">git merge</h4>
<blockquote>
<p>“</p>
<p>将其它分支合并到当前分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge --squash</span><br></pre></td></tr></table></figure>
<p>将待合并分支上的 <code>commit</code> 合并成一个新的 <code>commit</code> 放入当前分支，适用于待合并分支的提交记录不需要保留的情况<img src="https://s2.loli.net/2023/11/09/KB5hNOTbUcn1sCE.gif" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>Git</code> 执行&quot;<code>快进式合并</code>&quot;（fast-farward merge），会直接将 <code>Master</code>分支指向 <code>Develop</code> 分支，使用 <code>--no-ff</code> 参数后，会执行正常合并，在 <code>Master</code>分支上生成一个新节点，保证版本演进更清晰。</p>
<p><img src="https://s2.loli.net/2023/11/09/bC41XyFQdtiW32s.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge --no-edit</span><br></pre></td></tr></table></figure>
<p>在没有冲突的情况下合并，不想手动编辑提交原因，而是用 <code>Git</code> 自动生成的类似 <code>Merge branch 'test'</code> 的文字直接提交</p>
<h4 id="git-checkout-2">git checkout</h4>
<blockquote>
<p>“</p>
<p>切换分支</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>创建 <code>daily/0.0.1</code> 分支，同时切换到这个新创建的分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout HEAD demo.html</span><br></pre></td></tr></table></figure>
<p>从本地版本库的 <code>HEAD</code>（也可以是提交ID、分支名、Tag名） 历史中检出 <code>demo.html</code> 覆盖当前工作区的文件，如果省略 <code>HEAD</code> 则是从暂存区检出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --orphan new_branch</span><br></pre></td></tr></table></figure>
<p>这个命令会创建一个全新的，完全没有历史记录的新分支，但当前源分支上所有的最新文件都还在，真是强迫症患者的福音，但这个新分支必须做一次 <code>git commit</code>操作后才会真正成为一个新分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -p other_branch</span><br></pre></td></tr></table></figure>
<p>这个命令主要用来比较两个分支间的差异内容，并提供交互式的界面来选择进一步的操作，这个命令不仅可以比较两个分支间的差异，还可以比较单个文件的差异。</p>
<h4 id="git-stash">git stash</h4>
<blockquote>
<p>“</p>
<p>在 <code>Git</code> 的栈中保存当前修改或删除的工作进度，当你在一个分支里做某项功能开发时，接到通知把昨天已经测试完没问题的代码发布到线上，但这时你已经在这个分支里加入了其它未提交的代码，这个时候就可以把这些未提交的代码存到栈里。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>将未提交的文件保存到Git栈中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>查看栈中保存的列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash show stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>显示栈中其中一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>移除栈中其中一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>从Git栈中检出最新保存的一条记录，并将它从栈中移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>从Git栈中检出其中一条记录，但不从栈中移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash branch new_banch</span><br></pre></td></tr></table></figure>
<p>把当前栈中最近一次记录检出并创建一个新分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
<p>清空栈里的所有记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash create</span><br></pre></td></tr></table></figure>
<p>为当前修改或删除的文件创建一个自定义的栈并返回一个ID，此时并未真正存储到栈里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash store xxxxxx</span><br></pre></td></tr></table></figure>
<p>将 <code>create</code> 方法里返回的ID放到 <code>store</code> 后面，此时在栈里真正创建了一个记录，但当前修改或删除的文件并未从工作区移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash create</span><br><span class="line">09eb9a97ad632d0825be1ece361936d1d0bdb5c7</span><br><span class="line">$ git stash store 09eb9a97ad632d0825be1ece361936d1d0bdb5c7</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: Created via &quot;git stash store&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="操作历史">操作历史</h3>
<h4 id="git-log-2">git log</h4>
<blockquote>
<p>“</p>
<p>显示提交历史记录</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure>
<p>显示带提交差异对比的历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log demo.html</span><br></pre></td></tr></table></figure>
<p>显示 <code>demo.html</code> 文件的历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --since=&quot;2 weeks ago&quot;</span><br></pre></td></tr></table></figure>
<p>显示2周前开始到现在的历史记录，其它时间可以类推</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --before=&quot;2 weeks ago&quot;</span><br></pre></td></tr></table></figure>
<p>显示截止到2周前的历史记录，其它时间可以类推</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -10</span><br></pre></td></tr></table></figure>
<p>显示最近10条历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log f5f630a..HEAD</span><br></pre></td></tr></table></figure>
<p>显示从提交ID <code>f5f630a</code> 到 <code>HEAD</code> 之间的记录，<code>HEAD</code> 可以为空或其它提交ID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>在一行中输出简短的历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h&quot;</span><br></pre></td></tr></table></figure>
<p>格式化输出历史记录</p>
<p><code>Git</code> 用各种 <code>placeholder</code> 来决定各种显示内容，我挑几个常用的显示如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>%H: commit hash</p>
</li>
<li class="lvl-2">
<p>%h: 缩短的commit hash</p>
</li>
<li class="lvl-2">
<p>%T: tree hash</p>
</li>
<li class="lvl-2">
<p>%t: 缩短的 tree hash</p>
</li>
<li class="lvl-2">
<p>%P: parent hashes</p>
</li>
<li class="lvl-2">
<p>%p: 缩短的 parent hashes</p>
</li>
<li class="lvl-2">
<p>%an: 作者名字</p>
</li>
<li class="lvl-2">
<p>%aN: mailmap的作者名</p>
</li>
<li class="lvl-2">
<p>%ae: 作者邮箱</p>
</li>
<li class="lvl-2">
<p>%ad: 日期 (–date= 制定的格式)</p>
</li>
<li class="lvl-2">
<p>%ar: 日期, 相对格式(1 day ago)</p>
</li>
<li class="lvl-2">
<p>%cn: 提交者名字</p>
</li>
<li class="lvl-2">
<p>%ce: 提交者 email</p>
</li>
<li class="lvl-2">
<p>%cd: 提交日期 (–date= 制定的格式)</p>
</li>
<li class="lvl-2">
<p>%cr: 提交日期, 相对格式(1 day ago)</p>
</li>
<li class="lvl-2">
<p>%d: ref名称</p>
</li>
<li class="lvl-2">
<p>%s: commit信息标题</p>
</li>
<li class="lvl-2">
<p>%b: commit信息内容</p>
</li>
<li class="lvl-2">
<p>%n: 换行</p>
</li>
</ul>
<h4 id="git-cherry-pick">git cherry-pick</h4>
<blockquote>
<p>“</p>
<p>合并分支的一条或几条提交记录到当前分支末梢</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick 170a305</span><br></pre></td></tr></table></figure>
<p>合并提交ID <code>170a305</code> 到当前分支末梢</p>
<h4 id="git-reset">git reset</h4>
<blockquote>
<p>“</p>
<p>将当前的分支重设（reset）到指定的 <code>&lt;commit&gt;</code> 或者 <code>HEAD</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --mixed &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<p><code>--mixed</code> 是不带参数时的默认参数，它退回到某个版本，保留文件内容，回退提交历史</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --soft &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<p>暂存区和工作区中的内容不作任何改变，仅仅把 <code>HEAD</code> 指向 <code>&lt;commit&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<p>自从 <code>&lt;commit&gt;</code> 以来在工作区中的任何改变都被丢弃，并把 <code>HEAD</code> 指向 <code>&lt;commit&gt;</code></p>
<h4 id="git-rebase">git rebase</h4>
<blockquote>
<p>“</p>
<p>重新定义分支的版本库状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase branch_name</span><br></pre></td></tr></table></figure>
<p>合并分支，这跟 <code>merge</code> 很像，但还是有本质区别，看下图：</p>
<p><img src="https://s2.loli.net/2023/11/09/WgEdkbiAX6nHuyK.jpg" alt=""></p>
<p>合并过程中可能需要先解决冲突，然后执行 <code>git rebase --continue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~~</span><br></pre></td></tr></table></figure>
<p>打开文本编辑器，将看到从 <code>HEAD</code> 到 <code>HEAD~~</code> 的提交如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 9a54fd4 添加commit的说明</span><br><span class="line">pick 0d4a808 添加pull的说明</span><br><span class="line"># Rebase 326fc9f..0d4a808 onto d286baa</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>将第一行的 <code>pick</code> 改成 <code>Commands</code> 中所列出来的命令，然后保存并退出，所对应的修改将会生效。如果移动提交记录的顺序，将改变历史记录中的排序。</p>
<h4 id="git-revert">git revert</h4>
<blockquote>
<p>“</p>
<p>撤销某次操作，此次操作之前和之后的 <code>commit</code> 和 <code>history</code> 都会保留，并且把这次撤销作为一次最新的提交</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure>
<p>撤销前一次提交操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert HEAD --no-edit</span><br></pre></td></tr></table></figure>
<p>撤销前一次提交操作，并以默认的 <code>Revert &quot;xxx&quot;</code> 为提交原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert -n HEAD</span><br></pre></td></tr></table></figure>
<p>需要撤销多次操作的时候加 <code>-n</code> 参数，这样不会每次撤销操作都提交，而是等所有撤销都完成后一起提交</p>
<h4 id="git-diff">git diff</h4>
<blockquote>
<p>“</p>
<p>查看工作区、暂存区、本地版本库之间的文件差异，用一张图来解释</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/6t2I5GeE1WYS4ur.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --stat</span><br></pre></td></tr></table></figure>
<p>通过 <code>--stat</code> 参数可以查看变更统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.md | 1 -</span><br><span class="line">1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure>
<h4 id="git-reflog">git reflog</h4>
<p><code>reflog</code> 可以查看所有分支的所有操作记录（包括commit和reset的操作、已经被删除的commit记录，跟 <code>git log</code> 的区别在于它不能查看已经删除了的commit记录<img src="https://s2.loli.net/2023/11/11/VpM9WLKwcDItBHn.jpg" alt=""></p>
<h3 id="远程版本库连接">远程版本库连接</h3>
<p>如果在GitHub项目初始化之前，文件已经存在于本地目录中，那可以在本地初始化本地版本库，再将本地版本库跟远程版本库连接起来</p>
<h4 id="git-init">git init</h4>
<blockquote>
<p>“</p>
<p>在本地目录内部会生成.git文件夹</p>
</blockquote>
<h4 id="git-remote">git remote</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>不带参数，列出已经存在的远程分支，加上 <code>-v</code> 列出详细信息，在每一个名字后面列出其远程url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/gafish/gafish.github.com.git</span><br></pre></td></tr></table></figure>
<p>添加一个新的远程仓库，指定一个名字，以便引用后面带的URL</p>
<h4 id="git-fetch">git fetch</h4>
<blockquote>
<p>“</p>
<p>将远程版本库的更新取回到本地版本库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin daily/0.0.1</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>git fetch</code> 取回所有分支的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<h3 id="问题排查">问题排查</h3>
<h4 id="git-blame">git blame</h4>
<blockquote>
<p>“</p>
<p>查看文件每行代码块的历史信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git blame -L 1,10 demo.html</span><br></pre></td></tr></table></figure>
<p>截取 <code>demo.html</code> 文件1-10行历史信息</p>
<h4 id="git-bisect">git bisect</h4>
<blockquote>
<p>“</p>
<p>二分查找历史记录，排查BUG</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect start</span><br></pre></td></tr></table></figure>
<p>开始二分查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect bad</span><br></pre></td></tr></table></figure>
<p>标记当前二分提交ID为有问题的点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect good</span><br></pre></td></tr></table></figure>
<p>标记当前二分提交ID为没问题的点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git bisect reset</span><br></pre></td></tr></table></figure>
<p>查到有问题的提交ID后回到原分支</p>
<h3 id="更多操作">更多操作</h3>
<h4 id="git-submodule">git submodule</h4>
<blockquote>
<p>“</p>
<p>通过 Git 子模块可以跟踪外部版本库，它允许在某一版本库中再存储另一版本库，并且能够保持2个版本库完全独立</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/gafish/demo.git demo</span><br></pre></td></tr></table></figure>
<p>将 <code>demo</code> 仓库添加为子模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update demo</span><br></pre></td></tr></table></figure>
<p>更新子模块 <code>demo</code></p>
<h4 id="git-gc">git gc</h4>
<blockquote>
<p>“</p>
<p>运行Git的垃圾回收功能，清理冗余的历史快照</p>
</blockquote>
<h4 id="git-archive">git archive</h4>
<blockquote>
<p>“</p>
<p>将加了tag的某个版本打包提取</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git archive -v --format=zip v0.1 &gt; v0.1.zip</span><br></pre></td></tr></table></figure>
<p><code>--format</code> 表示打包的格式，如 <code>zip</code>，<code>-v</code> 表示对应的tag名，后面跟的是tag名，如 <code>v0.1</code>。</p>
<h2 id="总结">总结</h2>
<p>本文只是对 <code>Git</code> 的所有功能中的部分实用功能做了一次探秘，Git非常强大，还有很多功能有待我们去发现，限于本文篇幅，咱就此打住吧，预知更多好用功能，请善用谷歌。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	gafish-<a href="https://github.com/gafish/gafish.github.com">https://github.com/gafish/gafish.github.com</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim入门教程</title>
    <url>/archives/e72b9632.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<p>你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。</p>
<p><a href="http://www.vim.org/">Vim</a> the Six Billion Dollar editor</p>
<blockquote>
<p>Better, Stronger, Faster.</p>
</blockquote>
<p>学习 <a href="http://www.vim.org/">vim</a> 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p>
<span id="more"></span>
<p>我建议下面这四个步骤：</p>
<ol>
<li class="lvl-3">
<p>存活</p>
</li>
<li class="lvl-3">
<p>感觉良好</p>
</li>
<li class="lvl-3">
<p>觉得更好，更强，更快</p>
</li>
<li class="lvl-3">
<p>使用VIM的超能力</p>
</li>
</ol>
<p>当你走完这篇文章，你会成为一个vim的 superstar。</p>
<p>在开始学习以前，我需要给你一些警告：学习vim在开始时是痛苦的；需要时间；需要不断地练习，就像你学习一个乐器一样；不要期望你能在3天内把vim练得比别的编辑器更有效率；事实上，你需要2周时间的苦练，而不是3天。</p>
<h3 id="第一级-–-存活">第一级 – 存活</h3>
<ol>
<li class="lvl-3">
<p>安装 <a href="http://www.vim.org/">vim</a></p>
</li>
<li class="lvl-3">
<p>启动 vim</p>
</li>
<li class="lvl-3">
<p><strong>什么也别干！</strong> 请先阅读</p>
</li>
</ol>
<p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>启 动Vim后，vim在 <em>Normal</em> 模式下。</p>
</li>
<li class="lvl-2">
<p>让我们进入 <em>Insert</em> 模式，请按下键 <code>i </code>。(vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</p>
</li>
<li class="lvl-2">
<p>此时，你可以输入文本了，就像你用“记事本”一样。</p>
</li>
<li class="lvl-2">
<p>如果你想返回 <em>Normal</em> 模式，请按 <code>ESC</code> 键。</p>
</li>
</ul>
<p>现在，你知道如何在 <em>Insert</em> 和 <em>Normal</em> 模式下切换了。下面是一些命令，可以让你在 <em>Normal</em> 模式下幸存下来：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</p>
</li>
<li class="lvl-2">
<p><code>x</code> → 删当前光标所在的一个字符。</p>
</li>
<li class="lvl-2">
<p><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)  （:w 后可以跟文件名）</p>
</li>
<li class="lvl-2">
<p><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</p>
</li>
<li class="lvl-2">
<p><code>p</code> → 粘贴剪贴板</p>
</li>
</ul>
<p><strong>推荐</strong>:</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</p>
</li>
<li class="lvl-2">
<p><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（退出帮助需要输入:q）</p>
</li>
</ul>
</blockquote>
<p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>当是，在你进入第二级时，需要再说一下 <em>Normal</em> 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 <code>Ctrl</code> 键，比如：<code>Ctrl-C</code>。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，<strong>在VIM的Normal模式下，所有的键就是功能键了</strong>。这个你需要知道。</p>
<p>标记:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>下面的文字中，如果是 <code>Ctrl-λ</code>我会写成 <code>&lt;C-λ&gt;</code>.</p>
</li>
<li class="lvl-2">
<p>以 <code>:</code> 开始的命令你需要输入 <code>&lt;enter&gt;</code>回车，例如 — 如果我写成 <code>:q</code> 也就是说你要输入 <code>:q&lt;enter&gt;</code>.</p>
</li>
</ul>
<h3 id="第二级-–-感觉良好">第二级 – 感觉良好</h3>
<p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）</p>
<ol>
<li class="lvl-3">
<p><strong>各种插入模式</strong></p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>a</code> → 在光标后插入</li>
<li class="lvl-2"><code>o</code> → 在当前行后插入一个新行</li>
<li class="lvl-2"><code>O</code> → 在当前行前插入一个新行</li>
<li class="lvl-2"><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>简单的移动光标</strong></p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>0</code> → 数字零，到行头</li>
<li class="lvl-2"><code>^</code> → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li>
<li class="lvl-2"><code>$</code> → 到本行行尾</li>
<li class="lvl-2"><code>g_</code> → 到本行最后一个不是blank字符的位置。</li>
<li class="lvl-2"><code>/pattern</code> → 搜索 <code>pattern</code> 的字符串（如果搜索出多个匹配，可按n键到下一个）</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>拷贝/粘贴</strong>（p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>P</code> → 粘贴</li>
<li class="lvl-2"><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>Undo/Redo</strong></p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>u</code> → undo</li>
<li class="lvl-2"><code>&lt;C-r&gt;</code> → redo</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>打开/保存/退出/改变文件</strong>(Buffer)</p>
<blockquote>
<ul class="lvl-3">
<li class="lvl-2"><code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li>
<li class="lvl-2"><code>:w</code> → 存盘</li>
<li class="lvl-2"><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></li>
<li class="lvl-2"><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li>
<li class="lvl-2"><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li>
<li class="lvl-2"><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（我喜欢使用:n到下一个文件）</li>
</ul>
</blockquote>
</li>
</ol>
<p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p>
<h3 id="第三级-–-更好，更强，更快">第三级 – 更好，更强，更快</h3>
<p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p>
<h4 id="更好">更好</h4>
<p>下面，让我们看一下vim是怎么重复自己的：</p>
<ol>
<li class="lvl-3">
<p><code>.</code> → (小数点) 可以重复上一次的命令</p>
</li>
<li class="lvl-3">
<p>N<command> → 重复某个命令N次</p>
</li>
</ol>
<p>下面是一个示例，找开一个文件你可以试试下面的命令：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>2dd</code> → 删除2行</p>
</li>
<li class="lvl-2">
<p><code>3p</code> → 粘贴文本3次</p>
</li>
<li class="lvl-2">
<p><code>100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</p>
</li>
<li class="lvl-2">
<p><code>.</code> → 重复上一个命令—— 100 “desu “.</p>
</li>
<li class="lvl-2">
<p><code>3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</p>
</li>
</ul>
</blockquote>
<h4 id="更强">更强</h4>
<p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong>。</p>
<ol>
<li class="lvl-3">
<p>N<code>G</code> → 到第 N 行 （注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</p>
</li>
<li class="lvl-3">
<p><code>gg</code> → 到第一行。（相当于1G，或 :1）</p>
</li>
<li class="lvl-3">
<p><code>G</code> → 到最后一行。</p>
</li>
<li class="lvl-3">
<p>按单词移动：</p>
<blockquote>
<ol>
<li class="lvl-3"><code>w</code> → 到下一个单词的开头。</li>
<li class="lvl-3"><code>e</code> → 到下一个单词的结尾。</li>
</ol>
<p>&gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（程序变量）</p>
<p>&gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（程序语句）</p>
<p><img src="https://s2.loli.net/2023/11/09/mBIdizGN6uRQYsr.jpg" alt=""></p>
</blockquote>
</li>
</ol>
<p>下面，让我来说说最强的光标移动：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>&#123;</code>, <code>[</code>. （你需要把光标先移到括号上）</p>
</li>
<li class="lvl-2">
<p><code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</p>
</li>
</ul>
</blockquote>
<p>相信我，上面这三个命令对程序员来说是相当强大的。</p>
<h4 id="更快">更快</h4>
<p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p>
<p><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code></p>
<p>例如 <code>0y$</code> 命令意味着：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>0</code> → 先到行头</p>
</li>
<li class="lvl-2">
<p><code>y</code> → 从这里开始拷贝</p>
</li>
<li class="lvl-2">
<p><code>$</code> → 拷贝到本行最后一个字符</p>
</li>
</ul>
<p>你可可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p>
<p>你也可以输入 <code>y2/foo</code> 来拷贝2个 “foo” 之间的字符串。</p>
<p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>d</code> (删除 )</p>
</li>
<li class="lvl-2">
<p><code>v</code> (可视化的选择)</p>
</li>
<li class="lvl-2">
<p><code>gU</code> (变大写)</p>
</li>
<li class="lvl-2">
<p><code>gu</code> (变小写)</p>
</li>
<li class="lvl-2">
<p>等等</p>
</li>
</ul>
<p>（可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）</p>
<h3 id="第四级-–-Vim-超能力">第四级 – Vim 超能力</h3>
<p>你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p>
<h4 id="在当前行上移动光标-0-f-F-t-T">在当前行上移动光标: <code>0</code> <code>^</code> <code>$</code> <code>f</code> <code>F</code> <code>t</code> <code>T</code> <code>,</code> <code>;</code></h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>0</code> → 到行头</p>
</li>
<li class="lvl-2">
<p><code>^</code> → 到本行的第一个非blank字符</p>
</li>
<li class="lvl-2">
<p><code>$</code> → 到行尾</p>
</li>
<li class="lvl-2">
<p><code>g_</code> → 到本行最后一个不是blank字符的位置。</p>
</li>
<li class="lvl-2">
<p><code>fa</code> → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</p>
</li>
<li class="lvl-2">
<p><code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</p>
</li>
<li class="lvl-2">
<p><code>3fa</code> → 在当前行查找第三个出现的a。</p>
</li>
<li class="lvl-2">
<p><code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。<br>
<img src="https://s2.loli.net/2023/11/09/W43m7EYbDtGw8s9.jpg" alt=""></p>
</li>
</ul>
</blockquote>
<p>还有一个很有用的命令是 <code>dt&quot;</code> → 删除所有的内容，直到遇到双引号—— <code>&quot;。</code></p>
<h4 id="区域选择-action-a-object-或-action-i-object">区域选择 <code>&lt;action&gt;a&lt;object&gt;</code> 或 <code>&lt;action&gt;i&lt;object&gt;</code></h4>
<p>在visual 模式下，这些命令很强大，其命令格式为</p>
<p><code>&lt;action&gt;a&lt;object&gt;</code> 和 <code>&lt;action&gt;i&lt;object&gt;</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>action可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)。</p>
</li>
<li class="lvl-2">
<p>object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>&quot;、</code> <code>'、</code> <code>)、</code> <code>&#125;、</code> <code>]。</code></p>
</li>
</ul>
<p>假设你有一个字符串 <code>(map (+) (&quot;foo&quot;))</code>.而光标键在第一个 <code>o </code>的位置。</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>vi&quot;</code> → 会选择 <code>foo</code>.</p>
</li>
<li class="lvl-2">
<p><code>va&quot;</code> → 会选择 <code>&quot;foo&quot;</code>.</p>
</li>
<li class="lvl-2">
<p><code>vi)</code> → 会选择 <code>&quot;foo&quot;</code>.</p>
</li>
<li class="lvl-2">
<p><code>va)</code> → 会选择<code>(&quot;foo&quot;)</code>.</p>
</li>
<li class="lvl-2">
<p><code>v2i)</code> → 会选择 <code>map (+) (&quot;foo&quot;)</code></p>
</li>
<li class="lvl-2">
<p><code>v2a)</code> → 会选择 <code>(map (+) (&quot;foo&quot;))</code></p>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/9yNEFqn7KPxBZVD.png" alt=""></p>
<h4 id="块操作-C-v">块操作: <code>&lt;C-v&gt;</code></h4>
<p>块操作，典型的操作： <code>0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>^</code> → 到行头</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-v&gt;</code> → 开始块操作</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-d&gt;</code> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)</p>
</li>
<li class="lvl-2">
<p><code>I-- [ESC]</code> → I是插入，插入“<code>--</code>”，按ESC键来为每一行生效。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/09/96cr5YmoZ4BzFXg.gif" alt=""></p>
<p>在Windows下的vim，你需要使用 <code>&lt;C-q&gt;</code> 而不是 <code>&lt;C-v&gt;</code> ，<code>&lt;C-v&gt;</code> 是拷贝剪贴板。</p>
<h4 id="自动提示：-C-n-和-C-p">自动提示： <code>&lt;C-n&gt;</code> 和 <code>&lt;C-p&gt;</code></h4>
<p>在 Insert 模式下，你可以输入一个词的开头，然后按 <code>&lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了……</code></p>
<p>``<img src="https://s2.loli.net/2023/11/09/XuSiyhszGdOlreT.gif" alt=""></p>
<h4 id="宏录制：-qa-操作序列-q-a">宏录制： <code>qa</code> 操作序列 <code>q</code>, <code>@a</code>, <code>@@</code></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>qa</code> 把你的操作记录在寄存器 <code>a。</code></p>
</li>
<li class="lvl-2">
<p>于是 <code>@a</code> 会replay被录制的宏。</p>
</li>
<li class="lvl-2">
<p><code>@@</code> 是一个快捷键用来replay最新录制的宏。</p>
</li>
</ul>
<blockquote>
<p>*<strong>示例*</strong></p>
<p>在一个只有一行且这一行只有“1”的文本中，键入如下命令：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>qaYp&lt;C-a&gt;q</code>→</p>
<ul class="lvl-3">
<li class="lvl-4"><code>qa</code> 开始录制</li>
<li class="lvl-4"><code>Yp</code> 复制行.</li>
<li class="lvl-4"><code>&lt;C-a&gt;</code> 增加1.</li>
<li class="lvl-4"><code>q</code> 停止录制.</li>
</ul>
</li>
<li class="lvl-2">
<p><code>@a</code> → 在1下面写下 2</p>
</li>
<li class="lvl-2">
<p><code>@@</code> → 在2 正面写下3</p>
</li>
<li class="lvl-2">
<p>现在做 <code>100@@</code> 会创建新的100行，并把数据增加到 103.</p>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/XfDJhsqvOPctITK.gif" alt=""></p>
<h4 id="可视化选择：-v-V-C-v">可视化选择： <code>v</code>,<code>V</code>,<code>&lt;C-v&gt;</code></h4>
<p>前面，我们看到了 <code>&lt;C-v&gt;</code>的示例 （在Windows下应该是<C-q>），我们可以使用 <code>v</code> 和 <code>V</code>。一但被选好了，你可以做下面的事：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>J</code> → 把所有的行连接起来（变成一行）</p>
</li>
<li class="lvl-2">
<p><code>&lt;</code> 或 <code>&gt;</code> → 左右缩进</p>
</li>
<li class="lvl-2">
<p><code>=</code> → 自动给缩进 （这个功能相当强大，我太喜欢了）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/09/IL7gktZrFwiauRW.gif" alt=""></p>
<p>在所有被选择的行后加上点东西：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;C-v&gt;</code></p>
</li>
<li class="lvl-2">
<p>选中相关的行 (可使用 <code>j</code> 或 <code>&lt;C-d&gt;</code> 或是 <code>/pattern</code> 或是 <code>%</code> 等……)</p>
</li>
<li class="lvl-2">
<p><code>$</code> 到行最后</p>
</li>
<li class="lvl-2">
<p><code>A</code>, 输入字符串，按 <code>ESC。</code></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/09/vCgLYdQp6VAlmyq.gif" alt=""></p>
<h4 id="分屏-split-和-vsplit">分屏: <code>:split</code> 和 <code>vsplit</code>.</h4>
<p>下面是主要的命令，你可以使用VIM的帮助 <code>:help split</code></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>:split</code> → 创建分屏 (<code>:vsplit</code>创建垂直分屏)</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-w&gt;&lt;dir&gt;</code> : dir就是方向，可以是 <code>hjkl</code> 或是 ←↓↑→ 中的一个，其用来切换分屏。</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-w&gt;_</code> (或 <code>&lt;C-w&gt;|</code>) : 最大化尺寸 (<C-w>| 垂直分屏)</p>
</li>
<li class="lvl-2">
<p><code>&lt;C-w&gt;+</code> (或 <code>&lt;C-w&gt;-</code>) : 增加尺寸</p>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2023/11/09/837saHlWQKLdbZr.gif" alt=""></p>
<h3 id="结束语">结束语</h3>
<p>这是我每天使用的命令的 90%。我建议您每天学习的新命令不超过一两个。两到三周后，您将开始感受到 vim 在您手中的力量。</p>
<p>学习 Vim 更多的是训练而不是简单的记忆。幸运的是，vim 附带了一些非常好的工具和优秀的文档。运行 vimtutor 直到您熟悉最基本的命令。另外，您应该仔细阅读此页面：<code>:help usr_02.txt</code>。</p>
<p>然后，您将了解<code>!</code>、折叠、寄存器、插件和许多其他功能。像学习钢琴一样学习 vim 一切都应该没问题。学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p>
<blockquote>
<p>如果您喜欢这篇文章，可以阅读后续文章：<a href="http://yannesposito.com/Scratch/en/blog/Vim-as-IDE/"><em>Vim 作为 IDE</em></a></p>
</blockquote>
<h3 id="Reference">Reference</h3>
<p>[1]	简明 VIM 练级攻略: <a href="https://coolshell.cn/articles/5426.html#%E6%9B%B4%E5%BF%AB">https://coolshell.cn/articles/5426.html#更快</a></p>
<p>[2]	Learn Vim Progressively: <a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>C++参数传递</title>
    <url>/archives/9460e0c1.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<p>在C++中，参数传递的方式是“实虚结合”。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>按值传递(pass by value)</p>
</li>
<li class="lvl-2">
<p>地址传递(pass by pointer)</p>
</li>
<li class="lvl-2">
<p>引用传递(pass by reference)</p>
</li>
</ul>
<span id="more"></span>
<h2 id="1-按值传递"><strong>1.按值传递</strong></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在按值传递中，函数参数是通过将其值复制给形式参数（函数内部的参数）来传递的。</p>
</li>
<li class="lvl-2">
<p>这意味着在函数内部对参数的任何修改都不会影响函数外部的原始值。</p>
</li>
<li class="lvl-2">
<p>按值传递适用于不需要修改原始值的情况，或者需要在函数内部创建局部副本以避免影响原始值的情况。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modifyValue</span>(value); <span class="comment">// value的值不会改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-引用传递"><strong>2.引用传递</strong></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在引用传递中，函数参数是通过传递它们的引用（或指针）来传递的，这意味着函数内部可以直接访问和修改原始值。</p>
</li>
<li class="lvl-2">
<p>这允许函数对原始数据进行修改，而不需要创建副本。</p>
</li>
<li class="lvl-2">
<p>按引用传递通常用于需要修改原始值或避免创建副本的情况。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyValue</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modifyValue</span>(value); <span class="comment">// value的值被修改为42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-传址调用（传指针）">3.传址调用（传指针）</h2>
<h3 id="一级指针做参数"><strong>一级指针做参数</strong></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">int</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">func_2</span>(&amp;a);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数接受一个值，这个值是地址，谁的地址？外部变量 <code>a</code> 的地址，函数创建一个临时变量（指针类型）来存储外部变量 <code>a</code> 的地址</p>
</li>
<li class="lvl-2">
<p>在函数内部使用临时变量 <code>a</code> 可得到外部变量 <code>a</code> 的地址，使用 <code>*a</code> 可以获取外部变量 <code>a</code> 地址中所存储的值</p>
</li>
<li class="lvl-2">
<p>这个临时变量 <code>a</code> 复制的是外部变量的地址，按值传递，无论怎么复制，地址是唯一的，通过地址来修改外部变量的值是可以实现的</p>
</li>
</ul>
<p><mark><strong>改变指针指向？</strong></mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">int</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="literal">NULL</span>;<span class="comment">//让指针指向空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> *b = &amp;a; <span class="comment">//这个b存储的是变量a的地址</span></span><br><span class="line"> <span class="built_in">func_2</span>(b);   <span class="comment">//要修改b的指向，看似可以修改，其实不可以,注意我说的是指向。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数创建临时变量a存储b的值，也就是变量a的地址；</p>
</li>
<li class="lvl-2">
<p>给变量a赋值为空，结果只是临时变量a被修改了值，而原外部变量b的值还是指向外部变量a的地址；</p>
</li>
<li class="lvl-2">
<p>所以该函数实现不了预期的功能。</p>
</li>
</ul>
<h3 id="二级指针做参数"><strong>二级指针做参数</strong></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_3</span><span class="params">(<span class="type">int</span> ** a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br><span class="line"><span class="type">int</span> ** c = &amp;b;</span><br><span class="line"><span class="built_in">func_3</span>(c);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数创建一个临时变量 <code>a</code> 来存储 <code>c</code> 的值，即 <code>b</code> 的地址。</p>
</li>
<li class="lvl-2">
<p>函数内部使用 <code>*a</code> 获取外部变量 <code>b</code> 存储的地址，从而可以修改 <code>b</code> 指针的指向。</p>
</li>
<li class="lvl-2">
<p>通过 <code>**a</code> 可以访问外部变量 <code>a</code> 的值，并对其进行修改。</p>
</li>
</ul>
<h2 id="总结"><strong>总结</strong></h2>
<blockquote>
<ol>
<li class="lvl-3">
<p>如果想要修改指针指向变量的值，则无需传入高一级的指针，使用同级指针即可；</p>
</li>
<li class="lvl-3">
<p>如果想要修改指针本身的值，也就是地址，则应使用比原指针高一级的指针来实现。</p>
</li>
</ol>
</blockquote>
<h2 id="Reference">Reference</h2>
<p>[1]	C/C++什么时候使用二级指针，你知道吗？: <a href="https://cloud.tencent.com/developer/article/1732047">https://cloud.tencent.com/developer/article/1732047</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>参数传递</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序与快速排序</title>
    <url>/archives/d48e34d2.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h1>选择排序</h1>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="算法步骤">算法步骤</h2>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<p>重复第二步，直到所有元素均排序完毕</p>
<span id="more"></span>
<h2 id="C-实现">C++实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr1 = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">selection_sort</span>(arr1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array (int): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; arr1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; arr2 = &#123;<span class="number">3.14</span>, <span class="number">2.71</span>, <span class="number">1.618</span>, <span class="number">0.707</span>, <span class="number">2.718</span>&#125;;</span><br><span class="line">    <span class="built_in">selection_sort</span>(arr2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array (float): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间复杂度 O(n^2)，需要遍历每个元素</p>
</li>
<li class="lvl-2">
<p>空间复杂度O(1)，不占用额外空间</p>
</li>
</ul>
<h1>快速排序</h1>
<p>快速排序是一种使用分治策略的排序算法。它选择一个元素作为“枢纽”或“基准”元素，然后将数组分为两个子数组——一个包含所有比基准元素小的元素，另一个包含所有比基准元素大的元素。然后对这两个子数组进行递归地快速排序。</p>
<h2 id="算法步骤-2">算法步骤</h2>
<ol>
<li class="lvl-3">
<p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>
</li>
<li class="lvl-3">
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li class="lvl-3">
<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
</li>
</ol>
<h2 id="C-实现：">C++实现：</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">Partition</span>(A, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++11优化随机快排</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机快排</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> leftBorder, <span class="type">int</span> rightBorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftBorder &gt;= rightBorder) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机中轴</span></span><br><span class="line">        <span class="type">int</span> pivot = leftBorder + <span class="built_in">rand</span>() % (rightBorder - leftBorder + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(nums[pivot], nums[leftBorder]);</span><br><span class="line">        <span class="type">int</span> left = leftBorder, right = rightBorder;</span><br><span class="line">        <span class="type">int</span> pivotNum = nums[leftBorder];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通快排</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivotNum) --right;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivotNum) ++left;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivotNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码是关键优化，缩小一下中轴范围，针对2，2，2，2，2...这种重复样本有效</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;<span class="number">0</span> &amp;&amp; nums[left] == nums[left<span class="number">-1</span>]) --left;</span><br><span class="line">        <span class="keyword">while</span>(right&lt; nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) ++right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归缩小范围的左右区域</span></span><br><span class="line">        <span class="built_in">qSort</span>(nums, leftBorder,left<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">qSort</span>(nums, right+<span class="number">1</span>, rightBorder);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">qSort</span>(nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间空间复杂度分析">时间空间复杂度分析</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间复杂度</p>
<p>对于最好和平均情况，快速排序的时间复杂度是 O(nlogn)。这是因为在这些情况下，每次分区操作，我们可以将数组分为两个近乎相等的部分。这就意味着每次递归调用处理一半的大小。</p>
<p>但是在最坏情况下（即当给定的数组已经完全排序或者完全逆序排列时），快排的时间复杂度是 O(n^2)。这是因为每次分区操作只能减少数组大小1。</p>
</li>
<li class="lvl-2">
<p>空间复杂度</p>
<ul class="lvl-2">
<li class="lvl-4">快速排序是原地排序，不需要额外的存储空间，所以空间复杂度为 O(1)。</li>
<li class="lvl-4">但是，快速排序是递归的，因此需要考虑递归栈的空间。在最坏的情况下，递归栈的深度为 O(n)。在平均情况下，递归栈的深度为 O(logn)。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>链表理论基础</title>
    <url>/archives/d993e4b5.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h1>链表理论基础</h1>
<p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。</p>
<p>如图所示：<br>
<img src="https://s2.loli.net/2023/07/20/v4NiFGLQ2RKoVct.png" alt=""></p>
<span id="more"></span>
<h2 id="链表的类型">链表的类型</h2>
<p>接下来说一下链表的几种类型:</p>
<h3 id="单链表">单链表</h3>
<p>刚刚说的就是单链表。</p>
<h3 id="双链表">双链表</h3>
<p>单链表中的指针域只能指向节点的下一个节点。</p>
<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<p>如图所示：<br>
<img src="https://s2.loli.net/2023/07/20/i9AY6NcoVEPCuTI.png" alt=""></p>
<h3 id="循环链表">循环链表</h3>
<p>循环链表，顾名思义，就是链表首尾相连。</p>
<p>循环链表可以用来解决约瑟夫环问题。</p>
<p><img src="https://s2.loli.net/2023/07/20/k5WugEJ743vYxfB.png" alt=""></p>
<h2 id="链表的存储方式">链表的存储方式</h2>
<p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p>
<p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p>
<p>链表是通过指针域的指针链接在内存中各个节点。</p>
<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<p>如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/lH21brhLCXZJysm.png" alt=""></p>
<p>这个链表起始节点为2， 终止节点为7，  各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p>
<h2 id="链表的定义">链表的定义</h2>
<p>接下来说一说链表的定义。</p>
<p>链表节点的定义，很多同学在面试的时候都写不好。</p>
<p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p>
<p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p>
<p>这里我给出C/C++的定义链表节点方式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p>
<p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p>
<p>通过自己定义构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>
<h2 id="链表的操作">链表的操作</h2>
<h3 id="删除节点">删除节点</h3>
<p>删除D节点，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/rji16Yx5Pu8SnwM.png" alt=""></p>
<p>只要将C节点的next指针 指向E节点就可以了。</p>
<p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p>
<p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p>
<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>
<h3 id="添加节点">添加节点</h3>
<p>如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/IDXKom186eRbqkz.png" alt=""></p>
<p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p>
<p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p>
<h2 id="性能分析">性能分析</h2>
<p>再把链表的特性和数组的特性进行一个对比，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/20/me92ILFzh1TJUnV.png" alt=""></p>
<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>
<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h2 id="其他语言版本">其他语言版本</h2>
<h3 id="Python：">Python：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	代码随想录: <a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数组理论基础</title>
    <url>/archives/6193d61a.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="数组理论基础">数组理论基础</h2>
<p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力</p>
<p>也就是说，想法很简单，但实现起来 可能就不是那么回事了。</p>
<span id="more"></span>
<p>首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题</p>
<p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p>
<p>举一个字符数组的例子，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/19/QksAyZeBXjWdVK9.png" alt=""></p>
<p>需要两点注意的是</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数组下标都是从0开始的。</strong></p>
</li>
<li class="lvl-2">
<p><strong>数组内存空间的地址是连续的</strong></p>
</li>
</ul>
<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p>
<p><img src="https://s2.loli.net/2023/07/19/5fqvJkEZWtDjSRL.png" alt=""></p>
<p>而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p>那么二维数组直接上图，大家应该就知道怎么回事了</p>
<p><img src="https://s2.loli.net/2023/07/19/inkBdNrhVDG3a5q.png" alt=""></p>
<p><strong>那么二维数组在内存的空间地址是连续的么？</strong></p>
<p>不同编程语言的内存管理是不一样的，以C<ins>为例，在C</ins>中二维数组是连续分布的。</p>
<p>我们来做一个实验，C++测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_arr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试地址为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffee4065820 0x7ffee4065824 0x7ffee4065828</span><br><span class="line">0x7ffee406582c 0x7ffee4065830 0x7ffee4065834</span><br></pre></td></tr></table></figure>
<p>注意地址为16进制，可以看出二维数组地址是连续一条线的。</p>
<p>一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节。</p>
<p>0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12。</p>
<p>如图：</p>
<p><img src="https://s2.loli.net/2023/07/19/1zu7ArUa3B6ZoLf.png" alt=""></p>
<p><strong>所以可以看出在C++中二维数组在地址空间上是连续的</strong>。</p>
<p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p>
<p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_arr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[I@7852e922</span><br><span class="line">[I@4e25154f</span><br><span class="line">[I@70dea4e</span><br><span class="line">[I@5c647e05</span><br></pre></td></tr></table></figure>
<p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p>
<p>所以Java的二维数组可能是如下排列的方式：</p>
<p><img src="https://s2.loli.net/2023/07/19/wxgSvju5EWHZlfL.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	代码随想录: <a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法的时间与空间复杂度</title>
    <url>/archives/bc5d8ac6.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<h3 id="究竟什么是时间复杂度">究竟什么是时间复杂度</h3>
<p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。</p>
<p>我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。</p>
<p>那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。</p>
<span id="more"></span>
<p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p>
<h3 id="什么是大O">什么是大O</h3>
<p>这里的大O是指什么呢，说到时间复杂度，<strong>大家都知道O(n)，O(n^2)，却说不清什么是大O</strong>。</p>
<p>算法导论给出的解释：<strong>大O用来表示上界的</strong>，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。</p>
<p>同样算法导论给出了例子：拿插入排序来说，插入排序的时间复杂度我们都说是O(n^2) 。</p>
<p>输入数据的形式对程序运算时间是有很大影响的，在数据本来有序的情况下时间复杂度是O(n)，但如果数据是逆序的话，插入排序的时间复杂度就是O(n<sup>2)，也就对于所有输入情况来说，最坏是O(n</sup>2) 的时间复杂度，所以称插入排序的时间复杂度为O(n^2)。</p>
<p>同样的同理再看一下快速排序，都知道快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，<strong>所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)</strong>。</p>
<p><strong>但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界</strong>。如图所示：<br>
<img src="https://s2.loli.net/2023/07/19/HsbCE5wfolQtXMG.png" alt=""></p>
<p>我们主要关心的还是一般情况下的数据形式。</p>
<p><strong>面试中说道算法的时间复杂度是多少指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p>
<h3 id="不同数据规模的差异">不同数据规模的差异</h3>
<p>如下图中可以看出不同算法的时间复杂度在不同数据输入规模下的差异。</p>
<p><img src="https://s2.loli.net/2023/07/19/e9n3dqxmjJMt2U8.png" alt=""></p>
<p>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）。</p>
<p>就像上图中 O(5n^2) 和 O(100n) 在n为20之前 很明显 O(5n^2)是更优的，所花费的时间也是最少的。</p>
<p>那为什么在计算时间复杂度的时候要忽略常数项系数呢，也就说O(100n) 就是O(n)的时间复杂度，O(5n^2) 就是O(n^2)的时间复杂度，而且要默认O(n) 优于O(n^2) 呢 ？</p>
<p>这里就又涉及到大O的定义，<strong>因为大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong>。</p>
<p>例如上图中20就是那个点，n只要大于20 常数项系数已经不起决定性作用了。</p>
<p><strong>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt;  O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
<p>但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了。</p>
<h3 id="复杂表达式的化简">复杂表达式的化简</h3>
<p>有时候我们去计算时间复杂度的时候发现不是一个简单的O(n) 或者O(n^2)， 而是一个复杂的表达式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(2*n^2 + 10*n + 1000)</span><br></pre></td></tr></table></figure>
<p>那这里如何描述这个算法的时间复杂度呢，一种方法就是简化法。</p>
<p>去掉运行时间中的加法常数项 （因为常数项并不会因为n的增大而增加计算机的操作次数）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(2*n^2 + 10*n)</span><br></pre></td></tr></table></figure>
<p>去掉常数系数（上文中已经详细讲过为什么可以去掉常数项的原因）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n^2 + n)</span><br></pre></td></tr></table></figure>
<p>只保留保留最高项，去掉数量级小一级的n （因为n^2 的数据规模远大于n），最终简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n^2)</span><br></pre></td></tr></table></figure>
<p>如果这一步理解有困难，那也可以做提取n的操作，变成O(n(n+1)) ，省略加法常数项后也就别变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n^2)</span><br></pre></td></tr></table></figure>
<p>所以最后我们说：这个算法的算法时间复杂度是O(n^2) 。</p>
<p>也可以用另一种简化的思路，其实当n大于40的时候， 这个复杂度会恒小于O(3 × n^2)，<br>
O(2 × n^2 + 10 × n + 1000) &lt; O(3 × n<sup>2)，所以说最后省略掉常数项系数最终时间复杂度也是O(n</sup>2)。</p>
<h3 id="O-logn-中的log是以什么为底？">O(logn)中的log是以什么为底？</h3>
<p>平时说这个算法的时间复杂度是logn的，那么一定是log 以2为底n的对数么？</p>
<p>其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，<strong>但我们统一说 logn，也就是忽略底数的描述</strong>。</p>
<p>为什么可以这么做呢？如下图所示：</p>
<p><img src="https://s2.loli.net/2023/07/19/9cEr5iqM2uHGS3N.png" alt=""></p>
<p>假如有两个算法的时间复杂度，分别是log以2为底n的对数和log以10为底n的对数，那么这里如果还记得高中数学的话，应该不难理解<code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code>。</p>
<p>而以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。</p>
<p>抽象一下就是在时间复杂度的计算过程中，log以i为底n的对数等于log 以j为底n的对数，所以忽略了i，直接说是logn。</p>
<p>这样就应该不难理解为什么忽略底数了。</p>
<h3 id="举一个例子">举一个例子</h3>
<p>通过这道面试题目，来分析一下时间复杂度。题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。</p>
<p>如果是暴力枚举的话，时间复杂度是多少呢，是O(n^2)么？</p>
<p>这里一些同学会忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单，除了n^2 次的遍历次数外，字符串比较依然要消耗m次操作（m也就是字母串的长度），所以时间复杂度是O(m × n × n)。</p>
<p>接下来再想一下其他解题思路。</p>
<p>先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。</p>
<p>那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。</p>
<p>之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。</p>
<p>我们对O(m × n × log n + n × m) 进行简化操作，把m × n提取出来变成 O(m × n × (logn + 1))，再省略常数项最后的时间复杂度是 O(m × n × log n)。</p>
<p>最后很明显O(m × n × logn) 要优于O(m × n × n)！</p>
<p>所以先把字符串集合排序再遍历一遍找到两个相同字符串的方法要比直接暴力枚举的方式更快。</p>
<p>这就是我们通过分析两种算法的时间复杂度得来的。</p>
<h2 id="空间复杂度分析">空间复杂度分析</h2>
<p>那么一直还没有讲空间复杂度，所以打算陆续来补上，内容不难，大家可以读一遍文章就有整体的了解了。</p>
<p>什么是空间复杂度呢？</p>
<p>是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)。</p>
<p>空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。</p>
<p>关注空间复杂度有两个常见的相关问题</p>
<ol>
<li class="lvl-3">
<p>空间复杂度是考虑程序（可执行文件）的大小么？</p>
</li>
</ol>
<p>很多同学都会混淆程序运行时内存大小和程序本身的大小。这里强调一下<strong>空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。</strong></p>
<ol start="2">
<li class="lvl-3">
<p>空间复杂度是准确算出程序运行时所占用的内存么？</p>
</li>
</ol>
<p>不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。</p>
<p>所以空间复杂度是预先大体评估程序内存使用的大小。</p>
<p>说到空间复杂度，我想同学们在OJ（online judge）上应该遇到过这种错误，就是超出内存限制，一般OJ对程序运行时的所消耗的内存都有一个限制。</p>
<p>为了避免内存超出限制，这也需要我们对算法占用多大的内存有一个大体的预估。</p>
<p>同样在工程实践中，计算机的内存空间也不是无限的，需要工程师对软件运行时所使用的内存有一个大体评估，这都需要用到算法空间复杂度的分析。</p>
<p>来看一下例子，什么时候的空间复杂度是$O(1)$呢，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。</p>
<p>什么时候的空间复杂度是O(n)？</p>
<p>当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。</p>
<p>其他的 O(n^2)， O(n^3) 我想大家应该都可以以此例举出来了，<strong>那么思考一下 什么时候空间复杂度是 O(logn)呢？</strong></p>
<p>空间复杂度是logn的情况确实有些特殊，其实是在<strong>递归的时候，会出现空间复杂度为logn的情况</strong>。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	代码随想录: <a href="https://programmercarl.com/">https://programmercarl.com/</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>C++初始化列表与赋值</title>
    <url>/archives/29ca4c7e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<ul class="lvl-0">
<li class="lvl-2">const成员的初始化只能在构造函数初始化列表中进行</li>
<li class="lvl-2">引用成员的初始化也只能在构造函数初始化列表中进行</li>
<li class="lvl-2">对象成员（对象成员所对应的类没有默认构造函数）的初始化，也只能在构造函数初始化列表中进行</li>
</ul>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a), _p(<span class="literal">nullptr</span>) &#123;     <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> *_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="类之间嵌套">类之间嵌套</h2>
<p><strong>第一种： 使用初始化列表。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal(animal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal __animal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal animal;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(animal)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span>() <span class="function">is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Animal</span> <span class="params">(<span class="type">const</span> Animal &amp;)</span> is called</span></span><br><span class="line"><span class="function"><span class="title">Dog</span><span class="params">(<span class="type">const</span> Animal &amp;animal)</span> is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">~<span class="title">Dog</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br></pre></td></tr></table></figure>
<p>依次分析从上到下：</p>
<p>main函数中<code>Animal animal;</code>调用默认构造。</p>
<p><code>Dog d(animal);</code>等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Animal __animal = animal;</span><br></pre></td></tr></table></figure>
<p>实际上就是调用了拷贝构造，因此输出了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span> (<span class="type">const</span> Animal &amp;) is called</span><br></pre></td></tr></table></figure>
<p>再然后打印Dog的构造函数里面的输出。</p>
<p>最后调用析构，程序结束。</p>
<p><strong>第二种：构造函数赋值来初始化对象。</strong></p>
<p>构造函数修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) &#123;</span><br><span class="line">    __animal = animal;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span>() <span class="function">is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">Animal &amp; <span class="keyword">operator</span></span>=(<span class="type">const</span> Animal &amp;) <span class="function">is called</span></span><br><span class="line"><span class="function"><span class="title">Dog</span><span class="params">(<span class="type">const</span> Animal &amp;animal)</span> is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">~<span class="title">Dog</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br></pre></td></tr></table></figure>
<p>于是得出：</p>
<p>当调用<code>Dog d(animal);</code>时，等价于：</p>
<p>先定义对象，再进行赋值，因此先调用了默认构造，再调用=操作符重载函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设之前已经有了animal对象</span></span><br><span class="line">Animal __animal;</span><br><span class="line">__animal = animal;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小结</p>
</blockquote>
<p>通过上述我们得出如下结论：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>类中包含其他自定义的class或者struct，采用初始化列表，实际上就是创建对象同时并初始化</strong></p>
</li>
<li class="lvl-2">
<p><strong>而采用类中赋值方式，等价于先定义对象，再进行赋值，一般会先调用默认构造，在调用=操作符重载函数。</strong></p>
</li>
</ul>
<h2 id="无默认构造函数的继承关系中">无默认构造函数的继承关系中</h2>
<p>现考虑把上述的关系改为继承，并修改Animal与Dog的构造函数，如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp; animal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp; amimal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">int</span> age) : <span class="built_in">Animal</span>(age) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述是通过初始化列表给基类带参构造传递参数，如果不通过初始化列表传递，会发生什么影响？</p>
<p>去掉初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">int</span> age)  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">error: no matching function <span class="keyword">for</span> call to ‘Animal::<span class="built_in">Animal</span>()’</span><br></pre></td></tr></table></figure>
<p>由于在Animal中没有默认构造函数，所以报错，遇到这种问题属于灾难性的，我们应该尽量避免，可以通过初始化列表给基类的构造初始化。</p>
<h2 id="类中const数据成员、引用数据成员">类中const数据成员、引用数据成员</h2>
<p>特别是引用数据成员，必须用初始化列表初始化，而不能通过赋值初始化！</p>
<p>例如：在上述的Animal中添加私有成员，并修改构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age,std::string name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;age_;</span><br><span class="line">    <span class="type">const</span> std::string name_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>报下面错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: uninitialized reference member in ‘int&amp;’</span><br></pre></td></tr></table></figure>
<p>应该改为下面：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Animal</span>(<span class="type">int</span> age, std::string name) : <span class="built_in">age_</span>(age), <span class="built_in">name_</span>(name) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>初始化列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda函数</title>
    <url>/archives/3065ab21.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>Lambda表达式是一种用于创建匿名函数的语法构造。它可以在需要函数对象的地方使用，而无需显式定义一个命名函数。</p>
</blockquote>
<p>Lambda表达式有如下优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</p>
</li>
<li class="lvl-2">
<p>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</p>
</li>
<li class="lvl-2">
<p>在需要的时间和地点实现功能闭包，使程序更灵活。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="python中的Lambda">python中的Lambda</h2>
<p>在Python中，Lambda表达式用于创建匿名函数。Lambda表达式的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>lambda</code>关键字表示Lambda表达式的开始。</p>
</li>
<li class="lvl-2">
<p><code>arguments</code>表示参数列表，可以是零个或多个参数，参数之间使用逗号分隔。</p>
</li>
<li class="lvl-2">
<p><code>expression</code>表示Lambda函数的返回值，即函数体的表达式。</p>
</li>
</ul>
<p><strong>1. 将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不带参数</span></span><br><span class="line">greeting = <span class="keyword">lambda</span>: <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(greeting())  <span class="comment"># 输出: Hello, world</span></span><br><span class="line"><span class="comment"># 带参数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 输出: 7</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了把标准库time中的函数sleep的功能屏蔽(Mock)</span></span><br><span class="line">time.sleep=<span class="keyword">lambda</span> x:<span class="literal">None</span></span><br><span class="line">time.sleep(<span class="number">3</span>) <span class="comment">#程序不会休眠3秒钟，而是什么都不做</span></span><br></pre></td></tr></table></figure>
<p>在后续代码中调用time库的sleep函数将不会执行原有的功能</p>
<p><strong>3. 将lambda函数作为参数传递给其他函数。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squared))  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>部分Python内置函数接受函数作为参数</strong>,典型的<strong>此类内置函数有</strong>这些:</p>
<p><strong>filter函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3]。</span></span><br></pre></td></tr></table></figure>
<p><strong>sorted函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(<span class="number">5</span>-x))</span><br><span class="line"><span class="comment"># 将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序</span></span><br><span class="line"><span class="comment"># 其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]</span></span><br></pre></td></tr></table></figure>
<p><strong>map函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x+<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">#将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p><strong>reduce函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> a, b: <span class="string">&#x27;&#123;&#125;, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="comment"># 将列表 [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是&#x27;1, 2, 3, 4, 5, 6, 7, 8, 9&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="排序：">排序：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">80</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">90</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">70</span>&#125;</span><br><span class="line">]</span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> student: student[<span class="string">&quot;score&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [&#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;score&#x27;: 70&#125;, &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 80&#125;, &#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;score&#x27;: 90&#125;]</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，Lambda表达式用于创建匿名函数，并在不同的上下文中使用。Lambda表达式可以在需要函数对象的地方直接使用，无需显式定义一个命名函数。</p>
<h2 id="C-中的Lambda">C++中的Lambda</h2>
<h3 id="Lambda-表达式的各个部分">Lambda 表达式的各个部分</h3>
<p>下面是作为第三个参数 <code>std::sort()</code> 传递给函数的简单 lambda：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abssort</span><span class="params">(<span class="type">float</span>* x, <span class="type">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n,</span><br><span class="line">        <span class="comment">// Lambda expression begins</span></span><br><span class="line">        [](<span class="type">float</span> a, <span class="type">float</span> b) &#123;</span><br><span class="line">            <span class="built_in">return</span> (std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b));</span><br><span class="line">        &#125; <span class="comment">// end of lambda expression</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图显示了 lambda 语法的各个部分：</p>
<p><img src="https://s2.loli.net/2023/07/12/9vK8Vp4euns2TgY.png" alt=""></p>
<ol>
<li class="lvl-3">
<p>capture 子句（在 C++ 规范中也称为 Lambda 引导。）</p>
</li>
<li class="lvl-3">
<p>参数列表（可选）。 （也称为 Lambda 声明符）</p>
</li>
<li class="lvl-3">
<p>mutable 规范（可选）。</p>
</li>
<li class="lvl-3">
<p>exception-specification（可选）。</p>
</li>
<li class="lvl-3">
<p>trailing-return-type（可选）。</p>
</li>
<li class="lvl-3">
<p>Lambda 体。</p>
</li>
</ol>
<h3 id="捕获列表">捕获列表 [ ]</h3>
<p>捕获列表是零或多个捕获符的逗号分隔符列表，可选地以默认捕获符开始（仅有的默认捕获符是 &amp; 和 = ）。默认情况下，从lambda生成的类都包含一个对应该lambda所捕获变量的数据成员。类似任何普通类地数据成员，lambda的数据成员也在lambda对象创建时被初始化。类似参数传递，变量的捕获方式也可以是值或引用。</p>
<p><strong>值捕获：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;<span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">//将i拷贝到明位f的可调用对象</span></span><br><span class="line">	<span class="keyword">auto</span> f = [i] &#123; <span class="keyword">return</span> i; &#125;;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">f</span>(); <span class="comment">//j=100,因为i是创建时拷贝的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用捕获：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">100</span>;<span class="comment">//局部变量</span></span><br><span class="line">	<span class="comment">//对象f包含i的引用</span></span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;i] &#123; <span class="keyword">return</span> i; &#125;;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">f</span>(); <span class="comment">//j=0,传递的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了自己列出捕获列表的变量，还可以让编译器根据lambda中代码来推断我们要使用哪些变量（<strong>隐式捕获</strong>），用过使用&amp;或=指示编译器推断捕获列表。&amp;则采用引用捕获的方式，=则采用值捕获的方式。混合使用隐式捕获和显示捕获，则两者须使用不同的方式，一个为引用捕获，一个为值捕获。</p>
<p><strong>lambda捕获列表：</strong></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>[ ]。空捕获列表，lambda不能使用所在函数中的变量。</p>
</li>
<li class="lvl-2">
<p>[=]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</p>
</li>
<li class="lvl-2">
<p>[&amp;]。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</p>
</li>
<li class="lvl-2">
<p>[this]。函数体内可以使用Lambda所在类中的成员变量。</p>
</li>
<li class="lvl-2">
<p>[a]。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</p>
</li>
<li class="lvl-2">
<p>[&amp;a]。将a按引用进行传递。</p>
</li>
<li class="lvl-2">
<p>[=，&amp;a, &amp;b]。除a和b按引用进行传递外，其他参数都按值进行传递。</p>
</li>
<li class="lvl-2">
<p>[&amp;, a, b]。除a和b按值进行传递外，其他参数都按引用进行传递。</p>
</li>
</ul>
</blockquote>
<p><strong>悬垂引用：</strong></p>
<p>若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++ 的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。</p>
<h3 id="形参列表">形参列表 ( )</h3>
<p>lambda形参列表和一般的函数形参列表类似，但不允许默认实参(C<ins>14 前)。当以 auto 为形参类型时，该 lambda 为泛型 lambda(C</ins>14 起)。与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span></span><br><span class="line">	<span class="keyword">auto</span> f = [i, &amp;j]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">		i = <span class="number">100</span>, j = <span class="number">100</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">f</span>();</span><br><span class="line">	<span class="comment">//输出:0 100</span></span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="说明符">说明符</h3>
<p>允许以下说明符：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>mutable：允许 函数体修改各个复制捕获的对象，以及调用其非 const 成员函数；</p>
</li>
<li class="lvl-2">
<p>constexpr：显式指定函数调用运算符为 constexpr 函数。此说明符不存在时，若函数调用运算符恰好满足针对 constexpr 函数的所有要求，则它也会是 constexpr； (C++17 起)</p>
</li>
<li class="lvl-2">
<p>consteval：指定函数调用运算符为立即函数。不能同时使用 consteval 和 constexpr。(C++20 起)</p>
</li>
</ul>
</blockquote>
<p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。假如我们希望能改变一个被捕获的变量的值，就必须在参数列表后面加上关键字mutable。而一个引用捕获的变量则不受此限制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//加上mutable才可以在lambda函数中改变捕获的变量值</span></span><br><span class="line">	<span class="keyword">auto</span> f = [i, &amp;j]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">		i = <span class="number">100</span>, j = <span class="number">100</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">f</span>();</span><br><span class="line">	<span class="comment">//输出:0 100</span></span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回类型">返回类型 -&gt;</h3>
<p>当我们需要为一个lambda定义返回类型时，需要使用尾置返回类型。返回类型若缺省，则根据函数体中的 return 语句进行推断（如果有多条return语句，需要保证类型一直，否则编译器无法自动推断）。默认情况下，如果一个lambda函数体不包含return语句，则编译器假定返回void。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> f = []() -&gt;<span class="type">double</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="number">2.0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不显示指定返回类型，则int和double两种返回类型会导致推断冲突。</p>
<p><img src="https://s2.loli.net/2023/07/12/LB7RPprWyMbjYH3.png" alt=""></p>
<h3 id="函数体">函数体 { }</h3>
<p>略，同普通函数的函数体。</p>
<h3 id="综合示例">综合示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [introducer](optional)mutable throwSpec-&gt;retType &#123;&#125;</span></span><br><span class="line"><span class="comment">// mutable决定[]能够被改写  mutable throwSpec retType都是选择的,只要有一个存在就得写()</span></span><br><span class="line"><span class="comment">// retType 返回类型</span></span><br><span class="line"><span class="comment">// ()放参数</span></span><br><span class="line"><span class="comment">// []放外面变量 passed by value or reference</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnNamedLocalFunction</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> localVar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnNamedLocalFunction</span>(<span class="type">int</span> var) : <span class="built_in">localVar</span>(var) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val == localVar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string firstname;</span><br><span class="line">    string lastname;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LambdaFunctor</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_a &lt; n &amp;&amp; n &lt; m_b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> __x, __y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> x, <span class="type">int</span> y) : __x(x), __y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下列 lambda 的语境是成员函数 X::f</span></span><br><span class="line">        <span class="comment">// 对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针</span></span><br><span class="line">        <span class="keyword">return</span> [&amp;]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">operator</span>()(<span class="keyword">this</span>-&gt;__x + __y); <span class="comment">// X::operator()(this-&gt;x + (*this).y)</span></span><br><span class="line">            <span class="comment">// 拥有类型 X*</span></span><br><span class="line">        &#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__x;</span><br><span class="line">        &#125;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    [] &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> I = [] &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">I</span>();</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先看前面的id 如果没有mutable error: increment of read-only variable ‘id’</span></span><br><span class="line">    <span class="keyword">auto</span> f = [id]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        ++id;</span><br><span class="line">    &#125;;</span><br><span class="line">    id = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">f</span>();    <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">f</span>();    <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f</span>();    <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述lambda就相当于</span></span><br><span class="line"><span class="comment">//    class Functor &#123;</span></span><br><span class="line"><span class="comment">//    private:</span></span><br><span class="line"><span class="comment">//        int id;</span></span><br><span class="line"><span class="comment">//    public:</span></span><br><span class="line"><span class="comment">//        void operator() &#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; &quot;id=&quot; &lt;&lt; id &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//            ++id;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line"><span class="comment">//    Functor f;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 加不加mutable没影响,且传引用只要后面id1被修改了,就会使用修改后的值进行操作</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = [&amp;id1]() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        ++id1;</span><br><span class="line">    &#125;;</span><br><span class="line">    id1 = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">f1</span>();    <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">f1</span>();    <span class="comment">// 43</span></span><br><span class="line">    <span class="built_in">f1</span>();    <span class="comment">// 44</span></span><br><span class="line">    cout &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传参与返回</span></span><br><span class="line">    <span class="type">int</span> id2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;id2](<span class="type">int</span> &amp;param) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        ++id2;</span><br><span class="line">        ++param;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> id2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> param = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f2</span>(param);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [=] =表示默认以by value传递外部所有变量</span></span><br><span class="line">    <span class="comment">// [&amp;] &amp;表示默认以by reference传递外部所有变量</span></span><br><span class="line">    <span class="keyword">auto</span> f3 = [&amp;]() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一部分传引用,其余传值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f4 = [=, &amp;id]() &#123;       <span class="comment">// =不可以放在&amp;id后面</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        id++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一部分传值,其余传引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f5 = [&amp;, id]() &#123;       <span class="comment">// &amp;不可以放在id后面</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1=&quot;</span> &lt;&lt; id1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id2=&quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param=&quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f5</span>();</span><br><span class="line">    <span class="comment">// this 指针</span></span><br><span class="line">    <span class="function">X <span class="title">x_</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x_.f()=&quot;</span> &lt;&lt; x_.<span class="built_in">f</span>() &lt;&lt; endl;   <span class="comment">// 1+2=3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x_.ff()=&quot;</span> &lt;&lt; x_.<span class="built_in">ff</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面lambda函数等价于上述的UnNamedLocalFunction</span></span><br><span class="line">    <span class="type">int</span> tobefound = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [tobefound](<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">return</span> val == tobefound;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">bool</span> b1 = <span class="built_in">lambda1</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function">UnNamedLocalFunction <span class="title">lambda2</span><span class="params">(tobefound)</span></span>;</span><br><span class="line">    <span class="type">bool</span> b2 = <span class="built_in">lambda2</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; b1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ll1 = [](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// lambda 匿名函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span> x)&gt; ll = [](<span class="type">int</span> x) -&gt; <span class="type">float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">10.0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">ll</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decltype+lambda</span></span><br><span class="line">    <span class="comment">// 比大小</span></span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">const</span> Person&amp;p1,<span class="type">const</span> Person&amp;p2)&gt; cmp = [](<span class="type">const</span> Person &amp;p1, <span class="type">const</span> Person &amp;p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.lastname &lt; p2.lastname;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于lambda,我们往往只有object,很少有人能够写出它的类型，而有时就需要知道它的类型,要获得其type,就要借助其decltype</span></span><br><span class="line">    <span class="function">set&lt;Person, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">col</span><span class="params">(cmp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要申明lambda对象的类型，可以使用template或者auto进行自动推导。</span></span><br><span class="line">    <span class="comment">// 如果需要知道类型，可以使用decltype，比如，让lambda函数作为关联容器或者无序容器的排序函数或者哈希函数。</span></span><br><span class="line">    <span class="comment">// 上面代码给出了事例（decltype的第三种用法中的事例），定义了一个lambda函数用cmp表示，用来比较Person对象的大小，传入到Set容器中去，</span></span><br><span class="line">    <span class="comment">// 但根据右边的set容器的定义，我们传入的不仅是cmp（构造函数），还要传入模板的cmp类型（Set内部需要声明cmp类型），</span></span><br><span class="line">    <span class="comment">// 所以必须使用decltype来推导出类型。</span></span><br><span class="line">    <span class="comment">// （如果没有向构造函数传入cmp，调用的是默认的构造函数，也就是set() : t(Compare()), 这里会报错, 现在不会出问题了!</span></span><br><span class="line">    <span class="comment">// 因为Compare()指的是调用默认的lambda构造函数，而lambda函数没有默认构造函数和赋值函数）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">5</span>, <span class="number">28</span>, <span class="number">50</span>, <span class="number">83</span>, <span class="number">70</span>, <span class="number">590</span>, <span class="number">245</span>, <span class="number">59</span>, <span class="number">24</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">30</span>, y = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 函数对象是很强大的，封装代码和数据来自定义标准库的行为，但需要写出函数对象需要写出整个class，这是不方便的，而且是非本地的，</span></span><br><span class="line">    <span class="comment">// 用起来也麻烦，需要去看怎样使用，另外编译出错的信息也不友好，而且它们不是inline的，效率会低一些（算法效率还是最重要的）。</span></span><br><span class="line"><span class="comment">//    vec.erase(remove_if(vec.begin(), vec.end(), LambdaFunctor(x, y)), vec.end());</span></span><br><span class="line"><span class="comment">//    for(auto i:vec) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// 而lambda函数的提出解决了这个问题，简短有效清晰，上面的事例很好的说明了这个问题，用lambda要简短许多，功能一样，很直观。</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [x, y](<span class="type">int</span> n) &#123; <span class="keyword">return</span> x &lt; n &amp;&amp; n &lt; y; &#125;), vec.<span class="built_in">end</span>());</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ Lambda表达式的基本使用: <a href="https://blog.csdn.net/gongjianbo1992/article/details/105128849">https://blog.csdn.net/gongjianbo1992/article/details/105128849</a></p>
<p>[2]	python中的lambda函数用法: <a href="https://zhuanlan.zhihu.com/p/58579207">https://zhuanlan.zhihu.com/p/58579207</a></p>
<p>[3]	C++ 那些事: <a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>C++左值与右值</title>
    <url>/archives/8502303e.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="左值、右值">左值、右值</h2>
<p>C++ 11对C++ 98中的右值进行了扩充。在<strong>C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）</strong>。</p>
<p>左值是指可以出现在赋值操作符（=）的左边的表达式，它们具有持久的内存地址。左值可以被取地址（&amp;）操作符获取其内存地址，可以被修改，也可以作为参数传递给函数。</p>
<p>纯右值是指生成临时对象或字面量的表达式，它们通常是即将被使用的临时值。纯右值没有持久的内存地址，不能被取地址（&amp;）操作符获取其内存地址。例如，<code>int result = 2 + 3;</code> 中的 <code>2 + 3</code> 就是一个纯右值。</p>
<span id="more"></span>
<p>将亡值是指具有资源所有权的表达式，它们可以被移动（move）而不是复制（copy）。将亡值是一种特殊的右值引用，可以延长右值的生命周期，用于实现移动语义。通过将资源所有权转移给新对象，可以避免不必要的复制操作，提高了效率。例如，<code>std::vector&lt;int&gt; v1; std::vector&lt;int&gt; v2 = std::move(v1);</code> 中的 <code>std::move(v1)</code> 就是一个将亡值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;          <span class="comment">// a 是左值</span></span><br><span class="line">    <span class="type">int</span>&amp; b = a;          <span class="comment">// b 是左值引用</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; c = std::<span class="built_in">move</span>(a); <span class="comment">// c 是右值引用，将亡值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(a);              <span class="comment">// 调用 foo(int&amp; x)，因为 a 是左值</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>);             <span class="comment">// 调用 foo(int&amp;&amp; x)，因为 42 是纯右值</span></span><br><span class="line">    <span class="built_in">foo</span>(std::<span class="built_in">move</span>(a));   <span class="comment">// 调用 foo(int&amp;&amp; x)，因为 std::move(a) 是将亡值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bar</span>(a);              <span class="comment">// 完美转发，调用 foo(int&amp; x)</span></span><br><span class="line">    <span class="built_in">bar</span>(<span class="number">42</span>);             <span class="comment">// 完美转发，调用 foo(int&amp;&amp; x)</span></span><br><span class="line">    <span class="built_in">bar</span>(std::<span class="built_in">move</span>(a));   <span class="comment">// 完美转发，调用 foo(int&amp;&amp; x)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左值引用、右值引用">左值引用、右值引用</h2>
<p>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，<strong>由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在</strong>。</p>
<p><strong>右值引用和左值引用都是属于引用类型，并且都是左值</strong>。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p>
<p>左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = <span class="number">2</span>;       # 左值引用绑定到右值，编译失败</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;        # 非常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="number">2</span>;  # 常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b =<span class="number">2</span>;  # 常量左值引用绑定到右值，编程通过</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line"><span class="type">int</span> &amp;&amp;r2 = std::<span class="built_in">move</span>(a);  # 编译通过</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。<br>
<img src="https://img-blog.csdnimg.cn/d0517035f9af48be86bd99df75b5669e.png" alt=""></p>
<h2 id="std-move">std::move()</h2>
<p><strong>move作用是可以将一个左值转换成右值引用</strong>，从而可以调用C++11的拷贝构造函数。</p>
<h3 id="std-move-的实现">std::move()的实现</h3>
<p>std::move的实现主要依赖于static_cast&lt;T&amp;&amp; &gt;，但同时也会做一些参数推导（traits）的工作。其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>对于t为右值的情况，有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">move</span>(<span class="built_in">string</span>(<span class="string">&quot;dengwen&quot;</span>));</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>首先模板类型推导确定T的类型为string，得remove_reference::type为string，故返回值和static的模板参数类型都为string &amp;&amp;，而move的参数就是string &amp;&amp;,于是不需要进行类型转换直接返回。</p>
<p>对于t为左值的情况，引入一条规则：<strong>当将一个左值传递给一个参数是右值引用的函数，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断模板参数类型为实参的左值引用</strong>。有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;dengwen&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">move</span>(str);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>此时明显str是一个左值，首先模板类型推导确定T的类型为string &amp;，得remove_reference::type为string。故返回值和static的模板参数类型都为string &amp;&amp;，而move的参数类型为string&amp; &amp;&amp;，折叠后为sting &amp;。</p>
<p>所以结果就为将string &amp;通过static_cast转为string &amp;&amp;。返回string &amp;&amp;。</p>
<h2 id="引用折叠">引用折叠</h2>
<p>1.所有右值引用折叠到右值引用上仍然是一个右值引用。（<code>A&amp;&amp; &amp;&amp;</code> 变成 <code>A&amp;&amp;</code>）<br>
2.所有的其他引用类型之间的折叠都将变成左值引用。 （<code>A&amp; &amp;</code> 变成 <code>A&amp;</code>; <code>A&amp; &amp;&amp;</code> 变成 <code>A&amp;</code>; <code>A&amp;&amp; &amp;</code> 变成 <code>A&amp;</code>）</p>
<h2 id="完美转发">完美转发</h2>
<p>考虑下面例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">relay</span>(<span class="built_in">Test</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>在这个例子当中，我们的期待是，我们在main当中调用relay，Test的临时对象作为一个右值传入relay，在relay当中又被转发给了func，那这时候转发给func的参数t也应当是一个右值。也就是说，我们希望：<strong>当relay的参数是右值的时候，func的参数也是右值；当relay的参数是左值的时候，func的参数也是左值</strong>。</p>
<p>那么现在我们来运行一下这个程序，我们会看到，结果与我们预想的似乎并不相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>我们看到，在relay当中转发的时候，调用了复制构造函数，也就是说<strong>编译器认为这个参数t并不是一个右值，而是左值，因为它有一个名字</strong>。那么如果我们想要实现我们所说的，如果传进来的参数是一个左值，则将它作为左值转发给下一个函数；如果它是右值，则将其作为右值转发给下一个函数，我们应该怎么做呢？</p>
<p>这时，我们需要<code>std::forward&lt;T&gt;()</code>。<strong>与std::move()相区别的是，move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左右值类型</strong>。所以我们的代码应该是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">relay</span>(<span class="built_in">Test</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>现在运行的结果就成为了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">in relay</span><br><span class="line">move constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>而如果我们的调用方法变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">relay</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>那么输出就会变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>完美地实现了我们所要的转发效果。</p>
<h2 id="forward-的实现">forward()的实现</h2>
<p>std::forward()提供两个重载版本， 一个针对左值， 一个针对右值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line"><span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>根据以下实例进行分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; fparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::forward&lt;T&gt;(fparam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">foo</span>(i);</span><br><span class="line"><span class="built_in">foo</span>(<span class="number">47</span>);</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>在foo(i)， 如果传入的是一个左值， 那么foo中T的类型将是int&amp;, fparam类型是int&amp; &amp;&amp;, 经过折叠为int&amp;. 因此在std::forward模板函数中，推断出T的类型为int&amp;,因此，std::remove_reference用int&amp; 进行实例化。std::remove_reference的type成员是int。forward返回类型为int&amp; &amp;&amp;, 折叠为int&amp;。forward的参数类型__t为int&amp;。static_cast&lt;int &amp; &amp;&amp;&gt; 折叠为static_cast&lt;int &amp;&gt;。</p>
<p>因此std::forward最终被实例化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;<span class="type">__t</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&gt;(<span class="type">__t</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>可以发现，函数什么都不用做， 最终的传入forward的左值引用被保留了。</p>
<p>在foo(47)中， 传入的是一个右值，那么foo中T的类型将是int, fparam类型是T&amp;&amp;, 因此，在std::forward模板函数中推断出T的类型为int。因此， std::remove_reference用int 进行实例化。std::remove_reference的type成员是int。forward返回类型为int&amp;&amp;。forward的参数类型__t为int&amp;&amp;。static_cast&lt;int &amp;&amp; &amp;&amp;&gt; 折叠为static_cast&lt;int &amp;&amp;&gt;<br>
因此std::forward最终被实例化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;&amp;<span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;<span class="type">__t</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(<span class="type">__t</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>可以发现，函数什么都不用做， 最终的传入forward的右值引用被保留了。</p>
<p>通过以上分析， 实际上无论传递左值还是右值， forward都可以完美转发， 并且函数内部什么都不用做。</p>
<h2 id="函数返回值是左值还是右值">函数返回值是左值还是右值</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果函数返回值是引用类型，则为左值。</p>
</li>
<li class="lvl-2">
<p>如果函数返回值是值类型，则为右值。</p>
</li>
</ul>
<h2 id="如何判断一个值是左值还是右值">如何判断一个值是左值还是右值</h2>
<p>右值是能够赋值给左值，但是左值不能赋值给右值。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 左值和右值: <a href="https://blog.csdn.net/TABE_/article/details/122609775">https://blog.csdn.net/TABE_/article/details/122609775</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>左值与右值</tag>
      </tags>
  </entry>
  <entry>
    <title>RE（正则表达式）</title>
    <url>/archives/c7331187.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h1>RE（正则表达式）</h1>
<p>正则表达式（Regular Expression，简称为 “regex”）是一种用于处理字符串的强大工具，可以用来匹配、查找、替换和分割文本。在编程中，正则表达式广泛应用于文本处理和数据提取等场景。</p>
<p>通过在线工具（如 <a href="https://regex101.com/">regex101 ↗</a>）可以方便地测试和调试正则表达式。</p>
<span id="more"></span>
<h2 id="1-基本匹配">1. 基本匹配</h2>
<p>正则表达式是由字符和元字符组成的模式，用于描述字符串的一部分。字符就是普通的文本字符，例如 <code>a</code>、<code>b</code>、<code>1</code> 等；元字符具有特殊含义，用于表示某种模式。</p>
<h3 id="1-1-字符匹配">1.1 字符匹配</h3>
<p>在正则表达式中，大多数字符都与自身相匹配。例如，正则表达式 <code>abc</code> 匹配字符串 <code>&quot;abc&quot;</code>。</p>
<h3 id="1-2-元字符">1.2 元字符</h3>
<p>以下字符具有特殊含义，被称为元字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. ^ $ * + ? &#123; &#125; [ ] \ | ( )</span><br></pre></td></tr></table></figure>
<p>要在正则表达式中匹配这些字符本身，需要在它们前面加上反斜线 <code>\</code>。</p>
<h2 id="2-字符类">2. 字符类</h2>
<p>字符类允许我们匹配一组字符中的任意一个。它由一对方括号 <code>[</code> 和 <code>]</code> 包围，其中包含要匹配的字符。</p>
<p>例如，正则表达式 <code>[abc]</code> 匹配字符 <code>a</code>、<code>b</code> 或 <code>c</code>。</p>
<h3 id="2-1-范围">2.1 范围</h3>
<p>在字符类中，可以使用短横线 <code>-</code> 表示字符范围。例如，<code>[a-z]</code> 匹配任意小写字母；<code>[0-9]</code> 匹配任意数字。</p>
<h3 id="2-2-预定义字符类">2.2 预定义字符类</h3>
<p>正则表达式提供了一些预定义的字符类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>\d</code>：等价于 <code>[0-9]</code>，匹配任意数字。</p>
</li>
<li class="lvl-2">
<p><code>\D</code>：等价于 <code>[^0-9]</code>，匹配任意非数字字符。</p>
</li>
<li class="lvl-2">
<p><code>\w</code>：等价于 <code>[a-zA-Z0-9_]</code>，匹配任意字母、数字或下划线。</p>
</li>
<li class="lvl-2">
<p><code>\W</code>：等价于 <code>[^a-zA-Z0-9_]</code>，匹配任意非字母、数字或下划线的字符。</p>
</li>
<li class="lvl-2">
<p><code>\s</code>：匹配任意空白字符，如空格、制表符和换行符。</p>
</li>
<li class="lvl-2">
<p><code>\S</code>：匹配任意非空白字符。</p>
</li>
</ul>
<h2 id="3-量词">3. 量词</h2>
<p>量词指定一个模式出现的次数。常用的量词有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>*</code>：匹配前面的模式 0 次或多次。</p>
</li>
<li class="lvl-2">
<p><code>+</code>：匹配前面的模式 1 次或多次。</p>
</li>
<li class="lvl-2">
<p><code>?</code>：匹配前面的模式 0 次或 1 次。</p>
</li>
<li class="lvl-2">
<p><code>&#123;n&#125;</code>：匹配前面的模式正好 n 次。</p>
</li>
<li class="lvl-2">
<p><code>&#123;n,&#125;</code>：匹配前面的模式至少 n 次。</p>
</li>
<li class="lvl-2">
<p><code>&#123;n,m&#125;</code>：匹配前面的模式至少 n 次，最多 m 次。</p>
</li>
</ul>
<h2 id="4-分组和捕获">4. 分组和捕获</h2>
<p>使用圆括号 <code>(</code> 和 <code>)</code> 可以将多个字符组合成一个分组。例如，正则表达式 <code>(ab)+</code> 匹配字符串 <code>&quot;ab&quot;</code> 重复出现的部分，如 <code>&quot;ab&quot;</code>、<code>&quot;abab&quot;</code> 等。</p>
<p>分组还具有捕获功能，可以在匹配成功后提取分组中的内容。捕获的顺序是从左到右，按照左括号的顺序编号。</p>
<h2 id="5-断言">5. 断言</h2>
<p>断言用于判断字符串的当前位置是否满足某个条件，但不消耗字符。常用的断言有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>^</code>：匹配字符串的开始位置。</p>
</li>
<li class="lvl-2">
<p><code>$</code>：匹配字符串的结束位置。</p>
</li>
<li class="lvl-2">
<p><code>\b</code>：匹配单词的边界（即单词与空白字符之间的位置）。</p>
</li>
<li class="lvl-2">
<p><code>\B</code>：匹配非单词边界的位置。</p>
</li>
<li class="lvl-2">
<p><code>(?=...)</code>：正向先行断言，要求接下来的字符满足指定的模式，但不消耗字符。</p>
</li>
<li class="lvl-2">
<p><code>(?!...)</code>：负向先行断言，要求接下来的字符不满足指定的模式，但不消耗字符。</p>
</li>
</ul>
<h2 id="6-使用正则表达式的语言功能">6. 使用正则表达式的语言功能</h2>
<p>大多数编程语言都内置了对正则表达式的支持。以下是一些常见编程语言中使用正则表达式的示例：</p>
<h3 id="6-1-C">6.1 C++</h3>
<p>在 C++ 中，可以使用 <code>&lt;regex&gt;</code> 头文件中的正则表达式库来处理正则表达式。以下是一些常见的正则表达式库函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>std::regex_search(str, pattern)</code>：在字符串中查找指定模式的第一个匹配项。</p>
</li>
<li class="lvl-2">
<p><code>std::regex_match(str, pattern)</code>：检查字符串是否与指定模式完全匹配。</p>
</li>
<li class="lvl-2">
<p><code>std::regex_replace(str, pattern, newStr)</code>：将字符串中与指定模式匹配的项替换为指定的字符串。</p>
</li>
<li class="lvl-2">
<p><code>std::regex_iterator</code>：用于迭代查找字符串中所有与指定模式匹配的项。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\d+&quot;</span>)</span></span>; <span class="comment">// 创建一个匹配数字的正则表达式模式</span></span><br><span class="line">  std::string str = <span class="string">&quot;Found 42 items, each costs $15&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找第一个匹配项</span></span><br><span class="line">  std::smatch match;</span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(str, match, pattern)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First match: &quot;</span> &lt;&lt; match[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否完全匹配</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(str, pattern)) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Matched completely\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找所有匹配项</span></span><br><span class="line">  <span class="function">std::sregex_iterator <span class="title">it</span><span class="params">(str.begin(), str.end(), pattern)</span></span>;</span><br><span class="line">  std::sregex_iterator end;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;All matches: &quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (it != end) &#123;</span><br><span class="line">    std::cout &lt;&lt; (*it)[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++it;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换匹配项</span></span><br><span class="line">  std::string newStr = std::<span class="built_in">regex_replace</span>(str, pattern, <span class="string">&quot;NUMBER&quot;</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;New string: &quot;</span> &lt;&lt; newStr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-Python">6.2 Python</h3>
<p>在 Python 中，可以使用 <code>re</code> 模块处理正则表达式。以下是一些常见的 <code>re</code> 模块函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>re.search(pattern, string)</code>：在字符串中查找指定模式的第一个匹配项。</p>
</li>
<li class="lvl-2">
<p><code>re.findall(pattern, string)</code>：返回字符串中所有与指定模式匹配的项的列表。</p>
</li>
<li class="lvl-2">
<p><code>re.sub(pattern, repl, string, count=0)</code>：将字符串中与指定模式匹配的项替换为指定的字符串，可限制替换次数。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&#x27;\d+&#x27;</span></span><br><span class="line">string = <span class="string">&#x27;Found 42 items, each costs $15&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找第一个匹配项</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())  <span class="comment"># 输出：42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找所有匹配项</span></span><br><span class="line">numbers = re.findall(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># 输出：[&#x27;42&#x27;, &#x27;15&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换匹配项</span></span><br><span class="line">new_string = re.sub(pattern, <span class="string">&#x27;NUMBER&#x27;</span>, string)</span><br><span class="line"><span class="built_in">print</span>(new_string)  <span class="comment"># 输出：Found NUMBER items, each costs $NUMBER</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-JavaScript">6.3 JavaScript</h3>
<p>在 JavaScript 中，正则表达式可以使用 <code>RegExp</code> 对象表示。以下是一些常见的正则表达式方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>regex.test(string)</code>：测试字符串是否包含与正则表达式匹配的部分。</p>
</li>
<li class="lvl-2">
<p><code>regex.exec(string)</code>：在字符串中查找与正则表达式匹配的部分，返回一个匹配对象或 <code>null</code>。</p>
</li>
<li class="lvl-2">
<p><code>string.match(regex)</code>：返回一个数组，其中包含字符串中与正则表达式匹配的所有部分。</p>
</li>
<li class="lvl-2">
<p><code>string.replace(regex, replacement)</code>：将字符串中与正则表达式匹配的部分替换为指定的字符串。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/\d+/</span>;</span><br><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;Found 42 items, each costs $15&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试是否匹配</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">test</span>(string));  <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找第一个匹配项</span></span><br><span class="line"><span class="keyword">const</span> match = pattern.<span class="title function_">exec</span>(string);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>]);  <span class="comment">// 输出：42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找所有匹配项</span></span><br><span class="line"><span class="keyword">const</span> numbers = string.<span class="title function_">match</span>(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers);  <span class="comment">// 输出：[ &#x27;42&#x27;, &#x27;15&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换匹配项</span></span><br><span class="line"><span class="keyword">const</span> newString = string.<span class="title function_">replace</span>(pattern, <span class="string">&#x27;NUMBER&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newString);  <span class="comment">// 输出：Found NUMBER items, each costs $15</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>正则表达式</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客</title>
    <url>/archives/ec7d7221.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="安装">安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>配置安装 <a href="https://liuaoao.top/archives/938d5a31.html">Git及NodeJS</a></p>
</li>
<li class="lvl-2">
<p>创建GitHub仓库（<strong>注意仓库的取名格式：<a href="http://xn--eqr924avxo.github.io">用户名.github.io</a>（这将是以后的访问域名）</strong>)</p>
</li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">
<p>安装Hexo</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Hexo</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init hexo</span><br><span class="line">cd hexo</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br><span class="line"><span class="section"># Next theme</span></span><br><span class="line">cd hexo</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div class="note info">
            <p>转移至新设备：</p><ol><li class="lvl-3">打包Blog文件夹到新设备</li><li class="lvl-3">配置 <a href="https://liuaoao.top/archives/938d5a31.html">Git及NodeJS</a></li><li class="lvl-3"><code>npm install hexo-cli -g</code></li></ol>
          </div>
<h2 id="新建文章">新建文章</h2>
<ol>
<li class="lvl-3">
<p><strong>创建文章：</strong><br>
使用 Hexo 命令 <code>hexo new [layout] &lt;title&gt;</code> 可以新建一篇文章。</p>
<ul class="lvl-2">
<li class="lvl-5"><code>layout</code> 是文章的布局，默认为 <code>post</code>，通常可以省略。</li>
<li class="lvl-5"><code>title</code> 是文章的标题，同时也是文件的名称，文章文件将会保存在 <code>source/_posts</code> 目录下。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;如何在hexo上创建一篇文章&quot;</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在 <code>source/_posts</code> 目录下生成一个名为 “<a href="http://xn--hexo-o84f4by7lp0il6m70fipr9qs4n7dmwc.md">如何在hexo上创建一篇文章.md</a>” 的 Markdown 文件。</p>
</li>
<li class="lvl-3">
<p><strong>编辑 Front-matter：</strong><br>
Front-matter 是位于文章最上方，用 <code>---</code> 分隔的区域。它用于指定文章的变量设置。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">如何在hexo上创建一篇文章</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-09-16 19:33:46</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>可以在 Front-matter 中设置其他变量如 <code>categories</code> 和 <code>tags</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">博客</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">创建文章</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>编写内容：</strong><br>
在 Front-matter 设置好后，你可以继续编写文章的内容。如果文章较长，可以在文章中间插入 <code>&lt;!-- more --&gt;</code>，这样可以在首页显示部分内容，并添加一个 “阅读更多” 的提示。</p>
</li>
<li class="lvl-3">
<p><strong>发布文章：</strong><br>
写完文章后，运行以下命令生成和部署网站：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>版权声明：</strong><br>
文章末尾通常可以附上版权声明，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line"></span><br><span class="line">原文链接：https://liuaoao.top/archives/ec7d7221.html</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Next主题博客个性化">Next主题博客个性化</h2>
<p><strong><code>主题配置文件</code><strong>和</strong><code>站点配置文件</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/hexo/_config.yml</span><br><span class="line">/hexo/themes/next/_config.yml</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p><code>hexo\source</code>新建 <code>\_data</code>文件夹</p>
</li>
<li class="lvl-3">
<p>复制<code>\hexo\themes\next\_config.yml</code> 到<code>\_data</code>文件夹并重命名为 <code>next.yml</code></p>
</li>
<li class="lvl-3">
<p>个性化配置+域名设置文件开箱即用：</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1FS_w7nfsuilyRjwAFKV2WA">https://pan.baidu.com/s/1FS_w7nfsuilyRjwAFKV2WA</a><br>
提取码：gy9r</p>
</blockquote>
</li>
</ol>
<h2 id="文章分类层级">文章分类层级</h2>
<ol>
<li class="lvl-3">
<p>分类一般用法</p>
<p>Hexo 中分类和标签有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>父子分类</p>
<p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">- Life</span><br></pre></td></tr></table></figure>
<p>会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p>
</li>
<li class="lvl-3">
<p>并列+子分类</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>
<p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。## hexo提示块</p>
</li>
</ol>
<h2 id="标签大小写">标签大小写</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br><span class="line">tags: [123, 456]</span><br></pre></td></tr></table></figure>
<p>实现上述分类，需要把<code>git config</code>忽略大小写关闭</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># E:\Work\Hexo-hexo\.deploy<span class="emphasis">_git\.git</span></span></span><br><span class="line"><span class="emphasis"><span class="section">[core]</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	repositoryformatversion = 0</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	filemode = false</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	bare = false</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	logallrefupdates = true</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	symlinks = false</span></span></span><br><span class="line"><span class="emphasis"><span class="section">-   ignorecase = true</span></span></span><br><span class="line"><span class="emphasis"><span class="section">+   ignorecase = false</span></span></span><br></pre></td></tr></table></figure>
<h2 id="提示块">提示块</h2>
<div class="note default">
            <p>default 提示块标签</p>
          </div>
<div class="note primary">
            <p>primary 提示块标签</p>
          </div>
<div class="note success">
            <p>success 提示块标签</p>
          </div>
<div class="note info">
            <p>info 提示块标签</p>
          </div>
<div class="note warning">
            <p>warning 提示块标签</p>
          </div>
<div class="note danger">
            <p>danger 提示块标签</p>
          </div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>使用方法</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选项卡">选项卡</h3>
<div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">tab 1</a></li><li class="tab"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 1</strong></p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 3</strong></p></div></div></div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>使用方法</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 1** </span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 2**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab A --&gt;</span><br><span class="line">**选项卡 3** 名字为A</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="升级Hexo及全部插件">升级Hexo及全部插件</h2>
<p>先安装 <code>npm-check</code> 和 <code>npm-upgrade</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check npm-upgrade</span><br></pre></td></tr></table></figure>
<p>安装完后，执行 <code>npm-check</code> 即可检查本地各插件版本情况。</p>
<p>执行 <code>npm-upgrade</code> 可根据当前版本和最新版本比较，让用户确认和选择是否升级。若用户确认升级，则会自动把 <code>package-lock.json</code> 和 <code>package.json</code> 文件内容进行更新后保存，然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update -g --save </span><br></pre></td></tr></table></figure>
<p>上述命令执行完毕，则所有通过 <code>npm-upgrade</code> 确认的插件全部都升级到最新（包括 Hexo）。</p>
<h2 id="Markdown语法注意">Markdown语法注意</h2>
<ul class="lvl-0">
<li class="lvl-2">


  Hexo 使用 Nunjucks 来解析文章（旧版本使用 Swig，两者语法类似），内容若包含 {{ }} 或 {% %} 可能导致解析错误，您可以用 raw 标签包裹来避免潜在问题发生。详情见[官方文档问答部分](https://hexo.io/docs/troubleshooting.html#Escape-Contents)。代码如下：

  
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">Hello &#123;% trans %&#125;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>== ** 等左侧开始侧加空格</p>
</li>
<li class="lvl-2">
<p>\转义（网址不要带最好/）</p>
</li>
<li class="lvl-2">
<p>图片不显示名称，删掉[]里的值</p>
</li>
</ul>
<h2 id="Reference">Reference</h2>
<p>[1]	超详细Hexo+Github博客搭建小白教程: <a href="https://zhuanlan.zhihu.com/p/35668237">https://zhuanlan.zhihu.com/p/35668237</a></p>
<p>[2]	hexo theme next7.8 主题美化: <a href="https://blog.csdn.net/tuckEnough/article/details/107383201">https://blog.csdn.net/tuckEnough/article/details/107383201</a></p>
<p>[3]	Github+Hexo搭建个人博客(图文详解): <a href="https://blog.csdn.net/weixin_45377770/article/details/105228938?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_45377770/article/details/105228938?spm=1001.2014.3001.5506</a></p>
<p>[4]	在hexo-NexT中插入note提示块: <a href="https://jinnsjj.github.io/uncategorized/hexo-next-note/">https://jinnsjj.github.io/uncategorized/hexo-next-note/</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类构造函数 &amp; 析构函数</title>
    <url>/archives/7b6761ef.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="类的构造函数">类的构造函数</h2>
<p>类的 <strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>(<span class="type">double</span> len);  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="type">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取默认设置的长度</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl;</span><br><span class="line">   <span class="comment">// 再次设置长度</span></span><br><span class="line">   line.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">Object is being created, length = 10</span></span><br><span class="line"><span class="comment">Length of line : 10</span></span><br><span class="line"><span class="comment">Length of line : 6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="使用初始化列表来初始化字段">使用初始化列表来初始化字段</h3>
<p>使用初始化列表来初始化字段：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len): <span class="built_in">length</span>(len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的语法等同于如下语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>( <span class="type">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C::<span class="built_in">C</span>( <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c): <span class="built_in">X</span>(a), <span class="built_in">Y</span>(b), <span class="built_in">Z</span>(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的析构函数">类的析构函数</h2>
<p>类的 <strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="type">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Line line;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置长度</span></span><br><span class="line">   line.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">Object is being created</span></span><br><span class="line"><span class="comment">Length of line : 6</span></span><br><span class="line"><span class="comment">Object is being deleted</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="调用顺序">调用顺序</h2>
<p>1、<strong>构造函数</strong>的调用顺序</p>
<p>基类构造函数、对象成员构造函数、派生类本身的构造函数</p>
<p>2、<strong>析构函数</strong>的调用顺序</p>
<p>派生类本身的析构函数、对象成员析构函数、基类析构函数（与构造顺序正好 <mark>相反</mark>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//    static B b;</span></span><br><span class="line">     B b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;D::constructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">     ~<span class="built_in">D</span>()&#123;cout&lt;&lt;<span class="string">&quot;D::deconstructor&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C* pd = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    <span class="keyword">delete</span> pd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">-----&gt;B b</span></span><br><span class="line"><span class="comment">A::constructor</span></span><br><span class="line"><span class="comment">B::constructor</span></span><br><span class="line"><span class="comment">C::constructor</span></span><br><span class="line"><span class="comment">D::constructor</span></span><br><span class="line"><span class="comment">C::deconstructor</span></span><br><span class="line"><span class="comment">B::deconstructor</span></span><br><span class="line"><span class="comment">A::deconstructor</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----&gt;static B b</span></span><br><span class="line"><span class="comment">A::constructor</span></span><br><span class="line"><span class="comment">C::constructor</span></span><br><span class="line"><span class="comment">D::constructor</span></span><br><span class="line"><span class="comment">C::deconstructor</span></span><br><span class="line"><span class="comment">A::deconstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>static B b</code>：<code>B</code>类的构造函数没有被调用的原因是因为 <code>B</code> 类对象 <code>b</code> 被声明为静态成员变量。静态成员变量在类的定义中只是声明，需要在类外部进行定义和初始化。</p>
</blockquote>
<h2 id="拷贝构造函数-赋值构造函数">拷贝构造函数 &amp; 赋值构造函数</h2>
<p>拷贝构造函数和赋值构造函数都是C++中的特殊成员函数，用于在对象之间进行数据的拷贝操作。它们的定义和功能有所不同。</p>
<ol>
<li class="lvl-3">
<p>拷贝构造函数：拷贝构造函数用于创建一个新对象，该对象与另一个已存在的同类对象具有相同的值和属性。它的定义形式为：<code> 类名(const 类名&amp; 对象名)</code>。拷贝构造函数通常用于以下情况：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过赋值或参数传递方式将一个对象的值复制给另一个对象。</p>
</li>
<li class="lvl-2">
<p>当函数返回一个对象时，会调用拷贝构造函数来生成一个临时副本。</p>
</li>
<li class="lvl-2">
<p>当对象作为参数传递给函数时，会调用拷贝构造函数来生成参数对象的副本。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        <span class="comment">// 拷贝对象的数据</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    <span class="comment">// 使用拷贝构造函数创建一个新对象obj2，它与obj1具有相同的值</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>赋值构造函数：赋值构造函数用于将一个已存在的对象的值赋给另一个已存在的对象。它的定义形式为：<code>类名&amp; operator=(const 类名&amp; 对象名)</code>。赋值构造函数通常用于以下情况：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>在一个对象已经存在的情况下，将其赋值给另一个对象。</p>
</li>
<li class="lvl-2">
<p>对象在创建后需要动态地改变其值。</p>
</li>
<li class="lvl-2">
<p>赋值构造函数实际上是对对象的状态进行了复制,它们仍然是两个独立的对象，在内存中具有不同的地址。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 赋值构造函数</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        <span class="comment">// 将对象的数据赋值给当前对象</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = obj.data;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line">    <span class="comment">// 将obj1的值赋给obj2，调用赋值构造函数</span></span><br><span class="line">    obj2 = obj1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>拷贝构造函数用于创建一个新对象，并将另一个对象的值复制给该新对象。</p>
</li>
<li class="lvl-2">
<p>赋值构造函数用于将一个已存在的对象的值赋给另一个已存在的对象。</p>
</li>
<li class="lvl-2">
<p>拷贝构造函数在对象创建、返回和参数传递时调用，赋值构造函数在对象赋值时调用。</p>
</li>
</ul>
<h2 id="Reference">Reference</h2>
<p>[1] 	C++ 类构造函数 &amp; 析构函数: <a href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">https://www.runoob.com/cplusplus/cpp-constructor-destructor.html</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>构造函数</tag>
        <tag>析构函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程</title>
    <url>/archives/9f089854.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="介绍">介绍</h2>
<blockquote>
<p><code>C++</code>多线程是指在<code>C++</code>程序中使用多个线程来实现并发执行的功能。多线程可以提高程序的性能和响应速度，同时也可以简化程序的设计和实现。</p>
<p>在<code>C++</code>中，可以使用标准库中的<code>thread</code>类来创建和管理线程。<code>thread</code>类提供了多个构造函数和成员函数，可以用于创建新线程、等待线程结束、获取线程<code>ID</code>等操作</p>
</blockquote>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;chrono&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std::chrono;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">using ull = unsigned long long;</span><br><span class="line">ull OddSum = <span class="number">0</span>;</span><br><span class="line">ull EvenSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">void findEven(ull start, ull end) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ull i = start; i &lt;= end; ++i)</span><br><span class="line">    <span class="comment">#  i 的二进制表示中最低位与 1 的按位与</span></span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            EvenSum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void findOdd(ull start, ull end) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ull i = start; i &lt;= end; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            OddSum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    ull start = <span class="number">0</span>, end = <span class="number">1900000000</span>;</span><br><span class="line"></span><br><span class="line">    auto startTime = high_resolution_clock::now();</span><br><span class="line">    findOdd(start, end);</span><br><span class="line">    findEven(start, end);</span><br><span class="line">    auto stopTime = high_resolution_clock::now();</span><br><span class="line">    auto duration = duration_cast&lt;microseconds&gt;(stopTime - startTime);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;OddSum : &quot;</span> &lt;&lt; OddSum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;EvenSum: &quot;</span> &lt;&lt; EvenSum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sec: &quot;</span> &lt;&lt; duration.count() / <span class="number">1000000</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建线程的五种类型">创建线程的五种类型</h2>
<ol>
<li class="lvl-3">
<p><strong>function_pointer</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// <span class="number">1.</span>函数指针</span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(<span class="built_in">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意：如果我们创建多线程 并不会保证哪一个先开始</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    std::thread t1(fun, <span class="number">10</span>);</span><br><span class="line">//    std::thread t2(fun, <span class="number">10</span>);</span><br><span class="line">    t1.join();</span><br><span class="line">//    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++ 中，函数名可以被视为指向函数代码的指针。在这里，<code>fun</code> 函数被用作线程的入口函数，它会在新的线程中被执行。在创建线程时，我们将 <code>fun</code> 函数的地址作为参数传递给了 <code>std::thread</code> 构造函数。</p>
</blockquote>
<ol start="2">
<li class="lvl-3">
<p><strong>lambda_function</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.函数指针</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 注意：如果我们创建多线程 并不会保证哪一个先开始</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 2.Lambda函数</span><br><span class="line">    auto fun = [](int x) &#123;</span><br><span class="line">        while (x-- &gt; 0) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">//    std::1.thread t1(fun, 10);</span><br><span class="line">    // 也可以写成下面：</span><br><span class="line">    std::thread t1_1([](int x) &#123;</span><br><span class="line">        while (x-- &gt; 0) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 11);</span><br><span class="line">//    std::1.thread t2(fun, 10);</span><br><span class="line">//    t1.join();</span><br><span class="line">    t1_1.join();</span><br><span class="line">//    t2.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p><strong>functor</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// <span class="number">3.</span>functor (Funciton Object)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    void operator()(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t(Base(), <span class="number">10</span>);</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p><strong>no_static_member_function</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// <span class="number">4.</span>Non-static member function</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    void fun(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    Base b;</span><br><span class="line">    thread t(&amp;Base::fun,&amp;b, <span class="number">10</span>);</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>函数名与函数指针的相关解释</p><p>第一种：函数名与<code>FunP</code>函数指针都是函数指针。<code>fun</code>是一个函数指针常量，<code>funP</code>是一个函数数指针变量。</p><p>虽然通过常量与变量来解释函数名无法赋值可以帮助理解，但是我们发现对<code>fun</code>赋值时编译器给的错误提示并不是说对常量进行赋值，而是告诉我们<code>=</code>号两端格式不匹配。对此，第二种理解更合理。</p><p>第二种：函数名和数组名实际上都不是指针，但是，在使用时可以退化成指针，即编译器可以帮助我们实现自动的转换。</p><p>这也可以解释为什么当我们在<code>=</code>号右侧使用函数名时，无论是取值还是取地址都没有问题，因为编译替我们做了相当于强制类型转换的工作，而在当函数名在<code>=</code>号左侧时，右侧的函数指针并没有这个功能，毕竟他们俩不是同一种结构。</p>
          </div>
<ol start="5">
<li class="lvl-3">
<p><strong>static_member_function</strong></p>
</li>
</ol>
<blockquote>
<p>非静态成员函数只能通过类的对象进行调用，因为它们需要访问对象的状态。这与静态成员函数不同，后者可以直接通过类名进行调用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// <span class="number">4.</span>static member function</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    static void fun(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t(&amp;Base::fun, <span class="number">10</span>);</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Join-与-Detachs">Join 与 Detachs</h2>
<ol>
<li class="lvl-3">
<p><strong>join</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>一旦线程开始，我们要想等待线程完成，需要在该对象上调用<code>join()</code>双重<code>join</code>将导致程序终止</p>
<blockquote>
<p>调用 <code>join()</code> 后会进入“已加入状态”，即该线程对象已经完成其任务并已经被系统回收。如果再次调用该线程对象的 join()，会导致程序崩溃。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>在join之前我们应该检查显示是否可以被<code>join</code>,通过使用<code>joinable()</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;chrono&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void run(<span class="built_in">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t1(run, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">if</span> (t1.joinable()) &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() after&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p><strong>detach</strong></p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-3">
<p>这用于从父线程分离新创建的线程</p>
</li>
<li class="lvl-3">
<p>在分离线程之前，请务必检查它是否可以<code>joinable</code>，否则可能会导致两次分离，并且双重<code>detach()</code>将导致程序终止</p>
</li>
<li class="lvl-3">
<p>如果我们有分离的线程并且main函数正在返回，那么分离的线程执行将被挂起</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;chrono&gt;</span></span><br><span class="line"><span class="comment">#include &lt;mutex&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void run(<span class="built_in">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t1(run, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    t1.detach();</span><br><span class="line">    <span class="keyword">if</span>(t1.joinable())</span><br><span class="line">        t1.detach();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main() after&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mutex-in-C-Threading">mutex in C++ Threading</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>critical_section</strong></p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>这段代码创建了两个线程<code>t1</code>和<code>t2</code>，它们都会执行<code>countgold()</code>函数，用于计算一个共享变量<code>sum</code>的值。<code>countgold()</code>函数使用了一个互斥锁来保护共享变量<code>sum</code>的访问。</p>
</li>
<li class="lvl-3">
<p><code>main()</code>函数启动了两个线程，并等待它们完成。一旦两个线程都完成了计算，程序就会输出sum的最终值。由于使用了互斥锁，程序可以保证每次只有一个线程能够修改sum变量，因此最终结果是可预测的。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;mutex&gt;</span></span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>; //shared</span><br><span class="line"></span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line">void *countgold() &#123;</span><br><span class="line">    <span class="built_in">int</span> i; //local to each thread</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        m.lock();</span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">1</span>;</span><br><span class="line">        m.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    thread t1(countgold);</span><br><span class="line">    thread t2(countgold);</span><br><span class="line"></span><br><span class="line">    //Wait <span class="keyword">for</span> both threads to finish</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; <span class="built_in">sum</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>mutex</code>提供了两个主要的操作：<code>lock()</code>和<code>unlock()</code>。在访问共享资源之前，线程需要调用<code>lock()</code>函数来获取互斥锁；在访问完成之后，线程需要调用<code>unlock()</code>函数来释放互斥锁。当一个线程已经获取了互斥锁时，其他线程将无法获取该锁，直到该线程释放了锁。这样可以保证在任何时候只有一个线程能够访问共享资源，从而避免了竞态条件的发生。</p>
</blockquote>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 那些事: <a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python优化提速</title>
    <url>/archives/d933fa60.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="前言">前言</h2>
<p><code>Python</code> 相对于其他编程语言被认为较慢，主要有以下几个原因：</p>
<ol>
<li class="lvl-3">
<p>解释型语言：<code>Python</code>是一种解释型语言，而不是编译型语言。在程序执行时，<code>Python</code>解释器会逐行解释和执行代码，这会引入一定的开销。相比之下，编译型语言如<code>C++</code>在运行之前会将代码编译成机器码，因此执行速度更快。</p>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li class="lvl-3">
<p>动态类型和动态内存管理：<code>Python</code>是一种动态类型语言，变量的类型可以在运行时动态改变。这导致在运行时需要进行类型检查和转换，增加了运行时的开销。此外，<code>Python</code>还使用了自动的内存管理机制，即垃圾回收机制，用于自动分配和释放内存。垃圾回收的开销也会影响<code>Python</code>的性能。</p>
</li>
<li class="lvl-3">
<p>全局解释锁（<code>GIL</code>）：<code>Python</code>的标准解释器（<code>CPython</code>）中存在一个全局解释锁（<code>GIL</code>），它限制了同一时间只能有一个线程执行<code>Python</code>字节码。这意味着在多线程的情况下，<code>Python</code>无法有效地利用多核处理器的优势，导致在处理计算密集型任务时性能受限。但是，值得注意的是，在<code>I/O</code>密集型任务中，由于<code>GIL</code>会在<code>I/O</code>操作时释放，因此多线程可以提高性能。</p>
</li>
<li class="lvl-3">
<p>部分库的实现方式：<code>Python</code>的一些常用库和模块使用了底层用<code>C</code>或<code>C++</code>编写的扩展模块，这些模块的性能比纯<code>Python</code>代码高。然而，并非所有的库都使用这种方式，一些纯<code>Python</code>实现的库性能可能较低。</p>
</li>
</ol>
<h2 id="常规小技巧">常规小技巧</h2>
<ol>
<li class="lvl-3">
<p><strong>列表推导（List Comprehension）</strong>：使用列表推导可以将<code>for</code>循环转化为更高效的单行表达式。它可以通过在一个列表中使用<code>for</code>循环来创建另一个列表。列表推导通常比显式的<code>for</code>循环更快，因为它利用了底层的优化机制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> numbers]</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>map()</strong> 函数：使用<code>map()</code>函数可以将一个函数应用到一个可迭代对象的所有元素上，并返回一个新的可迭代对象。这种方式可以比显式的<code>for</code>循环更快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers))</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>使用<code>numpy</code>库：如果你在处理大量的数值数据，使用<code>numpy</code>库可以显著加快<code>for</code>循环的运算。<code>numpy</code>是一个高性能的科学计算库，提供了多维数组和向量化操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">numbers = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">squared = numbers**<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p><strong>并行计算</strong>：如果你需要对一个较大的数据集进行计算，并且这些计算是相互独立的，你可以考虑使用并行计算来加速<code>for</code>循环。<code>Python</code>中有一些库，如<code>multiprocessing</code>和<code>concurrent.futures</code>，可以方便地实现并行计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Pool() <span class="keyword">as</span> pool:</span><br><span class="line">    squared = pool.<span class="built_in">map</span>(square, numbers)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Pandas加速循环">Pandas加速循环</h2>
<ol>
<li class="lvl-4">
<p><code>Iterrows()</code>为每一行返回一个<code> Series</code>，因此它以索引对的形式遍历<code>DataFrame</code>，以<code>Series</code>的形式遍历目标列，这使得它比标准循环更快。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建示例DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用iterrows()遍历DataFrame</span></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    <span class="comment"># 访问每一行的数值</span></span><br><span class="line">    a_value = row[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">    b_value = row[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行操作</span></span><br><span class="line">    result = a_value + b_value</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-4">
<p><code>apply</code>本身并不快，但与<code>DataFrame</code>结合使用时，它具有很大的优势。这取决于<code>apply</code>表达式的内容。 如果它可以在<code>Cython</code>中执行，那么<code>apply</code>要快得多。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建示例DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用apply()遍历DataFrame的每一行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_values</span>(<span class="params">row</span>):</span><br><span class="line">    <span class="comment"># 访问每一行的数值</span></span><br><span class="line">    a_value = row[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">    b_value = row[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行操作</span></span><br><span class="line">    <span class="keyword">return</span> a_value + b_value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用apply()进行循环操作</span></span><br><span class="line">result = df.apply(add_values, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>利用向量化<code>Pandas Vectorization</code>的优势来创建真正高效的代码</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">80</span>, <span class="number">90</span>, np.inf]</span><br><span class="line">labels = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;grade&#x27;</span>] = pd.cut(df[<span class="string">&#x27;score&#x27;</span>], bins=bins, labels=labels)</span><br></pre></td></tr></table></figure>
<p>以上示例中，通过直接对整个<code>DataFrame</code>或<code>Series</code>进行操作，避免了显式的循环，并且利用了底层的C实现来提高运算效率。向量化操作通常比迭代方式更高效，并且能够简化代码，提高可读性。</p>
<h2 id="itertools加速循环">itertools加速循环</h2>
<p><code>itertools</code> 是一个强大的 <code>Python</code> 模块，提供了许多用于迭代和组合的工具函数。虽然 <code>itertools</code> 本身并不会直接加速循环，但可以通过它提供的函数来优化循环的效率。</p>
<p>下面是一些使用 <code>itertools</code> 加速循环的示例：</p>
<ol>
<li class="lvl-4">
<p><code>itertools.chain()</code>: 如果你有多个可迭代对象，可以使用 <code>itertools.chain()</code> 将它们连接起来，从而避免多次嵌套循环。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i, j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 itertools.chain()</span></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">10</span>), <span class="built_in">range</span>(<span class="number">5</span>)):</span><br><span class="line">    <span class="built_in">print</span>(i, j)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-4">
<p><code>itertools.islice()</code>: 当你只需要迭代可迭代对象的一部分时，可以使用 <code>itertools.islice()</code> 来切片迭代。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list[<span class="number">3</span>:<span class="number">7</span>]:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 itertools.islice()</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> itertools.islice(my_list, <span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-4">
<p><code>itertools.compress()</code>: 如果你想根据某个条件过滤迭代对象，可以使用 <code>itertools.compress()</code> 来实现。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">my_condition = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item, condition <span class="keyword">in</span> <span class="built_in">zip</span>(my_list, my_condition):</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 itertools.compress()</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> itertools.compress(my_list, my_condition):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<p>这只是一些使用 <code>itertools</code> 加速循环的示例。根据具体的需求，你还可以探索其他 <code>itertools</code> 函数，如 <code>itertools.filterfalse()</code>、<code>itertools.groupby()</code> 等。</p>
<h2 id="Numba-makes-Python-code-fast">Numba makes Python code fast</h2>
<p><code>Numba</code>是一个适用于使用<code>NumPy</code>数组、函数和循环的<code>Python</code>即时编译器。使用<code>Numba</code>的常见方式是通过应用修饰符来编译函数。当调用使用<code>Numba</code>修饰的函数时，它会被即时编译为机器码，从而使代码的全部或部分以本地机器码速度运行。</p>
<h3 id="安装">安装</h3>
<p><code>Numba</code> 可用作<a href="https://www.anaconda.com/">Anaconda Python 发行版的</a><a href="https://conda.io/docs/">conda</a>包 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ conda install numba</span><br></pre></td></tr></table></figure>
<p><code>Numba</code> 也有可用的pip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install numba</span><br></pre></td></tr></table></figure>
<h3 id="装饰器-jit来尝试和加速一些功能">装饰器<code>@jit</code>来尝试和加速一些功能</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>) </span><span class="comment"># Set &quot;nopython&quot; mode for best performance, equivalent to @njit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go_fast</span>(<span class="params">a</span>): <span class="comment"># Function is compiled to machine code when called the first time</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a.shape[<span class="number">0</span>]):   <span class="comment"># Numba likes loops</span></span><br><span class="line">        trace += np.tanh(a[i, i]) <span class="comment"># Numba likes NumPy functions</span></span><br><span class="line">    <span class="keyword">return</span> a + trace              <span class="comment"># Numba likes NumPy broadcasting</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(go_fast(x))</span><br></pre></td></tr></table></figure>
<h3 id="其他感兴趣的事情：">其他感兴趣的事情：</h3>
<p><code>Numba</code> 有很多装饰器，我们已经看到了<code>@jit</code>，但也有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>@njit</code>- 这是一个别名，因为<code>@jit(nopython=True)</code>它很常用！</p>
</li>
<li class="lvl-2">
<p><code>@vectorize</code>- 生成 <code>NumPy</code> <code>ufunc</code>（支持所有方法<code>ufunc</code>）。<a href="https://numba.readthedocs.io/en/stable/user/vectorize.html#vectorize">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@guvectorize</code>- 生成 <code>NumPy</code> 广义<code>ufunc</code>s。 <a href="https://numba.readthedocs.io/en/stable/user/vectorize.html#guvectorize">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@stencil</code>- 声明一个函数作为类似模板操作的内核。 <a href="https://numba.readthedocs.io/en/stable/user/stencil.html#numba-stencil">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@jitclass</code>- 对于 jit 感知类。<a href="https://numba.readthedocs.io/en/stable/user/jitclass.html#jitclass">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@cfunc</code>- 声明一个用作本机回调的函数（从 <code>C/C++ </code>等调用）。<a href="https://numba.readthedocs.io/en/stable/user/cfunc.html#cfunc">文档在这里</a>。</p>
</li>
<li class="lvl-2">
<p><code>@overload</code>- 注册您自己的函数实现以在 nopython 模式下使用，例如<code>@overload(scipy.special.j0)</code>. <a href="https://numba.readthedocs.io/en/stable/extending/high-level.html#high-level-extending">文档在这里</a>。</p>
</li>
</ul>
<p>一些装饰器中可用的额外选项：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>parallel = True</code>-<a href="https://numba.readthedocs.io/en/stable/reference/jit-compilation.html#jit-decorator-parallel">启用</a>函数的自动 <a href="https://numba.readthedocs.io/en/stable/user/parallel.html#numba-parallel">并行化。</a></p>
</li>
<li class="lvl-2">
<p><code>fastmath = True</code>- 为函数启用<a href="https://numba.readthedocs.io/en/stable/reference/jit-compilation.html#jit-decorator-fastmath">快速数学行为。</a></p>
</li>
</ul>
<p><code>ctypes/cffi/cython </code>互操作性：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>cffi</code>- 模式支持<a href="https://numba.readthedocs.io/en/stable/reference/pysupported.html#cffi-support">CFFI</a>函数的调用<code>nopython</code>。</p>
</li>
<li class="lvl-2">
<p><code>ctypes</code>-模式支持调用<a href="https://numba.readthedocs.io/en/stable/reference/pysupported.html#ctypes-support">ctypes</a><code>nopython</code>包装函数。</p>
</li>
<li class="lvl-2">
<p><code>Cython</code> 导出的函数<a href="https://numba.readthedocs.io/en/stable/extending/high-level.html#cython-support">是可调用的</a>。</p>
</li>
</ul>
<h3 id="GPU-目标：">GPU 目标：</h3>
<p><code>Numba</code> 可以针对<a href="https://developer.nvidia.com/cuda-zone">Nvidia CUDA</a> GPU。您可以用纯 Python 编写内核并让 Numba 处理计算和数据移动（或明确地执行此操作）。单击以获取有关 <a href="https://numba.readthedocs.io/en/stable/cuda/index.html#cuda-index">CUDA</a>的 Numba 文档。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git及NodeJS安装配置</title>
    <url>/archives/938d5a31.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Git安装">Git安装</h2>
<p>在 Windows 上安装：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://git-scm.com/download/win">Git for Windows</a> 是运行在Windows系统上的Git版本，它提供了与其他版本相同的功能和命令，以便Windows用户能够使用Git来开发和管理项目。同时，Git for Windows还提供了额外的工具和选项，如Bash命令行工具和ssh客户端。</p>
</li>
<li class="lvl-3">
<p><a href="https://desktop.github.com/">GitHub Desktop</a>是一个可视化的GitHub客户端程序，它帮助用户简化了使用Git控制代码版本的复杂性。通过GitHub Desktop，用户可以方便地克隆、更新、提交和推送代码，管理分支和合并请求，以及与他人协作开发代码。它适用于Windows和macOS操作系统，并且是免费提供下载和使用的。</p>
</li>
</ul>
<span id="more"></span>
<h3 id="Git-for-Windows-2-39-2">Git for Windows(2.39.2)</h3>
<ol>
<li class="lvl-3">
<p>修改安装路径</p>
</li>
<li class="lvl-3">
<p>选择安装组件，选择如下</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/13/Zt7JU2mjPwq9DNu.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>选择<code>Git</code>默认编辑器，默认<code>Vim</code></p>
</li>
<li class="lvl-3">
<p>调整新存储库中的初始分支的名称，默认<code>Let Git decide</code></p>
</li>
<li class="lvl-3">
<p>调整<code>PATH</code>环境，默认即可</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/13/n3yBG1Rx6K8viTY.png" alt=""></p>
<ol start="6">
<li class="lvl-3">
<p>选择<code>SSH</code>可执行文件，默认<code>Use bundled OpenSSH</code></p>
</li>
<li class="lvl-3">
<p>选择<code>HTTPS</code>后端传输，默认<code>Use the OpenSSL library</code></p>
</li>
<li class="lvl-3">
<p>配置行结束转换，默认<code>Checkout Windows-style, commit Unix-style line endings</code></p>
</li>
<li class="lvl-3">
<p>配置终端模拟器以与<code>Git Bash</code>一起使用，默认<code>Use MinTTY(the default terminal of MSYS2)</code></p>
</li>
<li class="lvl-4">
<p>选择<code>git pull</code>的默认行为，默认<code>Default (fast-forward or merge)</code></p>
</li>
<li class="lvl-4">
<p>选择凭据助手，默认<code>Git Credential Manager</code></p>
</li>
<li class="lvl-4">
<p>配置额外选项，默认<code>Enable file system caching</code></p>
</li>
<li class="lvl-4">
<p>配置实验选项，默认即可</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/05/13/g9QYUONCXtD2aTS.png" alt=""></p>
<ol start="14">
<li class="lvl-4">
<p>测试</p>
</li>
</ol>
<p>安装完成，可以在开始菜单中看到<code>Git</code>的三个启动图标<code>（Git Bash、Git CMD、Git GUI）</code>,推荐使用<code>Git Bash</code></p>
<p><img src="https://s2.loli.net/2023/05/13/NtR31WeHUvMrC8u.png" alt=""></p>
<h4 id="配置SSH">配置SSH</h4>
<ol>
<li class="lvl-3">
<p><code>Git Bash</code>:</p>
</li>
</ol>
<p><code>Git Bash</code>中<code>Ctrl+ins</code> 复制 <code>Shift+ins</code>粘贴</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;Humble-LiuAo&quot;</span></span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;1743185682@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;1743185682@qq.com&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>新建SSH</p>
</li>
</ol>
<p>登录 <a href="https://link.zhihu.com/?target=http%3A//github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code></p>
<ol start="3">
<li class="lvl-3">
<p><code>git bash</code>:</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>将输出的内容复制到 <code>github SSH</code>,点击确定保存</p>
<ol start="4">
<li class="lvl-3">
<p>验证</p>
</li>
</ol>
<p>输入<code>ssh -T git@github.com</code>，显示如下信息，配置成功</p>
<p><img src="https://s2.loli.net/2023/05/13/q4oE6MkztX9amBi.png" alt=""></p>
<h2 id="NodeJS安装">NodeJS安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>下载安装：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p>
</li>
<li class="lvl-2">
<p>修改全局包保存路径（非必须）</p>
</li>
</ul>
<p>下载全局包时，默认保存在C盘下，可通过 <code>npm root -g</code> 命令查看当前路径，有时候想把全局包放在其他目录下，以免占用C盘空间。</p>
<p>在安装目录下创建两个文件夹，<code>node_global </code>全局包存放，<code>node_cache</code> node缓存。</p>
<p><img src="https://s2.loli.net/2023/05/13/hzdHwlSCp3RujUr.png" alt=""></p>
<ol>
<li class="lvl-3">
<p>在cmd命令行中执行如下两条命令</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config set prefix <span class="string">&quot;D:\Software\nodejs\node_global&quot;</span></span><br><span class="line">npm config set cache <span class="string">&quot;D:\Software\nodejs\node_cache&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>修改环境变量</p>
</li>
</ol>
<p>上面步骤里更改了<code>npm</code>全局模块的存放路径和<code>cache</code>路径，但是系统还不知道，所以需要修改环境变量。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改用户变量 <code>path</code>，添加 <code>node_global</code> 的路径</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/13/IyAcesFCoTz3Xwa.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加系统变量 <code>NODE_PATH</code></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/13/TtWgGUVuB92YQA7.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	Git 详细安装教程（详解 Git 安装过程的每一个步骤）: <a href="https://blog.csdn.net/mukes/article/details/115693833">https://blog.csdn.net/mukes/article/details/115693833</a></p>
<p>[2]	NodeJS安装及配置(Windows): <a href="https://blog.csdn.net/yaorongke/article/details/119084295">https://blog.csdn.net/yaorongke/article/details/119084295</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>代理与内网穿透</title>
    <url>/archives/b512fc98.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="代理">代理</h2>
<h3 id="什么是反向代理？">什么是反向代理？</h3>
<p>反向代理是位于 Web 服务器前面的服务器，其将客户端（例如 Web 浏览器）请求转发到这些 Web 服务器。反向代理通常用于帮助提高<a href="https://www.cloudflare.com/learning/security/what-is-web-application-security/">安全性</a>、<a href="https://www.cloudflare.com/learning/performance/why-site-speed-matters/">性能</a>和可靠性。为了更好地理解反向代理的工作原理以及它可以提供的好处，我们来首先定义什么是代理服务器。</p>
<span id="more"></span>
<h3 id="什么是代理服务器？">什么是代理服务器？</h3>
<p>转发代理，通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机之前的服务器。当这些计算机向 Internet 上的站点和服务发出请求时，代理服务器将拦截这些请求，然后代表客户端与 Web 服务器进行通信，起到中间设备的作用。</p>
<p>例如，典型的转发代理通信中涉及 3 台计算机：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>A：这是用户的家用计算机</p>
</li>
<li class="lvl-2">
<p>B：这是一个转发代理服务器</p>
</li>
<li class="lvl-2">
<p>C：这是网站的源站（用于存储网站数据）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/jNpMBu3SwHXDsdF.png" alt="正向代理流：流量从用户的设备 (A) 到正向代理 (B) 到互联网到源服务器 (C)"></p>
<p>在标准的互联网通信中，计算机 A 将直接与计算机 C 保持联系，客户端将请求发送到<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源服务器</a>，并且源服务器将响应客户端。当存在转发代理时，A 将请求发送到 B，B 随后将请求转发给 C。C 将向 B 发送响应，而 B 则将响应转发给 A。</p>
<p>为什么要将这个多余的中间设备添加到 Internet 活动中？使用转发代理可能有几个原因：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>为避免州或机构的浏览限制</strong>——一些政府、学校和其他组织使用防火墙来使用户访问受限版本的互联网。转发代理可用于绕过这些限制，因为它们使用户可以连接到代理，而不是直接连接到他们正在访问的站点。</p>
</li>
<li class="lvl-2">
<p><strong>阻止访问某些内容</strong>——相对的，也可以设置代理以阻止特定用户群访问某些站点。例如，学校网络可能配置为通过启用内容筛选规则的代理连接到 Web，以拒绝转发来自 Facebook 和其他社交媒体网站的响应。</p>
</li>
<li class="lvl-2">
<p><strong>保护自己的在线身份</strong>——在某些情况下，常规互联网用户希望增加在线匿名性，但在其他情况下，互联网用户居住在政府可能对政治异议者施加严重后果的地方。在网络论坛或社交媒体上批评政府可能会导致这些用户受到罚款或监禁。如果持不同政见者使用转发代理连接到他们发布政治敏感评论的网站，则用于发表评论的 <a href="https://www.cloudflare.com/learning/dns/glossary/what-is-my-ip-address/">IP 地址</a>将更难追溯到持不同政见者。仅代理服务器的 IP 地址将对他人可见。</p>
</li>
</ul>
<h3 id="反向代理有何不同？">反向代理有何不同？</h3>
<p>反向代理是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求。这与转发代理不同 - 在转发代理中，代理位于客户端的前面。使用反向代理，当客户端将请求发送到网站的源服务器时，反向代理服务器会在<a href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/">网络边缘</a>拦截这些请求。然后，反向代理服务器将向源服务器发送请求并从源服务器接收响应。</p>
<p>转发代理和反向代理之间的区别非常细微，但非常重要。简单概括而言，转发代理位于客户端的前面，确保没有源站直接与该特定客户端通信；而反向代理服务器位于源站前面，确保没有客户端直接与该源站通信。</p>
<p>这一次，所涉及的计算机包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>D：任意数量的用户家用计算机</p>
</li>
<li class="lvl-2">
<p>E：这是反向代理服务器</p>
</li>
<li class="lvl-2">
<p>F：一台或多台源站</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/IoGSXLkaHTrl7PU.png" alt="反向代理流：流量从用户的设备 (D) 到互联网到反向代理 (E) 到源服务器 (F)"></p>
<p>通常，来自 D 的所有请求都将直接发送到 F，而 F 会直接将响应发送到 D。使用反向代理，来自 D 的所有请求都将直接发送给 E，而 E 会将其请求发送到 F 并从 F 接收响应，然后将适当响应传递给 D。</p>
<p>下面是反向代理的一些好处：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><a href="https://www.cloudflare.com/learning/cdn/cdn-load-balance-reliability/">负载均衡</a></strong> - 一个每天吸引数百万用户的热门网站可能无法使用单个源服务器处理所有传入站点流量。但该站点可以分布在不同服务器的池中，让所有服务器都处理同一站点的请求。在这种情况下，反向代理可以提供一种负载均衡解决方案，在不同服务器之间平均分配传入流量，以防止单个服务器过载。如果某台服务器完全无法运转，则其他服务器可以代为处理流量。</p>
</li>
<li class="lvl-2">
<p><strong>防范攻击</strong> - 配备反向代理后，网站或服务无需透露其源服务器的 IP 地址。这使得攻击者更难利用针对性攻击，例如 <a href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/">DDoS 攻击</a>。这时候，攻击者只能针对反向代理，例如 Cloudflare 的 <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/">CDN</a>，而后者拥有具有更严格的安全性，拥有更多资源来抵御网络攻击。</p>
</li>
<li class="lvl-2">
<p><strong><a href="https://www.cloudflare.com/learning/cdn/glossary/global-server-load-balancing-gslb/">全局服务器负载平衡</a> (GSLB)</strong> - 在这种负载均衡形式中，一个网站可以分布在全球各地的多个服务器上，反向代理会将客户端发送到地理位置上最接近它们的服务器。这样可以减少请求和响应传播的距离，从而最大程度地减少加载时间。</p>
</li>
<li class="lvl-2">
<p><strong>缓存</strong> - 反向代理还可以<a href="https://www.cloudflare.com/learning/cdn/what-is-caching/">缓存</a>内容，从而提高速度。例如，如果巴黎的用户访问使用反向代理而 Web 服务器位于洛杉矶的网站，则该用户实际上可能连接到巴黎本地的反向代理服务器，然后该本地反向代理服务器必须与洛杉矶的源服务器进行通信。之后，代理服务器可以缓存（或临时保存）响应数据。随后浏览该站点的巴黎用户将从巴黎反向代理服务器处获取本地缓存的响应，从而享受到更快的性能。</p>
</li>
<li class="lvl-2">
<p><strong>SSL 加密</strong> - <a href="https://www.cloudflare.com/learning/ssl/what-is-encryption/">加密</a>和解密每个客户端的 <a href="https://www.cloudflare.com/learning/security/glossary/what-is-ssl/">SSL</a>（或 <a href="https://www.cloudflare.com/learning/security/glossary/transport-layer-security-tls/">TLS</a>）通信对于源服务器可能需要耗费大量计算资源。可以配置由反向代理解密所有传入请求并加密所有传出响应，腾出源服务器上的宝贵资源。</p>
</li>
</ul>
<h3 id="如何实施反向代理">如何实施反向代理</h3>
<p>一些公司构建自己的反向代理，但这需要大量的软件和硬件工程资源，以及对硬件的大量投资。享受反向代理的所有好处的最简单、最具成本效益的方法之一就是注册 CDN 服务。例如，<a href="https://www.cloudflare.com/cdn/">Cloudflare CDN</a> 提供上面列出的所有性能和安全功能，以及许多其他功能。</p>
<h2 id="内网穿透">内网穿透</h2>
<h3 id="1-什么是内网穿透">1. 什么是内网穿透?</h3>
<p>在了解内网穿透原理之前，我们先说什么是内网穿透。内网，就是在公司或者家庭内部，建立的局域网络或者是办公网络，可以实现多台电脑之间的资源共享，包括设备、资料、数据等。而外网则是通过一个网关与其它的网络系统连接，相对于内网而言，这种网络系统称之为外部网络，常见的就是我们日常使用的互联网。</p>
<p>一般而言，在没有固定公网IP的情况下，外网设备无法直接访问内网设备。而内网穿透技术，顾名思义就是能让外网的设备找到处于内网的设备，从而实现数据通信。</p>
<h3 id="2-内网穿透的原理">2. 内网穿透的原理</h3>
<p>内网穿透，又称为NAT穿透。NAT背后的设备，它们的主要特点是 ，可以访问外网，但不能被外网设备有效访问。基于这一特点，NAT穿透技术是让NAT背后的设备，先访问指定的外网服务器，由指定的外网服务器搭建桥梁，打通内、外网设备的访问通道，实现外网设备访问到内网设备。</p>
<p>该技术除了可以访问隐藏在NAT后的设备，同样可以穿透防火墙。这是因为防火墙一般只拦截了入站没有拦截出站，所以也可以让防火墙内的设备对外提供服务。</p>
<p>由于内网设备并不是与外网设备直接相连，所以在安全性上是毋庸置疑的，内网穿透可以说是安全与效率兼得。</p>
<p><img src="https://s2.loli.net/2023/05/11/RE1iaN8nV6dDMWg.png" alt=""></p>
<h3 id="3-如何实现内网穿透">3. 如何实现内网穿透</h3>
<p>我们可以安装<a href="https://hsk.oray.com/">花生壳</a>内网穿透软件，在软件上添加<a href="https://hsk.oray.com/">映射</a>时，配置被访问内网设备的相关信息 ，以及选择用作外网访问该映射的<a href="https://domain.oray.com/">域名</a>。当映射诊断信息提示连接成功时，即可实现内网穿透。</p>
<p>利用花生壳的内网穿透技术，外网的设备通过访问固定域名，连接花生壳服务器所搭建的通道，顺畅地与内网设备进行数据通信。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	什么是反向代理？|代理服务器介绍: <a href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/">https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/</a></p>
<p>[2]	内网穿透原理解析: <a href="https://service.oray.com/question/5571.html">https://service.oray.com/question/5571.html</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>代理</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置C++</title>
    <url>/archives/1a24c243.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>使用系统：Ubuntu</p>
<p>使用IDE：Clion（目前用的免费教育许可证：<a href="https://www.jetbrains.com/zh-cn/community/education/#students%EF%BC%89">https://www.jetbrains.com/zh-cn/community/education/#students）</a></p>
</blockquote>
<span id="more"></span>
<h2 id="环境配置">环境配置</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 终端安装</span><br><span class="line">apt-get install gcc</span><br><span class="line">apt-get install g++</span><br><span class="line">或指定版本：8</span><br><span class="line">sudo apt-get install gcc-8</span><br><span class="line">sudo apt-get install g++-8</span><br><span class="line"># 查看版本</span><br><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br><span class="line"># 查看该命令的所有操作</span><br><span class="line">g++ --h</span><br><span class="line">gcc --h</span><br></pre></td></tr></table></figure>
<h2 id="终端运行示例">终端运行示例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+T 打开终端</span><br><span class="line">mkdir ~/Projects/cppdemo &amp;&amp; cd ~/Projects/cppdemo # 创建项目目录cppdemo</span><br><span class="line">vi hello.cpp # vi打开文件hello.cp</span><br></pre></td></tr></table></figure>
<p>输入代码（<code>vi</code>操作）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>g++</code>编辑器编译，生成可执行文件 hello，<code>-o</code> 后面的hello是生成的存储输出内容的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>执行可执行文件（即打开hello）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure>
<h2 id="vim常用命令">vim常用命令</h2>
<p><strong>Vim(Vi IMproved)</strong> 是一种功能强大的文本编辑器，常用于Unix和Linux系统中。下面是一些常见的 Vim 操作：</p>
<ol>
<li class="lvl-3">
<p>打开文件：</p>
<ul class="lvl-2">
<li class="lvl-5">在终端中输入<code>vim</code>命令，后跟文件路径和名称，例如：<code>vim myfile.txt</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p>模式切换：</p>
<ul class="lvl-2">
<li class="lvl-5">按下<code>i</code>进入插入模式，可以输入和编辑文本。</li>
<li class="lvl-5">按下<code>Esc</code>键回到普通模式，可以执行命令。</li>
</ul>
</li>
<li class="lvl-3">
<p>保存和退出：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>:w</code>保存文件。</li>
<li class="lvl-5">输入<code>:q</code>退出 Vim。</li>
<li class="lvl-5">输入<code>:wq</code>保存并退出。</li>
</ul>
</li>
<li class="lvl-3">
<p>导航和编辑文本：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，使用箭头键或<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>进行光标导航。</li>
<li class="lvl-5">使用<code>x</code>删除当前光标所在位置的字符。</li>
<li class="lvl-5">使用<code>dd</code>删除当前行。</li>
<li class="lvl-5">使用<code>yy</code>复制当前行。</li>
<li class="lvl-5">使用<code>p</code>粘贴剪贴板中的内容。</li>
</ul>
</li>
<li class="lvl-3">
<p>撤销和重做：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>u</code>撤销最近的操作。</li>
<li class="lvl-5">输入<code>Ctrl + r</code>重做撤销的操作。</li>
</ul>
</li>
<li class="lvl-3">
<p>查找和替换：</p>
<ul class="lvl-2">
<li class="lvl-5">在普通模式下，输入<code>/</code>，后跟要查找的内容，按下回车键开始查找。</li>
<li class="lvl-5">输入<code>n</code>查找下一个匹配项。</li>
<li class="lvl-5">输入<code>:%s/old/new/g</code>全局替换文档中的所有匹配项。</li>
</ul>
</li>
</ol>
<h2 id="Reference">Reference</h2>
<p>[1]	Linux下的C/C++编译环境配置: <a href="https://blog.csdn.net/qq_27607539/article/details/73721946">https://blog.csdn.net/qq_27607539/article/details/73721946</a></p>
<p>[2]	如何在Ubuntu终端运行C++程序: <a href="https://blog.csdn.net/W1995S/article/details/117876875">https://blog.csdn.net/W1995S/article/details/117876875</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>Vim</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware安装配置Ubuntu</title>
    <url>/archives/4da17f55.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="开启虚拟化">开启虚拟化</h2>
<p><strong>进入BIOS模式</strong>：联想拯救者：重启出现图标时按 <strong><u>Fn+F2</u></strong></p>
<ol>
<li class="lvl-3">
<p>选择 Configuration，再选择 Intel Virtualization Technology，此时该选项应该是 Disabled（关闭）；</p>
</li>
<li class="lvl-3">
<p>将 Disabled（关闭）改为 Enabled（开启）；</p>
</li>
</ol>
<span id="more"></span>  　　　　
<ol start="3">
<li class="lvl-3">
<p>点击Fn+F10，保存后退出，重启即可。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504172953354.png" alt=""></p>
<h2 id="安装ubuntu">安装ubuntu</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>参考 <mark>软件管家</mark> 公众号，或点击：<a href="https://mp.weixin.qq.com/s/OWUfIJ9Iwd-nwYhbTWXjuA">https://mp.weixin.qq.com/s/OWUfIJ9Iwd-nwYhbTWXjuA</a></p>
</li>
<li class="lvl-2">
<p><strong>硬盘、内存</strong>等参数可根据电脑配置修改</p>
</li>
</ul>
<h2 id="禁止更新">禁止更新</h2>
<ol>
<li class="lvl-3">
<p>系统设置–&gt;软件和更新–&gt;更新</p>
</li>
</ol>
<p>将“自动检查更新”和“有新版本时通知我”设置为“从不“，关闭对话框完成设置。</p>
<p><img src="https://s2.loli.net/2023/05/11/WqTUCsxc2kt7vRa.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>修改配置文件</p>
</li>
</ol>
<p>修改配置文件<code>/etc/apt/apt.conf.d/10periodic</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxx:~$cat /etc/apt/apt.conf.d/10periodic</span><br><span class="line">APT : :Periodic: : Update-Package-Lists &quot;1&quot;;</span><br><span class="line">APT : :Periodic: : Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line">APT : :Periodic: :AutocleanInterval &quot;0&quot;;</span><br><span class="line">APT : :Periodic: :Unattended-Upgrade &quot;0&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>linux系统下修改只读【read-only】文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod a+w /etc/apt/apt.conf.d/10periodic</span><br></pre></td></tr></table></figure>
<h2 id="输入法">输入法</h2>
<ol>
<li class="lvl-3">
<p>安装<code>fcitx</code>输入法框架</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx  # 安装fcitx输入法框架</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>配置<code>Fcitx</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">im-config  # 终端运行命令</span><br></pre></td></tr></table></figure>
<p>在弹出窗口选择<code>fcitx</code>，确认关闭窗口，并重启电脑让配置生效</p>
<p><img src="https://s2.loli.net/2023/05/11/iJMhA9I6Ny3zQXl.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>安装谷歌输入法</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx-googlepinyin -y # 安装谷歌输入法</span><br><span class="line">fcitx-config-gtk3   # 配置谷歌输入法</span><br></pre></td></tr></table></figure>
<p>在弹出对话框中取消勾选 “仅显示当前语言”，然后搜索选中“google”，点击确认。</p>
<p><img src="https://s2.loli.net/2023/05/11/jwv1inJr9ldCU4N.png" alt=""></p>
<p>点击桌面右上角，打开<code>configure</code>可以修改快捷键</p>
<p><img src="https://s2.loli.net/2023/05/11/AucRjCPOnmzFS8v.png" alt=""></p>
<p><strong>解决Jetbarins Clion Ubuntu Fcitx 中文输入法光标跟随问题</strong></p>
<ol>
<li class="lvl-3">
<p>下载根据补丁修复过的<code>jre</code>：<a href="https://github.com/RikudouPatrickstar/JetBrainsRuntime-for-Linux-x64/">https://github.com/RikudouPatrickstar/JetBrainsRuntime-for-Linux-x64/</a></p>
</li>
<li class="lvl-3">
<p>替换Clion的<code>jre</code></p>
<ul class="lvl-2">
<li class="lvl-5">选择特定<strong>路径</strong>解压</li>
<li class="lvl-5">Ctrl+shift+A，搜索: <code>Choose Boot Java Runtime for the IDE的Action</code>，并点击进入</li>
<li class="lvl-5">选择 <strong>New</strong> --&gt; <strong>Add Custom Runtime…</strong></li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/25oLvcydS8Jz1VW.png" alt="image-20230511201625729"></p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Add JDK…</strong></p>
</li>
<li class="lvl-5">
<p>选择你解压的 <strong>路径</strong> ，点击OK，重启即可</p>
</li>
</ul>
</li>
</ol>
<h2 id="必备软件">必备软件</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Vim、Firefox（浏览器）、Variety（桌面壁纸）</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/HsgGFj1eu3I6LmM.png" alt=""></p>
<h2 id="设置代理">设置代理</h2>
<ol>
<li class="lvl-3">
<p>安装clash for windows</p>
</li>
</ol>
<p>下载链接：<a href="https://github.com/Fndroid/clash_for_windows_pkg">https://github.com/Fndroid/clash_for_windows_pkg</a></p>
<p>选择<code>linux</code>版本的压缩包</p>
<p><img src="https://s2.loli.net/2023/05/11/p3aCmfMAWLU9Hni.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p>运行clash</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd download #切换到下载目录</span><br><span class="line">sudo tar -zx Clash.for.Windows-0.17.1-x64-linux.tar.gz -C /opt #解压</span><br><span class="line">cd /opt</span><br><span class="line">sudo mv &#x27;Clash for Windows-0.17.1-x64-linux&#x27; clash  # 重命名</span><br><span class="line">cd clash</span><br><span class="line">./cfw  # run</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>配置clash</p>
</li>
</ol>
<p>clash导入订阅链接–&gt;开启代理（建议打开开机自启）</p>
<p><img src="https://s2.loli.net/2023/05/11/1QnjTCq4LlwOeyx.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>设置代理</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>终端添加环境变量</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 666 /etc/environment</span><br><span class="line">vi /etc/environment</span><br><span class="line"># 填入内容</span><br><span class="line">http_proxy=http://127.0.0.1:7890/</span><br><span class="line">https_proxy=http://127.0.0.1:7890/</span><br><span class="line">ftp_proxy=http://127.0.0.1:7890/</span><br><span class="line">HTTP_PROXY=http://127.0.0.1:7890/</span><br><span class="line">HTTPS_PROXY=http://127.0.0.1:7890/</span><br><span class="line">FTP_PROXY=http://127.0.0.1:7890/</span><br><span class="line"># 恢复原始状态</span><br><span class="line">sudo chmod 444 /etc/environment</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>或者：设置–&gt;网络–&gt;手动设置代理</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/XNFpfvIk95E3ire.png" alt=""></p>
<h2 id="克隆">克隆</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>右键点击虚拟机–&gt;管理–&gt;克隆</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/KDLpXHFaYlCncSm.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改克隆文件名</p>
</li>
</ul>
<p>修改如下克隆配置文件名字</p>
<p><img src="https://s2.loli.net/2023/05/11/rJDClkcfet8vRVZ.png" alt=""></p>
<p>打开<code>.vmx</code>文件，修改相应的值即可</p>
<p><img src="https://s2.loli.net/2023/05/11/WMFa1jY7kQ3dVue.png" alt=""></p>
<h2 id="优化">优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改导航栏位置</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/05/11/n8hEAt1fxYr2veP.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	ubuntu 禁止/取消系统自动更新的方法: <a href="https://blog.csdn.net/dacming/article/details/125164420">https://blog.csdn.net/dacming/article/details/125164420</a></p>
<p>[2] 	linux系统下修改只读【read-only】文件: <a href="https://blog.csdn.net/weixin_45677951/article/details/108746753">https://blog.csdn.net/weixin_45677951/article/details/108746753</a></p>
<p>[3]	ubuntu20.04 LTS安装谷歌拼音输入法: <a href="https://blog.csdn.net/kan2016/article/details/105735645">https://blog.csdn.net/kan2016/article/details/105735645</a></p>
<p>[4]	linux下使用clash(GUI): <a href="https://www.jianshu.com/p/02e3e8ccfe80">https://www.jianshu.com/p/02e3e8ccfe80</a></p>
<p>[5]	ubuntu启动栏导航栏放置到桌面底部、左侧: <a href="https://blog.csdn.net/lzp_k2/article/details/100089800">https://blog.csdn.net/lzp_k2/article/details/100089800</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter安装配置</title>
    <url>/archives/72216da9.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="安装">安装</h2>
<ol>
<li class="lvl-3">
<p><strong>conda安装</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Prompt</code>，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install jupyter notebook</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol start="2">
<li class="lvl-3">
<p><strong>navigator安装</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Navigator</code>，点击<code>Jupyter</code>下的 <code>Insatll</code></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509223656406.png" alt=""></p>
<h2 id="修改默认打开路径">修改默认打开路径</h2>
<ol>
<li class="lvl-3">
<p><strong>生成配置文件</strong></p>
</li>
</ol>
<p>打开<code>Anaconda Prompt</code>，输入<code>jupyter notebook --generate-config</code></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/a6b56b88c868a12438d03169baed880.png" alt=""></p>
<ol start="2">
<li class="lvl-3">
<p><strong>修改配置文件</strong></p>
<p>根据显示的路径，打开配置文件<code>jupyter_notebook_config.py</code>，全文搜索 <code>notebook_dir</code>，找到后填入自己的工作路径并保存。（注意：工作路径不能出现中文，否则无法打开<code>Jupyter Notebook</code>）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509223042167.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p><strong>修改JupyterNotebook快捷方式的目标属性</strong></p>
</li>
</ol>
<p>右击<code>JupyterNotebook</code>快捷方式，选择【属性】，删除【目标】属性中的【%USERPROFILE%】，点击【应用】–【确定】</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/7e5c619809d4324a7bfd40810834af3.png" alt=""></p>
<h2 id="优化">优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>主题切换</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># install jupyterthemes</span><br><span class="line">conda install -c conda-forge jupyterthemes</span><br><span class="line"># update to latest version</span><br><span class="line">conda update jupyterthemes</span><br><span class="line"></span><br><span class="line">jt -l # 加载可用主题列表</span><br><span class="line"># selecting a particular theme</span><br><span class="line">jt -t &lt;name of the theme&gt;</span><br><span class="line"># reverting to original Theme</span><br><span class="line">jt -r</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509225426973.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>插件安装</strong></p>
</li>
</ul>
<p>打开<code>Anaconda Prompt</code>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure>
<p>安装完点击<code>extensions</code>，勾选相应的功能即可</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230509230915195.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	jupyter-contrib-nbextensions: <a href="https://pypi.org/project/jupyter-contrib-nbextensions/">https://pypi.org/project/jupyter-contrib-nbextensions/</a></p>
<p>[2]	jupyter-themes: <a href="https://github.com/dunovank/jupyter-themes">https://github.com/dunovank/jupyter-themes</a></p>
<p>[3]	Installing Jupyter: <a href="https://jupyter.org/install">https://jupyter.org/install</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>You-Get下载视频</title>
    <url>/archives/96ba4918.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><code>You-Get</code>是一款功能强大的开源命令行工具，可支持从多种网站下载视频、音频等媒体内容，包括流行的YouTube、Bilibili、优酷、爱奇艺等平台。不仅如此，它还能够下载各种在线流媒体、HLS、DASH、M3U8等格式的视频和音频。该工具简单易用，支持多种操作系统，如Windows、macOS和Linux等平台。使用者只需在终端输入指令，即可轻松将感兴趣的媒体下载到本地。<code>You-Get</code>还支持批量下载、断点续传等实用功能，非常适合在需要下载大量媒体内容的情况下使用。</p>
</blockquote>
<span id="more"></span>
<h2 id="配置">配置</h2>
<p><strong>安装 you-get</strong>（<em>装有python环境</em>：参考<a href="https://liuaoao.top/archives/eabeff19.html">Anaconda-Python环境安装</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install you-get  </span><br></pre></td></tr></table></figure>
<p><strong>安装 ffmpeg</strong>（合并音画必须）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>python: <code>pip install ffmpeg</code></p>
</li>
<li class="lvl-2">
<p>或者官网下载：<a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></p>
<ul class="lvl-2">
<li class="lvl-4">将<code>ffmpeg.exe</code>的上一层路径 <code>xxx\bin</code>填入环境变量（用户+系统的Path，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</li>
</ul>
</li>
<li class="lvl-2">
<p>检验是否安装成功<code>ffmpeg -version</code></p>
</li>
</ul>
<h2 id="下载命令">下载命令</h2>
<p><strong>视频信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get -i URL #提示如何下载不同比例不同格式文件</span><br><span class="line">- format:        dash-flv</span><br><span class="line">  container:     mp4</span><br><span class="line">  quality:       高清 1080P</span><br><span class="line">  size:          222.8 MiB (233636151 bytes)</span><br><span class="line"># download-with: you-get --format=dash-flv [URL]</span><br></pre></td></tr></table></figure>
<p><strong>单个视频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get [URL]              #通过网址下载文件</span><br><span class="line">you-get -o 本地路径  [URL]   #更改本地下载目录，默认下载位置为当前powershell打开目录</span><br><span class="line">cd C:\                         #更改powershell目录</span><br></pre></td></tr></table></figure>
<p><strong>批量下载</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>playlist</code>可以使其按列表下载（批量下载的关键）</p>
</li>
<li class="lvl-2">
<p><code>format=dash-flv720</code>指定下载720P的flv视频</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看批量视频信息</span><br><span class="line">you-get --playlist -i https://www.bilibili.com/video/BV13t411G7oh</span><br><span class="line"># 下载</span><br><span class="line">you-get --playlist --format=dash-flv720 -o D:\SX https://www.bilibili.com/video/BV13t411G7oh</span><br></pre></td></tr></table></figure>
<h2 id="使用技巧">使用技巧</h2>
<ol>
<li class="lvl-3">
<p>使用代理加速（参考：<a href="https://liuaoao.top/archives/7b6d4a85.html">Windows代理设置</a>）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一次性关闭命令行需重新设置</span><br><span class="line">set http_proxy=http://127.0.0.1:1080</span><br><span class="line">set https_proxy=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>cookies请求</p>
</li>
</ol>
<p>一些视频可能需要会员才能下载，此时我们需要带cookies请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you-get --cookies=C:\Users\91425\Desktop\cookies.txt --format=dash-flv -o D:\SX https://www.bilibili.com/video/BV19h411s7oq </span><br><span class="line"># --cookies=C:\Users\91425\Desktop\cookies.txt 部分就是指定cookies的部分</span><br></pre></td></tr></table></figure>
<p><code>you-get</code>支持<code>Mozilla cookies.sqlite</code>和<code>Netscape</code>两种格式的<code>cookies</code>。前者可以使用火狐浏览器直接导出。后者在<code>Chromium</code>内核的浏览器上可以使用<code>Get cookies.txt</code>插件获取。</p>
<h2 id="Reference">Reference</h2>
<p>[1]	记录一个you-get批量下载B站视频的方法: <a href="https://zhuanlan.zhihu.com/p/442019718">https://zhuanlan.zhihu.com/p/442019718</a></p>
<p>[2]	You-get在Windows系统下的安装+会员视频下载的cookie配置: <a href="https://blog.csdn.net/cwj1412/article/details/107775004">https://blog.csdn.net/cwj1412/article/details/107775004</a></p>
<p>[3]	you-get不自动合并音频和视频的解决办法: <a href="https://zhuanlan.zhihu.com/p/386392241">https://zhuanlan.zhihu.com/p/386392241</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-axis</title>
    <url>/archives/e3a284ef.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>在Python中，<code>axis</code>参数在许多库如NumPy、Pandas中是一个重要概念，它表示数据沿着哪个轴或维度进行操作。</p>
</blockquote>
<h2 id="NumPy">NumPy</h2>
<h3 id="np-array">np.array()</h3>
<p>对于一个二维数组（矩阵），<code>axis=0</code>表示操作沿着行（垂直方向），<code>axis=1</code>表示操作沿着列（水平方向）</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 3x3 的数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着 axis=0（行方向）求和</span></span><br><span class="line">sum_axis0 = np.<span class="built_in">sum</span>(arr, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 输出: array([12, 15, 18])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着 axis=1（列方向）求和</span></span><br><span class="line">sum_axis1 = np.<span class="built_in">sum</span>(arr, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输出: array([ 6, 15, 24])</span></span><br></pre></td></tr></table></figure>
<h3 id="np-concatenate-a1-a2-axis-0">np.concatenate(a1,a2 axis=0)</h3>
<p><code>np.concatenate</code>主要用于在指定轴上对多个数组进行拼接，拼接的轴的长度必须相同，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]) </span><br><span class="line"></span><br><span class="line">c = np.concatenate((a, b), axis=<span class="number">0</span>)</span><br><span class="line">d = np.concatenate((a, b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment">#[[1 2]</span></span><br><span class="line"><span class="comment"># [3 4]</span></span><br><span class="line"><span class="comment"># [5 6]</span></span><br><span class="line"><span class="comment"># [7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2 5 6]</span></span><br><span class="line"><span class="comment"># [3 4 7 8]]</span></span><br></pre></td></tr></table></figure>
<h3 id="np-append-arr-values-axis-None">np.append(arr, values, axis=None)</h3>
<p><code>np.append</code>是在数组的末尾添加元素，其使用方法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.append(arr, values, axis=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中，arr为原数组，values为需要添加的值，axis为需要添加的轴（如果不指定axis，则会将数组先展开成1D数组，再进行添加）。如果添加的值是一个数组，则会将数组在指定的轴上与原数组进行拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">c = np.append(a, b)  <span class="comment"># 在1D数组上进行拼接</span></span><br><span class="line">d = np.append(a, b, axis=<span class="number">0</span>)  <span class="comment"># 在行上进行拼接</span></span><br><span class="line">e = np.append(a, b, axis=<span class="number">1</span>)  <span class="comment"># 在列上进行拼接</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment">#[1 2 3 4 5 6 7 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2]</span></span><br><span class="line"><span class="comment"># [3 4]</span></span><br><span class="line"><span class="comment"># [5 6]</span></span><br><span class="line"><span class="comment"># [7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[1 2 5 6]</span></span><br><span class="line"><span class="comment"># [3 4 7 8]]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>np.append</code>返回的是新的数组，不会改变原数组。在原始数据集比较大时，推荐使用<code>np.concatenate()</code>函数进行数组拼接。</p>
<h3 id="np-stack-array-axis-0">np.stack(array, axis=0)</h3>
<p>沿着新轴连接数组的序列，<mark>此方法与拼接不同</mark>。</p>
<p><em>axis</em> 参数指定新轴在结果尺寸中的索引。例如，如果<code>axis=0</code>，它将是第一个维度，如果<code>axis=-1</code>，它将是最后一个维度。</p>
<h4 id="一维数组">一维数组</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个一维数组</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴0方向连接这两个数组</span></span><br><span class="line">c = np.stack((a, b), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(c.shape)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (2,3)</span></span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴1方向连接这两个数组</span></span><br><span class="line">d = np.stack((a, b), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(d.shape)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (3,2)</span></span><br><span class="line"><span class="comment"># [[1 4]</span></span><br><span class="line"><span class="comment">#  [2 5]</span></span><br><span class="line"><span class="comment">#  [3 6]]</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2"></label><code>(2,3)</code>和<code>(3,2)</code>中的<code>2</code>是怎么来的：因为有<code>a</code>和<code>b</code>两个<code>array</code>。</p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">可以理解</label><code>axis</code>指定了要增加的维度：例如<code>axis=0</code>表示在第一维度上增加，因此<code>(2,3)</code>中的<code>2</code>位于第一维度。而<code>axis=1</code>表示在第二维度上增加，因此<code>(3,2)</code>中的<code>2</code>位于第二维度。</p>
</li>
</ul>
<h4 id="二维数组">二维数组</h4>
<p>两个要素：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>stack堆叠的 <strong>方向</strong></p>
</li>
<li class="lvl-2">
<p>stack堆叠后增加的 <strong>维度</strong></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个2行3列的二维数组</span></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个2行3列的二维数组</span></span><br><span class="line">arr2 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴0方向连接这两个数组</span></span><br><span class="line">arr3 = np.stack((arr1, arr2), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr3 shape:<span class="subst">&#123;arr3.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># Arr3 shape:(2, 2, 3)</span></span><br><span class="line"><span class="comment"># [[[ 1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 4  5  6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 7  8  9]</span></span><br><span class="line"><span class="comment">#   [10 11 12]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴1方向连接这两个数组</span></span><br><span class="line">arr4 = np.stack((arr1, arr2), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr4 shape:<span class="subst">&#123;arr4.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr4)</span><br><span class="line"><span class="comment"># Arr4 shape:(2, 2, 3)</span></span><br><span class="line"><span class="comment"># [[[ 1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 7  8  9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 4  5  6]</span></span><br><span class="line"><span class="comment">#   [10 11 12]]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在轴2方向连接这两个数组</span></span><br><span class="line">arr5 = np.stack((arr1, arr2), axis=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Arr5 shape:<span class="subst">&#123;arr5.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr5)</span><br><span class="line"><span class="comment"># Arr5 shape:(2, 3, 2)</span></span><br><span class="line"><span class="comment"># [[[ 1  7]</span></span><br><span class="line"><span class="comment">#   [ 2  8]</span></span><br><span class="line"><span class="comment">#   [ 3  9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  [[ 4 10]</span></span><br><span class="line"><span class="comment">#   [ 5 11]</span></span><br><span class="line"><span class="comment">#   [ 6 12]]]</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>2</code>就是指的<code>a</code>和<code>b</code>，而<code>2</code>放在什么位置是根据<code>axis</code>来确定的</p>
<h2 id="Pandas">Pandas</h2>
<p>在Pandas中，<code>axis</code>参数用于在<code>DataFrame</code>（类似于二维表格的数据结构）上执行操作，如汇总、排序和删除列或行等。与<code>NumPy</code>类似，<code>axis=0</code>表示操作沿着行（垂直方向），<code>axis=1</code>表示操作沿着列（水平方向）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="string">&#x27;C&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    A  B  C</span></span><br><span class="line"><span class="comment"># 0  1  4  7</span></span><br><span class="line"><span class="comment"># 1  2  5  8</span></span><br><span class="line"><span class="comment"># 2  3  6  9</span></span><br><span class="line"><span class="comment"># 删除名为 &#x27;A&#x27; 的列，沿着 axis=1（列方向）</span></span><br><span class="line">df = df.drop(<span class="string">&#x27;A&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    B  C</span></span><br><span class="line"><span class="comment"># 0  4  7</span></span><br><span class="line"><span class="comment"># 1  5  8</span></span><br><span class="line"><span class="comment"># 2  6  9</span></span><br><span class="line"><span class="comment"># 计算每一行的和，沿着 axis=1（列方向）</span></span><br><span class="line">row_sum = df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(row_sum)</span><br><span class="line"><span class="comment"># 0    11</span></span><br><span class="line"><span class="comment"># 1    13</span></span><br><span class="line"><span class="comment"># 2    15</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	numpy.stack最通俗的理解: <a href="https://blog.csdn.net/qq_17550379/article/details/78934529">https://blog.csdn.net/qq_17550379/article/details/78934529</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程</title>
    <url>/archives/e8e79e61.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><code>C++</code>并发编程是指在<code>C++</code>程序中使用多线程和同步机制来实现并发执行的功能。并发编程可以提高程序的性能和响应速度，同时也可以简化程序的设计和实现。</p>
<p>在<code>C++</code>中，可以使用多个线程来并发执行不同的任务。为了避免竞态条件和数据不一致等问题，需要使用同步机制来协调多个线程之间的操作。常用的同步机制包括互斥锁、条件变量、原子操作等。</p>
</blockquote>
<h2 id="hello-world开始">hello world开始</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>join()</mark> 函数：阻塞当前线程，直到关联的线程执行完毕。</p>
</li>
<li class="lvl-2">
<p><mark>detach()</mark> 函数：让一个线程在后台独立运行，不受主线程的控制，从而允许主线程提前退出而不必等待后台线程完成。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();       <span class="comment">// must add this line otherwise will failed!</span></span><br><span class="line">    <span class="comment">// 需要注意的是线程对象执行了join后就不再joinable了，所以只能调用join一次。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="Basic">Basic</h2>
<h3 id="悬空引用">悬空引用</h3>
<p>当 <strong>i</strong> 的生命周期结束时，<strong>func</strong> 对象中的引用 <strong>i</strong> 就变成了悬空引用，其指向的内存可能被其他程序占用或被释放，从而导致不可预测的错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;</span><br><span class="line">    <span class="type">int</span> &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp;i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">do_something</span>(i);           <span class="comment">// 1. 潜在访问隐患：悬空引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="简洁机制">简洁机制</h4>
<p>保线程在函数结束之前安全退出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特殊情况下的等待</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//        do_something_in_current_thread();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();  <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try catch 只能捕获轻量级错误,所以如需确保线程在函数之前结束——查看是否因为线程函数使用了局部变量的引用，</span></span><br><span class="line"><span class="comment">// 以及其他原因——而后再确定一下程序可能会退出的途径，无论正常与否，可以提供一个简洁的机制，来做解决这个问题。</span></span><br></pre></td></tr></table></figure>
<h4 id="RAII">RAII</h4>
<p>一种方式是使用“资源获取即初始化方式 <strong>(RAII，Resource Acquisition Is Initialization)</strong>，并且提供一个类，在析构函数中使用join()，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::thread支持移动的好处是可以创建thread_guard类的实例，并且拥有其线程的所有权。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span> &#123;</span><br><span class="line">    std::thread &amp;t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread &amp;t_)</span> :</span></span><br><span class="line"><span class="function">            t(t_) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">thread_guard</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) <span class="comment">// 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();      <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;   <span class="comment">// 3</span></span><br><span class="line">    thread_guard &amp;<span class="keyword">operator</span>=(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line"><span class="comment">//    do_something_in_current_thread();</span></span><br><span class="line">&#125;    <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 线程所关联的局部对象（即 my_func 的参数）的生命周期将在 thread_guard 对象之后结束，而不是在线程结束之后。当线程执行到4处时，局部对象就要被逆序销毁了。因此，thread_guard对象g是第一个被销毁的，</span></span><br><span class="line"><span class="comment">// 这时线程在析构函数中被加入2到原始线程中。</span></span><br><span class="line"><span class="comment">// 即使do_something_in_current_thread抛出一个异常，这个销毁依旧会发生。</span></span><br></pre></td></tr></table></figure>
<p>由于线程的管理得到了线程保护对象的管理，线程在程序结束时一定会被正确的处理，并且不会产生悬空的线程引用，保证了线程的安全退出.</p>
<h3 id="Most-Vexing-Parse">Most Vexing Parse</h3>
<p><strong>Most Vexing Parse</strong>：声明的对象被解析为一个函数声明而不是对象定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function">thread <span class="title">my_thread1</span><span class="params">(background_task())</span></span></span><br></pre></td></tr></table></figure>
<p>解决如下：</p>
<ol>
<li class="lvl-3">
<p>使用多组括号：这种方法可以告诉编译器我们正在声明一个对象，而不是一个函数。</p>
</li>
<li class="lvl-3">
<p>使用新的初始化语法：C<ins>11引入了C</ins>的新初始化语法，即使用花括号{}来初始化对象。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">thread <span class="title">my_thread1</span><span class="params">((background_task()))</span></span>; <span class="comment">// 使用多组括号</span></span><br><span class="line">my_thread1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">thread my_thread2&#123;<span class="built_in">background_task</span>()&#125;;   <span class="comment">// 使用新的初始化语法</span></span><br><span class="line">my_thread2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<h2 id="transfer">transfer</h2>
<p>这段代码演示了如何使用<code>std::thread</code>来创建新线程，并将类成员函数作为线程函数传递，同时也演示了如何使用<code>std::unique_ptr</code>来管理资源，并将这个资源传递给一个新线程。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>std::move(p)</code>: 左值转化为右值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_length_work</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_big_object</span><span class="params">(std::unique_ptr&lt;X&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X my_x;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(&amp;X::do_length_work, &amp;my_x)</span></span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;X&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> X)</span></span>;</span><br><span class="line">    p-&gt;<span class="built_in">do_length_work</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">tt</span><span class="params">(process_big_object,std::move(p))</span></span>;</span><br><span class="line">    <span class="comment">//std::thread实例的可移动且不可复制性。不可复制保性证了在同一时间点，</span></span><br><span class="line">    <span class="comment">// 一个std::thread实例只能关联一个执行线程；可移动性使得程序员可以自己决定，哪个实例拥有实际执行线程的所有权。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ownership">ownership</h2>
<h3 id="线程的创建、移动和管理">线程的创建、移动和管理</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; <span class="comment">// 构造一个thread对象t1</span></span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1); <span class="comment">// 把t1 move给另外一个thread对象t2，t1不再管理之前的线程了。</span></span><br><span class="line"><span class="comment">// 这句不需要std::move()，从临时变量进行移动是自动和隐式的。调用的是operator=(std::thread&amp;&amp;)</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function);</span><br><span class="line">std::thread t3;</span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2); <span class="comment">// 把t2 move给t3</span></span><br><span class="line"><span class="comment">// 把t3 move给t1，非法。因为`t1`已经有了一个相关的线程，会调用`std::terminate()`来终止程序。</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3);</span><br></pre></td></tr></table></figure>
<h3 id="一组线程">一组线程</h3>
<p>这段代码使用了<code>std::vector</code>和<code>std::thread</code>，它展示了如何使用C++11标准库来创建一组线程并等待它们完成工作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(<span class="type">unsigned</span> id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(do_work, i)); <span class="comment">// 产生线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(),</span><br><span class="line">                  std::<span class="built_in">mem_fn</span>(&amp;std::thread::join)); <span class="comment">// 对每个线程调用join()</span></span><br><span class="line">    <span class="comment">// &amp;std::thread::join获取的是std::thread::join成员函数的地址，将地址传递给std::mem_fn进行包装，从而将这个函数变成一个可调用对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RAII类scoped-thread">RAII类<code>scoped_thread</code></h3>
<p>这是一个RAII类<code>scoped_thread</code>的定义，它使用C++11标准库中的<code>std::thread</code>类来封装线程对象。具体来说，<code>scoped_thread</code>类通过重载构造函数和析构函数来控制线程的生命周期，从而确保线程在适当的时候被销毁。</p>
<p>在这个类的定义中，几个关键的实现细节：</p>
<ol>
<li class="lvl-3">
<p>使用<code>explicit</code>防止隐式类型转换。</p>
</li>
<li class="lvl-3">
<p>使用<code>std::logic_error</code>来抛出异常，以表示线程没有被启动的错误情况。</p>
</li>
<li class="lvl-3">
<p>在析构函数中调用<code>join()</code>函数，以确保线程在<code>scoped_thread</code>对象被销毁时能够正常结束。</p>
</li>
</ol>
<p>除此之外，由于线程对象的复制和复制赋值操作不可重载，因此需要通过<code>delete</code>关键字来禁止这些操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span> &#123;</span><br><span class="line">    std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span> :                 // <span class="number">1</span></span></span><br><span class="line"><span class="function">            t(std::move(t_)) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!t.<span class="built_in">joinable</span>())                                     <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;No thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">scoped_thread</span>() &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();                                            <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scoped_thread</span>(scoped_thread <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    scoped_thread &amp;<span class="keyword">operator</span>=(scoped_thread <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="runtime">runtime</h2>
<p>简单的线程池：将迭代器范围分割成多个子范围，每个子范围由一个线程进行处理，最后合并所有子范围的累加结果，从而实现了并行的累加操作。</p>
<p>在实现上，函数首先根据范围长度和硬件线程数，计算出要使用的线程数和任务块的大小。然后，函数将序列分块，并为每个块创建一个线程来执行累加操作。最后，使用<code>std::accumulate</code>将所有结果相加以得到最终结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使得每个线程具有最小数目的元素以避免过多的线程开销</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T &amp;result)</span> </span>&#123;</span><br><span class="line">        result = std::<span class="built_in">accumulate</span>(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumlate</span><span class="params">(Iterator first, Iterator last, T init)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">    cout&lt;&lt;max_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hardware_threads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    cout&lt;&lt;hardware_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> num_threads = std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    cout&lt;&lt;num_threads&lt;&lt;endl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> block_size = length / num_threads;</span><br><span class="line">    cout&lt;&lt;block_size&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(), block_start, block_end, std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">        <span class="comment">// std::ref用于将一个对象转化为一个引用</span></span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(block_start, last, results[num_threads - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// block_start到last无法划分为一个完整的块时，需要单独对这个子范围执行累加操作</span></span><br><span class="line">    std::for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), std::<span class="built_in">mem_fn</span>(&amp;std::thread::join));</span><br><span class="line">    <span class="comment">// std::mem_fn将一个成员函数指针转换为一个函数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">parallel_accumlate</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="id">id</h2>
<p>代码定义了两个函数<code>do_master_thread_work</code>和<code>do_common_work</code>，分别用于处理主线程和其他线程（即非主线程）的工作。在<code>some_core_part_of_algorithm</code>函数中，代码首先判断当前线程是否为主线程，如果是，则调用<code>do_master_thread_work</code>函数，否则调用<code>do_common_work</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的通用标识符</span></span><br><span class="line">std::thread::id master_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_master_thread_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;master&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_common_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;common&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::this_thread::<span class="built_in">get_id</span>() == master_thread) &#123;</span><br><span class="line">        <span class="built_in">do_master_thread_work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">do_common_work</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    master_thread = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;master_thread: &quot;</span> &lt;&lt; master_thread &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;master_thread 中运行:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">some_core_part_of_algorithm</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread 中运行:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(some_core_part_of_algorithm)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2>
<p>[1]	C++ 那些事: <a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Pr2020基础总结</title>
    <url>/archives/7eda6880.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><strong>安装</strong>：参考 <mark>软件管家</mark> 公众号(<a href="https://mp.weixin.qq.com/s/TC44SwDnZI2k1XsdCEBoyA">https://mp.weixin.qq.com/s/TC44SwDnZI2k1XsdCEBoyA</a>)，推荐2020及以上版本</p>
<p><u>注意GPU渲染出现预览黑屏，掉帧，导出渲染失败，cpu拉满独显不工作等问题，需更新驱动或Pr版本</u></p>
<ol>
<li class="lvl-3">
<p><strong>更新驱动</strong>为最新版本（参考：<a href="https://liuaoao.top/archives/2888cf0.html">Ps2019总结</a>）</p>
</li>
<li class="lvl-3">
<p>更新驱动未解决，<strong>更新Pr</strong>为2020或更高</p>
</li>
</ol>
</blockquote>
<span id="more"></span>
<h2 id="项目">项目</h2>
<p>新建：Ctrl+Alt+N</p>
<p>打开：Ctrl+O</p>
<h2 id="基本操作">基本操作</h2>
<h3 id="资源管理">资源管理</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">放大资源</td>
</tr>
<tr>
<td style="text-align:center">J、K、L</td>
<td style="text-align:center">前进、暂停、后退</td>
</tr>
<tr>
<td style="text-align:center">I、O</td>
<td style="text-align:center">入点、出点</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">标记</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+M</td>
<td style="text-align:center">删除标记</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+Alt+M</td>
<td style="text-align:center">删除所有标记</td>
</tr>
<tr>
<td style="text-align:center">Shift</td>
<td style="text-align:center">多选</td>
</tr>
<tr>
<td style="text-align:center">Ctrl</td>
<td style="text-align:center">点选</td>
</tr>
</tbody>
</table>
<p>工具栏快捷键: <mark>Alt + 相应字母</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>红色：一般模式</p>
</li>
<li class="lvl-2">
<p>黄色：吸附模式</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">按住Ctrl</td>
<td style="text-align:center">切换边缘编辑模式</td>
</tr>
<tr>
<td style="text-align:center">按住Shfit</td>
<td style="text-align:center">标尺吸附到边缘</td>
</tr>
<tr>
<td style="text-align:center">按住Alt+滑轮</td>
<td style="text-align:center">放大缩小</td>
</tr>
<tr>
<td style="text-align:center">双击边缘</td>
<td style="text-align:center">精确修剪</td>
</tr>
<tr>
<td style="text-align:center">J、K、L</td>
<td style="text-align:center">前进、暂停、后退</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">波纹编辑</td>
</tr>
<tr>
<td style="text-align:center">N</td>
<td style="text-align:center">滚动编辑</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">向前选择轨道</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">移动</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">剃刀</td>
</tr>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">外滑</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">钢笔</td>
</tr>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">手形</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">文字</td>
</tr>
<tr>
<td style="text-align:center">Shfit+剃刀</td>
<td style="text-align:center">整个</td>
</tr>
<tr>
<td style="text-align:center">Shfit+选择轨道</td>
<td style="text-align:center">单个</td>
</tr>
<tr>
<td style="text-align:center">Shift+Delete</td>
<td style="text-align:center">贴合删除</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+K</td>
<td style="text-align:center">截断</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+D</td>
<td style="text-align:center">视频过度</td>
</tr>
<tr>
<td style="text-align:center">Q</td>
<td style="text-align:center">波纹修剪上一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">波纹修剪下一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+Q</td>
<td style="text-align:center">修剪上一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+W</td>
<td style="text-align:center">修剪下一个编辑点到播放指示器</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="音轨">音轨</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>标准 -</strong> 标准音轨替代了旧版本的立体声音轨类型。它可以同时容纳单声道和立体声音频剪辑。</p>
</li>
<li class="lvl-2">
<p><strong>单声道 -</strong> 单声道轨道包含一个音频通道。单声道轨道会复制该通道，以便左声道和右声道播放相同的录音，或仅通过左声道或右声道中的一个通道播放录音。如果立体声剪辑添加到单声道轨道，立体声剪辑声道将由单声道轨道汇总为单声道。</p>
</li>
<li class="lvl-2">
<p><strong>立体声轨道 -</strong> 立体声轨道为双声道音频。立体声轨道是以两个声道（一左一右）录制的音频。</p>
</li>
<li class="lvl-2">
<p><strong>自适应轨道 -</strong> 自适应轨道可以包含单声道、立体声和自适应剪辑。对于自适应音轨，可通过对工作流程效果最佳的方式将源音频映射至输出音频声道。处理可录制多个音轨的摄像机录制的音频时，这种音轨类型非常有用。处理合并后的剪辑或多机位序列时，也可使用自适应音轨。</p>
</li>
<li class="lvl-2">
<p><strong>5.1 -</strong> 包含以下声道：</p>
<ul class="lvl-2">
<li class="lvl-4">三条前置音频声道（左声道、中置声道、右声道）</li>
<li class="lvl-4">两条后置或环绕音频声道（左声道和右声道）</li>
<li class="lvl-4">通向低音炮扬声器的低频效果 (LFE) 音频声道。</li>
</ul>
<p>5.1 音轨只能包含 5.1 剪辑。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Pr</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode安装配置</title>
    <url>/archives/fe901771.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>安装：官网下载即可（<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>），安装时一般 <strong>把path添加到环境变量</strong></p>
<p><u>因为VSCode可以同步设置，重点写一下无法同步的的设置</u></p>
</blockquote>
<h2 id="主题、字体、插件">主题、字体、插件</h2>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504200256615.png" alt=""></p>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504200520492.png" alt=""></p>
<h2 id="配置C-1">配置C++<sup>[1]</sup></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>安装 C++ 插件</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/e1311c50b41c19263e0b72ca0e79cf2.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>安装编译调试环境</strong></p>
</li>
</ul>
<p>Windows 系统 按照下面步骤配置</p>
<ol>
<li class="lvl-3">
<p>下载安装 mingw-w64：<a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a></p>
</li>
<li class="lvl-3">
<p>直接将 mingw-w64 解压到一个合适的目录（例如C:\Program Files下）</p>
</li>
<li class="lvl-3">
<p>添加上****mingw-w64\bin**个文件夹的路径（用户+系统，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/e66b9612b8c5eaba62dae5366029335.png" alt=""></p>
<ol start="4">
<li class="lvl-3">
<p>打开powershell/cmd， 输入 <strong>gcc -v</strong> , 看到版本说明环境变量配置成功</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>配置VS Code调试环境</strong></p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>新建 <strong>CPP\ .vscode</strong> 文件夹</p>
</li>
<li class="lvl-3">
<p>在 .vscode 文件夹中，依次新建文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c_cpp_properties.<span class="property">json</span></span><br><span class="line">launch.<span class="property">json</span></span><br><span class="line">tasks.<span class="property">json</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>复制内容到 json文件</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>launch.json</mark>中：</p>
<ul class="lvl-2">
<li class="lvl-4"><strong>“miDebuggerPath”: 后面修改为你的 mingw64 路径</strong></li>
<li class="lvl-4">“preLaunchTask”: “task g++”** 和 <strong>tasks.json</strong> 中的 <strong>“label”: “task g++”</strong> 引号中的名字要一致，本代码中为 <strong>task g++</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// launch.json 配置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line"><span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line"><span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,<span class="comment">//配置类型，只能为cppdbg</span></span><br><span class="line"><span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,<span class="comment">//请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="comment">//调试程序的路径名称</span></span><br><span class="line"><span class="string">&quot;args&quot;</span>: [],<span class="comment">//调试传递参数</span></span><br><span class="line"><span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line"><span class="string">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//true显示外置的控制台窗口，false显示内置终端</span></span><br><span class="line"><span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line"><span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\mingw64\\bin\\gdb.exe&quot;</span>, </span><br><span class="line"><span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line"><span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line"><span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;task g++&quot;</span>,<span class="comment">//调试前执行的任务，就是之前配置的tasks.json中的label字段</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tasks.json 配置文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class="line"><span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line"><span class="string">&quot;label&quot;</span>: <span class="string">&quot;task g++&quot;</span>,<span class="comment">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class="line"><span class="string">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>,</span><br><span class="line"><span class="string">&quot;args&quot;</span>: [<span class="comment">//编译时候的参数</span></span><br><span class="line"><span class="string">&quot;-g&quot;</span>,<span class="comment">//添加gdb调试选项</span></span><br><span class="line"><span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,<span class="comment">//指定生成可执行文件的名称</span></span><br><span class="line"><span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;owner&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line"><span class="string">&quot;fileLocation&quot;</span>: [</span><br><span class="line"><span class="string">&quot;relative&quot;</span>,</span><br><span class="line"><span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;pattern&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;regexp&quot;</span>: <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span>,</span><br><span class="line"><span class="string">&quot;file&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">&quot;column&quot;</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">&quot;severity&quot;</span>: <span class="number">4</span>,</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line"><span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span><span class="comment">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c_cpp_properties.json 配置文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;Win32&quot;</span>,</span><br><span class="line"><span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line"><span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;defines&quot;</span>: [</span><br><span class="line"><span class="string">&quot;_DEBUG&quot;</span>,</span><br><span class="line"><span class="string">&quot;UNICODE&quot;</span>,</span><br><span class="line"><span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;C:/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line"><span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c11&quot;</span>,</span><br><span class="line"><span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line"><span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-4">
<p>配置完上面，vscode就可以正常调试了</p>
</li>
</ol>
<h2 id="优化配置">优化配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序文件路径不要有 <strong>中文</strong>，否则会导致 <strong>调试失败</strong></p>
</li>
<li class="lvl-2">
<p>Vscode设置保留在单文件夹中，如果要更换文件夹，请把 <strong>.vscode</strong> 文件夹也复制到你要更改的文件夹中</p>
</li>
<li class="lvl-2">
<p>中文显示乱码问题 VScode 编码设置/文件乱码</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">点击文件-&gt;首选项-&gt;设置，然后在右边用户设置输入：<strong>“files.autoGuessEncoding”: true</strong></li>
<li class="lvl-4">插入这一行内用并保存。</li>
<li class="lvl-4">或者如下图打钩：</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/165f67da7eb2ba912d58cd6d6e712fa.png" alt=""></p>
<p>加入这个设置后，VSCode会在打开文件时尝试猜测字符集编码。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>VsCode内部终端运行代码</p>
</li>
</ul>
<p>设置在终端运行 : 首选项 -&gt; 设置 -&gt; 扩展 -&gt; Run Code ，勾选 <strong>Run In Terminal</strong> 和 <strong>Save File Before Run</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/f35d61b71af8ed28acf99d20e644c2e.png" alt=""></p>
<p>后记：投降了，Linux我用Clion，看<a href="https://liuaoao.top/archives/1a24c243.html">Linux配置C++</a></p>
<h2 id="Reference">Reference</h2>
<p>[1]	VSCode配置C++开发环境（MinGW-w64）: <a href="https://juejin.cn/post/7170216201849667621">https://juejin.cn/post/7170216201849667621</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm安装配置</title>
    <url>/archives/c545af56.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>PyCharm专业版是功能最丰富的，与社区版相比，PyCharm 业版增加了Web开发、Python We框架、Python分析器、远程开发、支持数据库与SQL等更多高级功能。</p>
<p>PyCharm的社区版中没有Web开发、Python We框架、Python分析器、远程开发、支持数据库与SQL等这些功能。</p>
<p>PyCharm教育版的功能虽然比专业版会少一些，但与社区版相比，更加支持学校的教学工作。</p>
</blockquote>
<span id="more"></span>
<h2 id="PyCharm专业版安装">PyCharm专业版安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>参考 <mark>软件管家</mark>公众号，或点击：<a href="https://mp.weixin.qq.com/s/V2Ls-lcnymD9_ZullCh_fg">https://mp.weixin.qq.com/s/V2Ls-lcnymD9_ZullCh_fg</a></p>
</li>
</ul>
<h2 id="主题字体配置">主题字体配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>外观（先安装主题插件Material theme）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504191917951.png" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>代码字体</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504191946833.png" alt=""></p>
<h2 id="插件配置">插件配置</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CodeGlance</strong>: 代码缩略图</p>
</li>
<li class="lvl-2">
<p><strong>IdeaVim</strong>: 在IDE中使用Vim编辑器的功能</p>
</li>
<li class="lvl-2">
<p><strong>Key Promoter X</strong>: 自动提示快捷键</p>
</li>
<li class="lvl-2">
<p><strong>Material Theme</strong>: 修改主题</p>
</li>
<li class="lvl-2">
<p><strong>RestfulToolkitX</strong>： 供了一组用于构建 RESTful API 的工具和方法</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504192054149.png" alt=""></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX安装</title>
    <url>/archives/88b90715.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>LaTeX是一种专业的排版系统和标记语言，用于创建高质量的文档，尤其适合包含数学公式、技术内容和复杂结构的文档，如学术论文、书籍、报告、简历等。TeX Live是一款跨平台的LaTeX发行版，它包含了LaTeX编译器、宏包、字体和各种工具，适用于多种操作系统，如Windows、Linux和macOS。TeXstudio是一款免费开源的LaTeX编辑器。</p>
<p>WIindows推荐： <mark>Texlive 2023 + TeX studio</mark></p>
</blockquote>
<span id="more"></span>
<h2 id="Texlive-2023">Texlive 2023</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>ISO 映像下载：<a href="https://www.tug.org/texlive/acquire-iso.html">https://www.tug.org/texlive/acquire-iso.html</a></p>
</li>
</ul>
<p><strong>打开下载后的.ISO文件，以管理员身份运行install-tl-windows.bat文件。</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/explorer_vgFd0Lbe70.png" alt=""></p>
<p><strong>修改安装位置</strong></p>
<p><strong>选择安装语言</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>高级选项里 <mark>Advanced</mark> $\rightarrow$点击 <mark>Customize</mark> $\rightarrow$选择 <mark>中文和英文</mark></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/20230502111347.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/wish_PhEbgdUYiI.png" alt=""></p>
<p><strong>确定安装，等待安装完成后关闭窗口</strong></p>
<hr>
<h3 id="Texlive添加环境变量">Texlive添加环境变量</h3>
<p>添加Texlive环境变量，以在命令行中执行tex的命令</p>
<ol>
<li class="lvl-3">
<p>win+R 然后输入**sysdm.cpl **在高级中选择<em>环境变量</em></p>
</li>
<li class="lvl-3">
<p>编辑的Path变量（建议<u>用户和系统</u>的Path都添加），添加txtlive中的<mark>bin/windows</mark>路径（如：D:\Software\texlive\2023\bin\windows）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/SystemPropertiesAdvanced_iXSckGIh1W.png" alt=""></p>
<ol start="3">
<li class="lvl-3">
<p>查看验证安装版本（出现 <mark>版本号</mark> 则成功）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tex -v</span><br><span class="line">latex -v</span><br><span class="line">xelatex -v</span><br><span class="line">pdflatex -v</span><br></pre></td></tr></table></figure>
<h2 id="TeXstudio的安装">TeXstudio的安装</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>官网下载：<a href="https://texstudio.sourceforge.net/">https://texstudio.sourceforge.net/</a></p>
</li>
</ul>
<p><strong>双击安装$\rightarrow$修改安装位置即可</strong></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/texstudio-4.5.2-win-qt6_5StfAN4gxi.png" alt=""></p>
<p><strong>使用注意</strong>：<em>如果撰写中文论文，将默认编译器改为<code>Xelatex</code>。如果撰写英文论文，将默认编译器改为<code>Pdflatex</code></em></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/texstudio_xkx0Bq0fS9.png" alt=""></p>
<h2 id="Reference">Reference</h2>
<p>[1]	LaTeX的安装教程：<a href="https://blog.csdn.net/weixin_43872190/article/details/113736283">https://blog.csdn.net/weixin_43872190/article/details/113736283</a><br>
[2]	Latex（一）安装和环境变量的设置：<a href="https://blog.csdn.net/explorer9607/article/details/103506387">https://blog.csdn.net/explorer9607/article/details/103506387</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Ps2019基础总结</title>
    <url>/archives/2888cf0.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p><strong>安装</strong>：参考 <mark>软件管家</mark> 公众号(<a href="https://mp.weixin.qq.com/s/jUEyqVY8RrU2RB_mlPlKDQ">https://mp.weixin.qq.com/s/jUEyqVY8RrU2RB_mlPlKDQ</a>)，推荐2019及以上版本</p>
<p><u>注意：电脑出现蓝屏自动重启情况，是显卡驱动问题，需更新到最新版</u></p>
<p>推荐使用<strong>GeForce Experience</strong>更新<strong>Studio</strong>（3D工作流畅）最新驱动</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/image-20230504091325087.png" alt=""></p>
</blockquote>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<p><strong>色相、饱和度和亮度</strong> 是 <mark>颜色</mark> 的三个基本属性，通常缩写为HSL。它们是用于描述颜色的一种常见方式，特别是在计算机图形学和设计中。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>色相（Hue）：指颜色的基本色调，如红色、绿色、蓝色等。色相可以用一个0到360度的角度值来表示，其中0度表示红色，120度表示绿色，240度表示蓝色。</p>
</li>
<li class="lvl-2">
<p>饱和度（Saturation）：指颜色的纯度或强度，即颜色中灰色成分的比例。饱和度越高，颜色越鲜艳，越接近于纯色。饱和度可以用一个0到100%的值来表示，其中0%表示灰色，100%表示纯色。</p>
</li>
<li class="lvl-2">
<p>亮度（Lightness）：指颜色的明暗程度，即颜色中黑色成分的比例。亮度可以用一个0到100%的值来表示，其中0%表示黑色，100%表示白色。</p>
</li>
</ul>
<p><mark>图像</mark> 中最基本的概念除 <strong>颜色</strong> 之外,还包括:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对比度:指图像中明暗度的差异,对比度大意味着同一图像中的亮度差异较大,对比度小则差异较小。对比度直接影响图像的清晰度和层次感。</p>
</li>
<li class="lvl-2">
<p>纹理:指图像中像素在空间方向的变化模式。纹理为图像提供了粗糙或平滑的视觉感觉,丰富了图像的内容。</p>
</li>
<li class="lvl-2">
<p>空间频率:指图像中视觉模式的重复频率,它控制了图像中的细节程度。高频图像具有更多细节,低频图像则较为平滑。</p>
</li>
</ul>
<h2 id="新建文档">新建文档</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>Ctrl + N</mark></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">像素</th>
<th>分辨率</th>
<th>颜色模式</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">打印</td>
<td>300</td>
<td>CMYK</td>
<td>cm</td>
</tr>
<tr>
<td style="text-align:left">显示</td>
<td>72</td>
<td>RGB</td>
<td>像素</td>
</tr>
</tbody>
</table>
<p><em>背景透明的显示：灰白格子</em></p>
<h3 id="文件打开">文件打开</h3>
<ol>
<li class="lvl-3">
<p><mark>Ctrl+O</mark> 打开文件（<strong>Ctrl</strong>：点选 <strong>Shift</strong>：连选）</p>
</li>
<li class="lvl-3">
<p>资源管理器$\rightarrow$拖拽文件</p>
</li>
</ol>
<h3 id="文件查看">文件查看</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>窗口$\rightarrow$排列</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/Photoshop_cmHe5yK04V.png" alt=""></p>
<h3 id="文件保存">文件保存</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>Ctrl+Shift+S</mark></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">保持背景透明保存为PNG</label></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">保存为GIF：文件$\rightarrow$导出$\rightarrow$存储为web格式（格式选为GIF）</label></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/%25E5%259B%25BE%25E5%2583%258F%25E6%25A0%25BC%25E5%25BC%258F.jpg" alt=""></p>
<h2 id="基本操作">基本操作</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>工具栏快捷键: <mark>Alt + 相应字母</mark></p>
</li>
<li class="lvl-2">
<p>右键点击工具$\rightarrow$工具切换</p>
</li>
<li class="lvl-2">
<p>打开滚轮缩放（编辑$\rightarrow$首选项$\rightarrow$工具$\rightarrow$滚轮缩放）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">移动</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">画笔</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">旋转</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td style="text-align:center">缩放</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">选框</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">裁剪</td>
</tr>
<tr>
<td style="text-align:center">Alt</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">Shift + 相应字母</td>
<td style="text-align:center">同类型工具切换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + <code>+-</code></td>
<td style="text-align:center">缩放</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Z</td>
<td style="text-align:center">撤回</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift+ Z</td>
<td style="text-align:center">前进</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + J</td>
<td style="text-align:center">复制图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift+ N</td>
<td style="text-align:center">新建图层</td>
</tr>
<tr>
<td style="text-align:center">Delete</td>
<td style="text-align:center">删除图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + E</td>
<td style="text-align:center">合并图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  E</td>
<td style="text-align:center">合并可见图层</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + [</td>
<td style="text-align:center">图层下移</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + ]</td>
<td style="text-align:center">图层上移</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  [</td>
<td style="text-align:center">下移最底</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +  ]</td>
<td style="text-align:center">上移最顶</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + G</td>
<td style="text-align:center">新建组</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + T</td>
<td style="text-align:center">自由变换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift +T</td>
<td style="text-align:center">再次变换</td>
</tr>
<tr>
<td style="text-align:center">Alt + Delete</td>
<td style="text-align:center">填充前景色</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Delete</td>
<td style="text-align:center">填充背景色</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Ps</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown进阶</title>
    <url>/archives/97cdff40.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>Markdown是一种轻量级标记语言，旨在提供一个易于学习和使用的文本到HTML转换工具。它提供了标题、列表、代码块、链接等简单的标记和语法，使文本排版更加简单、清晰和易读。现在，许多平台都支持Markdown，包括GitHub、Stack Overflow和Reddit。掌握Markdown是非常有用的，具体参考<a href="https://liuaoao.top/archives/1ef37645.html">Markdown-For-Typora</a>。</p>
</blockquote>
<span id="more"></span>
<h2 id="常用查表">常用查表</h2>
<table>
<thead>
<tr>
<th style="text-align:center">样式名</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">转义</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">加粗</td>
<td style="text-align:center"><code>**文本**</code> 或 <code>__文本__</code></td>
</tr>
<tr>
<td style="text-align:center">斜体</td>
<td style="text-align:center"><code>*文本*</code> 或 <code>_文本_</code></td>
</tr>
<tr>
<td style="text-align:center">删除线</td>
<td style="text-align:center"><code>~~文本~~</code></td>
</tr>
<tr>
<td style="text-align:center">下划线</td>
<td style="text-align:center"><code>&lt;u&gt;文本&lt;/u&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">上标</td>
<td style="text-align:center"><code>文本^上标^</code></td>
</tr>
<tr>
<td style="text-align:center">下标</td>
<td style="text-align:center"><code>文本~下标~</code></td>
</tr>
<tr>
<td style="text-align:center">小号字体</td>
<td style="text-align:center"><code>&lt;small&gt;小号字体&lt;/small&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">大号字体</td>
<td style="text-align:center"><code>&lt;big&gt;大号字体&lt;/big&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">高亮</td>
<td style="text-align:center"><code>==文本==</code></td>
</tr>
<tr>
<td style="text-align:center">代码块</td>
<td style="text-align:center">`代码` 或 ```代码```</td>
</tr>
<tr>
<td style="text-align:center">链接</td>
<td style="text-align:center"><code>[链接文本](链接地址)</code></td>
</tr>
<tr>
<td style="text-align:center">图片</td>
<td style="text-align:center"><code>![图片替代文本](图片链接地址)</code></td>
</tr>
<tr>
<td style="text-align:center">引用</td>
<td style="text-align:center">&gt; 引用内容</td>
</tr>
<tr>
<td style="text-align:center">分割线</td>
<td style="text-align:center">— 或 ***</td>
</tr>
<tr>
<td style="text-align:center">数学公式</td>
<td style="text-align:center"><code>$$LaTex$$</code></td>
</tr>
</tbody>
</table>
<h2 id="箭头">箭头</h2>
<p><strong>基本箭头</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\uparrow$</td>
<td style="text-align:center"><code>$\uparrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\downarrow$</td>
<td style="text-align:center"><code>$\downarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\leftarrow$</td>
<td style="text-align:center"><code>$\leftarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\rightarrow$</td>
<td style="text-align:center"><code>$\rightarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\updownarrow$</td>
<td style="text-align:center"><code>$\updownarrow$</code></td>
</tr>
<tr>
<td style="text-align:center">$\leftrightarrow$</td>
<td style="text-align:center"><code>$\leftrightarro$</code></td>
</tr>
</tbody>
</table>
<p><strong>双线箭头</strong>：基本箭头<mark>首字母大写</mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">双线箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\Uparrow$</td>
<td style="text-align:center"><code>$\Uparrow$</code></td>
</tr>
</tbody>
</table>
<p><strong>长箭头</strong>：基本箭头前+<mark>long</mark></p>
<table>
<thead>
<tr>
<th style="text-align:center">长箭头</th>
<th style="text-align:center">Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\longrightarrow$</td>
<td style="text-align:center"><code>$\longrightarrow$</code></td>
</tr>
</tbody>
</table>
<hr>
<p>继续更新ing😄</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows终端代理</title>
    <url>/archives/7b6d4a85.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="CMD">CMD</h2>
<h3 id="临时生效">临时生效</h3>
<p>命令行窗口关闭就失效</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置</span><br><span class="line">set http_proxy=http://127.0.0.1:7890</span><br><span class="line">set https_proxy=http://127.0.0.1:7890</span><br><span class="line"># 如需账户、密码</span><br><span class="line">set http_proxy_user=username</span><br><span class="line">set http_proxy_pass=password</span><br><span class="line"># 查看</span><br><span class="line">set http_proxy</span><br><span class="line">set https_proxy</span><br><span class="line"># 取消</span><br><span class="line">set http_proxy=</span><br><span class="line">set https_proxy=</span><br><span class="line">set http_proxy_user=</span><br><span class="line">set http_proxy_pass=</span><br></pre></td></tr></table></figure>
<h3 id="永久生效">永久生效</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加如下环境变量（右键我的电脑-&gt; 属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">http_proxy</td>
<td style="text-align:center"><code> http://127.0.0.1:7890</code></td>
</tr>
<tr>
<td style="text-align:center">https_proxy</td>
<td style="text-align:center"><code> http://127.0.0.1:7890</code></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/c68f9ab677f3436d8a02a8a847329137.png" alt=""></p>
<h3 id="常用快捷键">常用快捷键</h3>
<p>有的需要右键–&gt;编辑模式–&gt;开启复制粘贴</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + a</td>
<td>将光标移到行首</td>
</tr>
<tr>
<td>Ctrl + e</td>
<td>将光标移到末尾</td>
</tr>
<tr>
<td>Ctrl + u</td>
<td>删除整行</td>
</tr>
<tr>
<td>Ctrl + k</td>
<td>向后删除，从光标开始直至行尾</td>
</tr>
<tr>
<td>Alt + Backspace</td>
<td>光标向前删除一个单词</td>
</tr>
<tr>
<td>Alt + f</td>
<td>将光标移动到后一个单词</td>
</tr>
<tr>
<td>Alt + b</td>
<td>将光标移动到前一个单词</td>
</tr>
<tr>
<td>Ctrl + p</td>
<td>上一条命令</td>
</tr>
<tr>
<td>Ctrl + n</td>
<td>下一条命令</td>
</tr>
</tbody>
</table>
<h2 id="Git（永久生效）">Git（永久生效）</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 设施全局代理</span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line"># 查看代理</span><br><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br><span class="line"># 取消全局代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>重启<code>cmd</code>命令行，使用 <code>curl www.google.com</code> ，如果有内容返回，说明设置成功（不可以是 <code>ping</code> 命令进行测试）</p>
<h2 id="Reference">Reference</h2>
<p>[1]	windows设置和删除代理: <a href="https://liuxingjun.github.io/blog/2018/05/03/windows%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%88%A0%E9%99%A4%E4%BB%A3%E7%90%86">https://liuxingjun.github.io/blog/2018/05/03/windows设置和删除代理</a></p>
<p>[2]	git设置、查看、取消代理: <a href="https://www.cnblogs.com/yongy1030/p/11699086.html">https://www.cnblogs.com/yongy1030/p/11699086.html</a></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Proxy</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown-For-Typora</title>
    <url>/archives/1ef37645.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="Overview">Overview</h2>
<p><strong>Markdown</strong> is created by <a href="http://daringfireball.net/">Daring Fireball</a>; the original guideline is <a href="http://daringfireball.net/projects/markdown/syntax">here</a>. Its syntax, however, varies between different parsers or editors. <strong>Typora</strong> is using <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a>.</p>
<span id="more"></span>
<h2 id="Block-Elements">Block Elements</h2>
<h3 id="Paragraph-and-line-breaks">Paragraph and line breaks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.按一次&quot;return&quot;即可创建新段落</span><br><span class="line">2.按&quot;shift&quot;+&quot;return&quot;以创建单行中断。大多数其他减值解析器将忽略单行中断，因此，为了让其他减值解析器识别您的线路中断，您可以在行的末尾留出两个空格，或插入&quot;<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>&quot;。</span><br></pre></td></tr></table></figure>
<h3 id="Headers">Headers</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">标题在行的开头使用 1-6 个哈希字符（&#x27;#&#x27;），对应于标题级别 1-6。</span><br><span class="line">例如：</span><br><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure>
<h3 id="Blockquotes">Blockquotes</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Markdown 使用电子邮件式&gt;字符进行阻止引用。它们被呈现为:</span><br><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. This is first paragraph.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; This is second pragraph. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote.</span></span><br><span class="line"></span><br><span class="line">在 Typora 中，输入&quot;&gt;&quot;，然后输入您的报价内容将生成报价块。Typora 将为您插入适当的&quot;&gt;&quot;或线路中断。嵌套块报价（另一个区块报价中的块报价），通过添加额外的&quot;&gt;&quot;级别。</span><br></pre></td></tr></table></figure>
<h3 id="Lists">Lists</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">输入&quot;* 列表项目 &quot; 将创建一个未排序的列表 -&quot;<span class="emphasis">*&quot;符号可以替换为&quot;+&quot;或&quot;-&quot;。   输入 &#x27;1.列表项目 &#x27; 将创建一个订单列表 - 其标记源代码如下：</span></span><br><span class="line"><span class="emphasis">## un-ordered list</span></span><br><span class="line"><span class="emphasis">*</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">*</span>   Blue</span><br><span class="line"></span><br><span class="line"><span class="section">## ordered list</span></span><br><span class="line"><span class="bullet">1.</span>  Red</span><br><span class="line"><span class="bullet">2.</span> 	Green</span><br><span class="line"><span class="bullet">3.</span>	Blue</span><br></pre></td></tr></table></figure>
<h3 id="Task-List">Task List</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">任务列表是标有 [] 或 [x] （不完整或已完成） 的项目列表。例如：</span><br><span class="line"><span class="bullet">-</span> [ ] a task list item</span><br><span class="line"><span class="bullet">-</span> [ ] list syntax required</span><br><span class="line"><span class="bullet">-</span> [ ] normal <span class="strong">**formatting**</span>, @mentions, #1234 refs</span><br><span class="line"><span class="bullet">-</span> [ ] incomplete</span><br><span class="line"><span class="bullet">-</span> [x] completed</span><br></pre></td></tr></table></figure>
<h3 id="Fenced-Code-Blocks">(Fenced) Code Blocks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Typora 只支持 fences in GitHub Flavored Markdown。不支持 Markdown 中的原始代码块。   使用 fences 很容易：输入<span class="code">```和按 &#x27;return&#x27;。在```</span>之后添加可选语言标识符，我们将通过语法加亮来运行它：</span><br><span class="line">Here&#x27;s an example:</span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">function test() &#123;</span></span><br><span class="line"><span class="code">  console.log(&quot;notice the blank line before this function?&quot;);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">syntax highlighting:</span><br><span class="line"><span class="code">```ruby</span></span><br><span class="line"><span class="code">require &#x27;redcarpet&#x27;</span></span><br><span class="line"><span class="code">markdown = Redcarpet.new(&quot;Hello World!&quot;)</span></span><br><span class="line"><span class="code">puts markdown.to_html</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>
<h3 id="Math-Blocks">Math Blocks</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">您可以使用<span class="strong">**MathJax**</span>来渲染[LaTeX]数学表达式。</span><br><span class="line">要添加数学表达，输入&quot;$$&quot;并按&quot;return&quot;键。这将触发一个接受 <span class="emphasis">*Tex/LaTex*</span> 源的输入字段。例如：</span><br></pre></td></tr></table></figure>
<p>$$<br>
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>
\end{vmatrix}<br>
$$</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">In the markdown source file, the math block is a <span class="emphasis">*LaTeX*</span> expression wrapped by a pair of ‘$$’ marks:</span><br><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;<span class="emphasis">_1 \times \mathbf&#123;V&#125;_</span>2 =  \begin&#123;vmatrix&#125;</span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Tables">Tables</h3>
<p>输入<code>| First Header  | Second Header |</code> &quot;并按<code>&quot;return&quot;</code>键。这将创建一个带有两列的表。   创建表后，将焦点放在该表上将打开表的工具栏，您可以调整表大小、对齐或删除表。您还可以使用上下文菜单复制和添加/删除单个列/行。   表的完整语法如下所述，但无需详细了解完整的语法，因为表的标记源代码由 Typora 自动生成。</p>
<p>在 markdown 源代码中，它们看起来像：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure>
<p>您还可以在表中包含 inline Markdown 标记，如链接、粗体、斜体或删除线（links, bold, italics, or strikethrough）。</p>
<p>最后，通过在头行中包含冒号  (<code>:</code>)，您可以将该列中的文本定义为左对齐、右对齐或中对齐：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure>
<p>最左边的冒号表示左对齐的列；最右边的冒号表示列是右对齐的；两边的冒号表示是中心对齐的列。</p>
<h3 id="Footnotes">Footnotes</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You can create footnotes like this[^footnote].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^footnote</span>]: <span class="link">Here is the *text* of the **footnote**.</span></span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>You can create footnotes like this<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p>
<p>将鼠标悬停在“脚注”上标上，可以查看脚注的内容。</p>
<h3 id="Horizontal-Rules">Horizontal Rules</h3>
<p>在空行输入 <code>***</code> 或 <code>---</code>，并按 <code>return</code> 将画出一条水平线。</p>
<h3 id="YAML-Front-Matter">YAML Front Matter</h3>
<p>Typora 现在支持<a href="http://jekyllrb.com/docs/frontmatter/">YAML Front Matter</a>。在文章的顶部输入<code>---</code>，然后按 <code>Return</code> 引入元数据块。或者，您可以从 Typora 的顶部菜单中插入元数据块。</p>
<h3 id="Table-of-Contents-TOC">Table of Contents(TOC)</h3>
<p>输入<code>[toc]</code>并按<code>Return</code>键。这将创建一个“目录”部分。TOC从文档中提取所有标题，当您添加到文档时，它的内容会自动更新。</p>
<h2 id="Span-Elements">Span Elements</h2>
<p>Span元素将在输入后立即被解析和呈现。将光标移动到这些span元素的中间会将这些元素展开为markdown源。下面是每个span元素的语法解释</p>
<h3 id="Links">Links</h3>
<p>Markdown支持两种样式的链接:内联和引用。</p>
<p>在这两种样式中，链接文本由 [方括号] 分隔。</p>
<p>要创建内联链接，请在链接文本的右方括号后立即使用一组规则括号。在圆括号内，将URL放置在您希望链接指向的位置，并为链接提供一个可选的标题，用引号括起来。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>](<span class="link">http://example.com/ &quot;Title&quot;</span>) inline link.</span><br><span class="line"></span><br><span class="line">[<span class="string">This link</span>](<span class="link">http://example.net/</span>) has no title attribute.</span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>This is <a href="http://example.com/" title="Title">an example</a> inline link. (<code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</code>)</p>
<p><a href="http://example.net/">This link</a> has no title attribute… (<code>&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</code>)</p>
<h4 id="Internal-Links">Internal Links</h4>
<p><strong>您可以将 href 设置为headers</strong>，这将创建一个书签，允许您单击后跳转到该部分。</p>
<p>例如: 命令(在Windows上:Ctrl) +单击此 <a href="#block-elements">This link</a> 将跳转到标题块元素。要查看如何编写，请移动光标或按下⌘键单击该链接以将元素展开为 markdown 源。</p>
<h4 id="Reference-Links">Reference Links</h4>
<p>参考样式的链接使用第二组方括号，在里面你可以选择一个标签来标识链接:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>][<span class="symbol">id</span>] reference-style link.</span><br><span class="line"></span><br><span class="line">Then, anywhere in the document, you define your link label on a line by itself like this:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">id</span>]: <span class="link">http://example.com/  &quot;Optional Title Here&quot;</span></span><br></pre></td></tr></table></figure>
<p>will produce</p>
<p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p>
<p>Then, anywhere in the document, you define your link label on a line by itself like this:</p>
<p>隐式链接名称快捷方式允许您省略链接的名称，在这种情况下链接文本本身将用作名称。只需使用一组空的方括号-例如，链接单词“Google”到 <a href="http://google.com">google.com</a> 网站，你可以简单地写:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol"></span>]</span><br><span class="line">And then define the link:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">Google</span>]: <span class="link">http://google.com/</span></span><br></pre></td></tr></table></figure>
<p><a href="http://google.com/">Google</a><br>
And then define the link:</p>
<h3 id="URLs">URLs</h3>
<p>Typora允许你以链接的形式插入url，用’ &lt; <code>brackets</code> &gt; '包围。</p>
<p><code>&lt;i@typora.io&gt;</code> becomes <a href="mailto:i@typora.io">i@typora.io</a>.</p>
<p>Typora 也会自动链接标准 url。例如: <a href="http://www.google.com">www.google.com</a>。</p>
<h3 id="Images">Images</h3>
<p>图片的语法与链接类似，但它们在链接开始之前需要额外的 <code>!</code> 符号。插入图像的语法是这样的:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg &quot;Optional title&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>您可以使用拖放从图像文件或 web 浏览器插入图像。您可以通过单击图像来修改 markdown 源代码。如果使用拖放方式添加的图像与当前正在编辑的文档位于同一目录或子目录，则使用相对路径。</p>
<p>如果你正在使用 markdown 来构建网站，你可以在 YAML Front Matters 中 使用属性<code>typora-root-url</code>为你的本地计算机上的图像预览指定一个URL前缀。例如，在YAML Front Matters 输入<code>typora-root-url:/User/Abner/Website/typora.io/</code>，然后<code>![alt](/blog/img/test.png)</code>在 Typora 将被视为<code>![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)</code></p>
<p>You can find more details <a href="https://support.typora.io/Images/">here</a>.</p>
<h3 id="Emphasis">Emphasis</h3>
<p>Markdown 将星号 (<code>*</code>) 和下划线(<code> _</code>)作为强调的指示符。用一个 <code>*</code> or <code>_</code> 包装的文本将用一个 HTML <code>&lt;em&gt;</code> tag 包装。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*single asterisks*</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_single underscores_</span></span><br></pre></td></tr></table></figure>
<p>output:</p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p>GFM 会忽略单词中常用的下划线，比如:</p>
<blockquote>
<p>wow_great_stuff</p>
<p>do_this_and_do_that_and_another_thing.</p>
</blockquote>
<p>要在原本用作强调分隔符的位置产生星号或下划线，可以使用反斜杠转义:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="emphasis">*this text is surrounded by literal asterisks\*</span></span><br></pre></td></tr></table></figure>
<p>推荐使用<code>*</code>符号。</p>
<h3 id="Strong">Strong</h3>
<p>双引号<code>*</code>或<code>_</code>将导致其包含的内容被一个HTML ’ <strong> '标签包装，例如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**double asterisks**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__double underscores__</span></span><br></pre></td></tr></table></figure>
<p>output:</p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<p>推荐使用 <code>**</code>符号</p>
<h3 id="Code">Code</h3>
<p>若要指示代码的内联跨度，请用反勾引号(`)将其包装起来。与预格式化的代码块不同，代码跨度表示正常段落中的代码。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Use the <span class="code">`printf()`</span> function.</span><br></pre></td></tr></table></figure>
<p>will produce:</p>
<p>Use the <code>printf()</code> function.</p>
<p>使用<code>printf()</code>函数</p>
<h3 id="Strikethrough">Strikethrough</h3>
<p>GFM 添加了创建划线文本的语法，这是标准 Markdown 所缺少的。</p>
<p><code>~~Mistaken text.~~</code> becomes <s>Mistaken text.</s></p>
<h3 id="Underlines">Underlines</h3>
<p>Underline 是由原始 HTML 驱动的。</p>
<p><code>&lt;u&gt;Underline&lt;/u&gt;</code> becomes <u>Underline</u>.</p>
<h3 id="Emoji-😄">Emoji 😄</h3>
<p>输入带有语法的表情符号: <code>:smile:</code>。</p>
<p>用户可以按下<code>ESC</code> 键自动完成对表情符号的建议，或者在首选面板上启用后自动触发。此外，直接输入 UTF-8 表情符号也可以通过菜单栏中的 <code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>来实现。</p>
<h3 id="Inline-Math">Inline Math</h3>
<p>要使用此功能，请先在 <code>Preference</code> 面板-&gt; <code>Markdown</code> 选项卡中启用它。然后，使用 <code>$</code> 包装 TeX 命令。例如: <code>$\lim_&#123;x \to \infty&#125; \exp(-x) = 0$</code> 将被呈现为 LaTeX 命令。</p>
<p>要触发内联数学的内联预览:输入“$”，然后按“ESC”键，然后输入 TeX 命令。</p>
<p>You can find more details <a href="https://support.typora.io/Math/">here</a>.</p>
<h3 id="Subscript">Subscript</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用 <code>~</code> 包装下标内容。例如: <code>H~2~O</code>, <code>X~long\ text~</code>/</p>
<h3 id="Superscript">Superscript</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用  <code>^</code>  包装上标内容。例如: <code>X^2^</code>.</p>
<h3 id="Highlight">Highlight</h3>
<p>要使用此功能，请先在<code>Preference</code> 面板-&gt;<code>Markdown</code> 选项卡中启用它。然后，使用 <code>==</code> 包装高亮内容。例如: <code>==highlight==</code>.</p>
<h2 id="HTML">HTML</h2>
<p>您可以使用 HTML 来样式化纯 Markdown 不支持的内容。例如，使用 <code>&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;</code> 来添加红色文本。</p>
<h3 id="Embed-Contents">Embed Contents</h3>
<p>一些网站提供基于框架的嵌入代码，你也可以将其粘贴到 Typora 中。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">&#x27;265&#x27;</span> <span class="attr">scrolling</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">title</span>=<span class="string">&#x27;Fancy Animated SVG Menu&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#x27;</span> <span class="attr">frameborder</span>=<span class="string">&#x27;no&#x27;</span> <span class="attr">allowtransparency</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">allowfullscreen</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;width: 100%;&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Video">Video</h3>
<p>你可以使用<code>&lt;video&gt;</code>HTML标签来嵌入视频。例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Other-HTML-Support">Other HTML Support</h3>
<p>You can find more details <a href="https://support.typora.io/HTML/">here</a>.</p>
<h2 id="Reference">Reference</h2>
<p>[1]	Typora的Markdown语法: <a href="https://support.typoraio.cn/zh/Markdown-Reference">https://support.typoraio.cn/zh/Markdown-Reference</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Here is the <em>text</em> of the <strong>footnote</strong>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>浅层语义分析（LSA）</title>
    <url>/archives/d42a069d.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<p><strong>前言</strong></p>
<p><mark>浅层语义分析（LSA）</mark> 是一种自然语言处理中用到的方法，其通过“矢量语义空间”来提取文档与词中的“概念”，进而分析文档与词之间的关系。LSA的基本假设是，如果两个词多次出现在同一文档中，则这两个词在语义上具有相似性。LSA使用大量的文本上构建一个矩阵，这个矩阵的一行代表一个词，一列代表一个文档，矩阵元素代表该词在该文档中出现的次数，然后再此矩阵上使用奇异值分解（SVD）来保留列信息的情况下减少矩阵行数，之后每两个词语的相似性则可以通过其行向量的cos值（或者归一化之后使用向量点乘）来进行标示，此值越接近于1则说明两个词语越相似，越接近于0则说明越不相似。</p>
<span id="more"></span>
<p>LSA最早在1988年由 <a href="https://en.wikipedia.org/wiki/Scott_Deerwester">Scott Deerwester</a>, <a href="https://en.wikipedia.org/wiki/Susan_Dumais">Susan Dumais</a>, <a href="https://en.wikipedia.org/wiki/George_Furnas">George Furnas</a>, <a href="https://en.wikipedia.org/wiki/Richard_Harshman">Richard Harshman</a>, <a href="https://en.wikipedia.org/wiki/Thomas_Landauer">Thomas Landauer</a>, <a href="https://en.wikipedia.org/w/index.php?title=Karen_Lochbaum&amp;action=edit&amp;redlink=1">Karen Lochbaum</a> and <a href="https://en.wikipedia.org/w/index.php?title=Lynn_Streeter&amp;action=edit&amp;redlink=1">Lynn Streeter</a>提出，在某些情况下，LSA又被称作潜在语义索引（LSI）。</p>
<p><strong>概述</strong></p>
<p><strong>词-文档矩阵（Occurences Matrix)</strong></p>
<p>LSA 使用词-文档矩阵来描述一个词语是否在一篇文档中。词-文档矩阵式一个稀疏矩阵，其行代表词语，其列代表文档。一般情况下，词-文档矩阵的元素是该词在文档中的出现次数，也可以是是该词语的tf-idf(term frequency–inverse document frequency)。</p>
<p>词-文档矩阵和传统的语义模型相比并没有实质上的区别，只是因为传统的语义模型并不是使用“矩阵”这种数学语言来进行描述。</p>
<p><strong>降维</strong></p>
<p>在构建好词-文档矩阵之后，LSA将对该矩阵进行降维，来找到词-文档矩阵的一个低阶近似。降维的原因有以下几点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>原始的词-文档矩阵太大导致计算机无法处理，从此角度来看，降维后的新矩阵式原有矩阵的一个近似。</p>
</li>
<li class="lvl-2">
<p>原始的词-文档矩阵中有噪音，从此角度来看，降维后的新矩阵式原矩阵的一个去噪矩阵。</p>
</li>
<li class="lvl-2">
<p>原始的词-文档矩阵过于稀疏。原始的词-文档矩阵精确的反映了每个词是否“出现”于某篇文档的情况，然而我们往往对某篇文档“相关”的所有词更感兴趣，因此我们需要发掘一个词的各种同义词的情况。</p>
</li>
</ul>
<p>降维的结果是不同的词或因为其语义的相关性导致合并，如：</p>
<p>{(car), (truck), (flower)} --&gt; {(1.3452 * car + 0.2828 * truck), (flower)}</p>
<p>将维可以解决一部分同义词的问题，也能解决一部分二义性问题。具体来说，原始词-文档矩阵经过降维处理后，原有词向量对应的二义部分会加到和其语义相似的词上，而剩余部分则减少对应的二义分量。</p>
<p><strong>推导</strong></p>
<p>假设X是词-文档矩阵，其元素（i,j）代表词语i在文档j中的出现次数，则X矩阵看上去是如下的样子：</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240431.png" alt=""></p>
<p>可以看到，每一行代表一个词的向量，该向量描述了该词和所有文档的关系。</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240905.png" alt=""></p>
<p>相似的，一列代表一个文档向量，该向量描述了该文档与所有词的关系。</p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191240123.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242577.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242830.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Humble-LiuAo/Study-notes/main/img/202204191242875.png" alt=""></p>
<p>**代码：**<a href="https://github.com/Humble-LiuAo/Machine-Learning/tree/main/Data%20Mining/LSA">https://github.com/Humble-LiuAo/Machine-Learning/tree/main/Data Mining/LSA</a></p>
<p><strong>应用</strong></p>
<p>低维的语义空间可以用于以下几个方面:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在低维语义空间可对文档进行比较，进而可用于文档聚类和文档分类。</p>
</li>
<li class="lvl-2">
<p>在翻译好的文档上进行训练，可以发现不同语言的相似文档，可用于跨语言检索。</p>
</li>
<li class="lvl-2">
<p>发现词与词之间的关系，可用于同义词、歧义词检测。.</p>
</li>
<li class="lvl-2">
<p>通过查询映射到语义空间，可进行信息检索。</p>
</li>
<li class="lvl-2">
<p>从语义的角度发现词语的相关性，可用于“选择题回答模型”（multi choice qustions answering model）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
        <category>Data mining</category>
      </categories>
      <tags>
        <tag>Machine learning</tag>
        <tag>语义分析</tag>
        <tag>Data mining</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda-Python环境安装</title>
    <url>/archives/eabeff19.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
<h2 id="查询版本信息">查询版本信息</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>驱动器版本：右键NVIDIA–&gt;系统信息（点击开始菜单，搜索<code>dxdiag</code>）</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应cuda版本：</p>
<p><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a></p>
</li>
</ul>
<span id="more"></span>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应tensorflow版本：</p>
<p><a href="https://tensorflow.google.cn/install/source_windows?hl=en#gpu">https://tensorflow.google.cn/install/source_windows?hl=en#gpu</a></p>
</li>
<li class="lvl-2">
<p>对应pytorch版本：</p>
<p><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p>
</li>
</ul>
<h2 id="安装Anaconda">安装Anaconda</h2>
<p>下载网址：<a href="https://repo.anaconda.com/archive/">https://repo.anaconda.com/archive/</a><br>
<strong>安装事项</strong>：</p>
<ol>
<li class="lvl-3">
<p>修改路径</p>
</li>
<li class="lvl-3">
<p>不要勾选“Add Anaconda to the system PATH environment variable”。</p>
</li>
<li class="lvl-3">
<p>添加上：<mark>Anaconda3、Anaconda3/Scripts、Anaconda3/Library/bin</mark>这3个文件夹的路径（用户+系统的Path，环境变量打开方式为：计算机–属性–高级系统设置–环境变量）</p>
</li>
</ol>
<h3 id="设置镜像源">设置镜像源</h3>
<p>清华镜像网址：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p>
<p>参考：<a href="https://www.cpci.dev/anaconda-mirrors-configure/">https://www.cpci.dev/anaconda-mirrors-configure/</a></p>
<ol>
<li class="lvl-3">
<p>生成 <mark>.condarc</mark> 文件： <code>conda config --set show_channel_urls yes</code>（C:\users\username\）</p>
</li>
<li class="lvl-3">
<p>清华源复制到 <mark>.condarc</mark> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">ssl_verify: false</span><br><span class="line"># 命令行</span><br><span class="line">conda clean -i</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>不走镜像、代理设置</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line"><span class="bullet">  -</span> defaults</span><br><span class="line">show<span class="emphasis">_channel_</span>urls: true</span><br><span class="line">proxy<span class="emphasis">_servers:</span></span><br><span class="line"><span class="emphasis">  http: 127.0.0.1:7890</span></span><br><span class="line"><span class="emphasis">  https: 127.0.0.1:7890</span></span><br><span class="line"><span class="emphasis">ssl_</span>verify: false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="conda安装tensorflow">conda安装tensorflow</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n tf python=3.6</span><br><span class="line">activate tf</span><br><span class="line">conda install tensorflow-gpu=1.9.0</span><br><span class="line"># 根据python版本默认安装 </span><br><span class="line">conda install tensorflow-gpu</span><br><span class="line"></span><br><span class="line">pip install --upgrade tensorflow</span><br><span class="line">python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span><br></pre></td></tr></table></figure>
<h3 id="高版本安装">高版本安装</h3>
<p>需要 <strong>pip</strong>安装 <strong>tensorflow</strong>：<a href="https://tensorflow.google.cn/install/pip?hl=en#windows-native">https://tensorflow.google.cn/install/pip?hl=en#windows-native</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge cudatoolkit=11.2 cudnn=8.1.0</span><br><span class="line">#如果上面这个执行失败了，多执行几次</span><br><span class="line">#如果自己的显卡支持，安装了上面的两个配置后，再安装下面的tensorflow-gpu 2.7.0版本的话</span><br><span class="line">#就可以直接显示gpu版本的状态为为true</span><br><span class="line">pip install tensorflow-gpu==2.7.0</span><br><span class="line">pip install &quot;tensorflow&lt;2.11&quot;</span><br><span class="line"># 走清华镜像</span><br><span class="line"> -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># 设置timeout</span><br><span class="line">pip --default-timeout=600 install &quot;tensorflow&lt;2.11&quot; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"># Verify install:</span><br><span class="line">#python</span><br><span class="line">#impor tensorflow as tf</span><br><span class="line">#print(tf.config.list_physical_devices(&#x27;GPU&#x27;))</span><br></pre></td></tr></table></figure>
<h2 id="conda安装pytorch">conda安装pytorch</h2>
<p>选择版本安装：<a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n pytorch python=3.8</span><br><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>
<p><strong>CondaSSLError: OpenSSL appears to be unavailable on this machine. OpenSSL is required to download and install packages. <mark>解决的方法</mark></strong></p>
<ol>
<li class="lvl-3">
<p>到你的anaconda的安装目录位置：比如<br>
<img src="https://gitee.com/humble_ao/Image/raw/master/c6c98a6807fd4b559bac2703f3399427.png" alt=""></p>
</li>
<li class="lvl-3">
<p><code>D:\ProgramData\Anaconda3\Library\bin</code>，找到如下两个DLL的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libcrypto-1_1-x64.dll</span><br><span class="line">libssl-1_1-x64.dll</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/humble_ao/Image/raw/master/db37a06081a944b6ad430fad2c9a5336.png" alt=""></p>
</li>
<li class="lvl-3">
<p>复制到 <code>D:\ProgramData\Anaconda3\DLLs</code><br>
<img src="https://gitee.com/humble_ao/Image/raw/master/b76e975a080d48a8bf437c02f17c4178.png" alt=""></p>
</li>
<li class="lvl-3">
<p>重启下shell</p>
</li>
</ol>
<h2 id="测试">测试</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tf</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">if</span> tf.test.gpu_device_name():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Default GPU Device: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(tf.test.gpu_device_name()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please install GPU version of TF&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="built_in">print</span>(tf.test.gpu_device_name())</span><br><span class="line"><span class="built_in">print</span>(tf.test.is_gpu_available())</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytorch</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">flag = torch.cuda.is_available()</span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CUDA可使用&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CUDA不可用&quot;</span>)</span><br><span class="line"></span><br><span class="line">ngpu= <span class="number">1</span></span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;驱动为：&quot;</span>,device)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;GPU型号： &quot;</span>,torch.cuda.get_device_name(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h2 id="conda常用命令">conda常用命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version:</span><br><span class="line">conda -V</span><br><span class="line">env:</span><br><span class="line">conda env list</span><br><span class="line">conda create -n env python=3.6 </span><br><span class="line">conda remove -n env --all</span><br><span class="line">conda deactivate</span><br><span class="line">Package:</span><br><span class="line">conda list</span><br><span class="line">conda list -n your_env_name</span><br><span class="line">conda install -n env_name package_name</span><br><span class="line">conda update -n env_name package_name</span><br><span class="line">conda install numpy pandas matplotlib scikit-learn seaborn scikit-image opencv</span><br><span class="line">conda update conda</span><br><span class="line">conda update anaconda-navigator</span><br><span class="line">conda update navigator-updater</span><br><span class="line">conda update --all</span><br><span class="line"></span><br><span class="line">numpy matplotlib scikit-image scikit-learn tqdm pandas global-land-mask netCDF4 gdal</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
</search>
